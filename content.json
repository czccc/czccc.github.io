{"pages":[{"title":"","text":"","link":"/404.html"},{"title":"常用软件汇总","text":"系统工具 软件 首页 备注 Bandizip https://www.bandizip.com/ 最新版需付费 Clover http://cn.ejie.me/ 绿色版v3.5.4 Edge chromium https://www.microsoft.com/en-us/edge 下载地址 Chrome https://www.google.com/intl/zh-CN/chrome/ PowerShell https://github.com/PowerShell/PowerShell ShadowSocksR https://ssr.tools/175 SSR-Windows, SSRR Acrobat https://get.adobe.com/cn/reader/ Windows 运行库 最新支持的 Visual C++ 下载 整合版1, 整合版2 OneQuick https://onequick.org/ 应用商店版 桌面版 Snipaste https://zh.snipaste.com/ 应用商店版 QuickLook https://github.com/QL-Win/QuickLook 应用商店版 releases TranslucentTB https://github.com/TranslucentTB/TranslucentTB 应用商店版 releases AutoHotKey https://www.autohotkey.com/ CCleaner https://www.ccleaner.com/ Everything https://www.voidtools.com/zh-cn/ PowerToys https://github.com/microsoft/PowerToys 常用软件 软件 首页 备注 QQ https://im.qq.com/pcqq/ TIM https://tim.qq.com/ WeChat https://weixin.qq.com/ 网页版 百度网盘 https://pan.baidu.com/disk/home 客户端 迅雷极速版 https://x.xunlei.com/ 绿色精简版 纯净最终版 FileZilla https://filezilla-project.org/ 坚果云 https://www.jianguoyun.com/ 个人主页 客户端 MathType https://www.mathtype.cn/ Mathpix https://mathpix.com/ Mendeley https://www.mendeley.com/ 客户端 网页端 欧陆词典 https://www.eudic.net/v4/en/app/eudic Typora https://typora.io/ 腾讯会议 https://meeting.tencent.com/ 客户端 Zoom会议 https://zoom.us/zh-cn/feature.html 客户端 字体 字体 首页 备注 FiraCode https://github.com/tonsky/FiraCode 下载页 Sarasa-Gothic https://github.com/be5invis/Sarasa-Gothic 下载页 Noto https://www.google.com/get/noto/ YaHei-Consolas-Hybrid https://github.com/yakumioto/YaHei-Consolas-Hybrid-1.12 V1.12 影音 软件 首页 备注 PotPlayer https://potplayer.daum.net/ 中文社区版 绿色版 foobar https://www.foobar2000.org/ 中文社区, foobaka 网易云音乐 https://music.163.com/ 应用商店版 QQ音乐 https://y.qq.com/ 爱奇艺 https://www.iqiyi.com/ 游戏 软件 首页 备注 Steam https://store.steampowered.com/ 客户端 WeGame https://www.wegame.com.cn/ 客户端 UbiSoft https://www.ubisoft.com.cn/ Uplay https://uplay.ubisoft.com/en-GB Epic https://www.epicgames.com/store/zh-Hant/ Moonlight https://moonlight-stream.org/ Qt, Android, Play Store MuMu模拟器 http://mumu.163.com/ 网易UU加速器 https://uu.163.com/ 腾讯加速器 https://jiasu.qq.com/ 编程软件 软件 首页 备注 Git https://git-scm.com/ 下载 VSCode https://code.visualstudio.com/ Github Windows Terminal https://github.com/microsoft/terminal 应用商店 Visual Studio https://visualstudio.microsoft.com/zh-hans/ 下载 Cmder https://cmder.net/ Github JetBrains https://www.jetbrains.com/ IDEA, PyCharm WSL https://docs.microsoft.com/en-us/windows/wsl/install-win10 ArchWSL, Manjaro Matlab https://www.mathworks.com/products/matlab.html Anaconda https://www.anaconda.com/ TUNA Docker https://www.docker.com/ Docker-Hub Java https://www.java.com/zh_CN/ 下载, Oracle-JDK, OpenJDK Python https://www.python.org/ 下载 Rust https://www.rust-lang.org/ Github, std-doc, docs MySQL https://www.mysql.com/cn/ 下载 Node.js https://nodejs.org/en/ 下载 装机工具 软件 首页 备注 WePE http://www.wepe.com.cn/ Rufus https://rufus.ie/ 卡硬工具箱 http://www.kbtool.cn/ 图吧工具箱 http://www.tbtool.cn/ CPU-Z https://www.cpuid.com/softwares/cpu-z.html GPU-Z https://www.techpowerup.com/gpuz/ EasyUEFI https://www.easyuefi.com/index-cn.html 需付费 分区助手 https://www.disktool.cn/download.html 轻松备份 https://www.disktool.cn/backup/download.html 口袋系统(WinToGo) https://www.disktool.cn/wintogo.html 软媒魔方 https://mofang.ruanmei.com/ 不建议使用 镜像 镜像 首页 备注 清华大学开源软件镜像站 https://mirrors.tuna.tsinghua.edu.cn/ 帮助 Archlinux, AUR, Archlinuxcn, Arch4edu, Ubuntu Anaconda, Pypi, Rustup 南京大学开源镜像站 https://mirrors.nju.edu.cn/ 帮助 archlinux, archlinuxcn, Manjaro Anaconda, Pypi, Rustup, Rust-Crates 上海交通大学软件源镜像服务 https://mirrors.sjtug.sjtu.edu.cn/#/ 中国科学技术大学 http://mirrors.ustc.edu.cn/ 帮助 阿里云官方镜像站 https://developer.aliyun.com/mirror/ 华为开源镜像站 https://mirrors.huaweicloud.com/ 腾讯开源镜像站 https://mirrors.cloud.tencent.com/ 网易开源镜像站 http://mirrors.163.com/","link":"/Software/index.html"},{"title":"about","text":"Cheng 我的名字叫吉良吉影，33岁。 住在杜王町东北部的别墅区一带，未婚。 我在龟友连锁店服务。 每天都要加班到晚上8点才能回家。 我不抽烟，酒仅止于浅尝。 晚上11点睡，每天要睡足8个小时。 睡前，我一定喝一杯温牛奶，然后做20分钟的柔软操，上了床，马上熟睡。 一觉到天亮，决不把疲劳和压力留到第二天。 医生都说我很正常。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"leetcode","text":"","link":"/leetcode/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"code-snippets","text":"Banner 1234567&lt;article class=&quot;message message-immersive is-primary&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-globe-asia mr-2&quot;&gt;&lt;/i&gt;This article is also available in &lt;a href=&quot;{% post_path zh-CN/FAQ %}&quot;&gt;简体中文&lt;/a&gt;.&lt;/div&gt;&lt;/article&gt; This article is also available in 简体中文. 12345&lt;article class=&quot;message is-primary&quot; style=&quot;font-size:inherit&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;I can't generate my site. / I met some errors when I generate my site.&lt;/div&gt;&lt;/article&gt; I can't generate my site. / I met some errors when I generate my site.","link":"/p/caf566a4/"},{"title":"分布式 raft 算法总结","text":"Raft 是一个分布式共识算法，相较于之前普遍使用的 Paxos 算法，Raft 更侧重于算法的简洁和易于理解，并具备支持工业级应用所需的性能。 Raft 有几个区别于其他算法的特性： Strong Leader：日志只能从 Leader 发送给 Follower，并覆盖掉 Follower 处与 Leader 不一致的日志。 Leader Election：Raft 使用随机的延时进行 Leader 的选举，这避免了一些冲突，并使得算法变得更简单。 Membership changes：Raft 使用 joint consensus 进行在前后两组节点之间进行无缝转变，节点变化的过程对用户而言是透明的。 状态机模型 Raft 的状态机模型如下所示： 简单的说，一个 Client 的请求过程分为如下四步： Client 向 Server Leader 发送一个请求 Leader 按共识协议将此请求作为一个 Log 存储在一个序列中，并开始在多个节点中进行复制 如果对此请求达成共识，便将其应用到状态机中 从状态机中返回相应的结果给 Client Client 的请求可能并不会被按时处理 (Leader 离线、网络延时、一直未达成共识等)，对 Client 而言，一个比较合理的操作是超时重试。 但是，Raft 协议本身并不负责处理由于 Client 超时重试而带来的重复日志，这一部分逻辑需要交由上层实体来控制。 Raft 算法综述 Raft 算法需要实现的，就是上述步骤中的第 2 步，也即，Raft 算法需要对传入的 Log 日志在不同的节点间尝试达成共识，如果能达成共识，则将此 Log 应用到状态机中，如果无法达成共识，则废弃此 Log。 Raft 算法主要可以分为如下几个部分： Leader election：也即实现中所使用的 Request vote，主要用于发送选举请求，处理选举结果。这一步往往出现在节点刚初始化时或者长时间未接收到来自于 Leader 的消息。 Log replication：也即实现中所使用的 Append entries，主要用于 Leader 向 Follower 发送日志项，维护 Follower 的心跳时间以免超时重新进行选举等。 Log compaction：也即实现中所使用的 Install snapshot，主要用于压缩日志项，从而减少开销，如果 Follower 的日志落后太多，为了减少网络开销以及快速进行同步，Leader 会向 Follower 直接发送状态机的快照副本，未在快照中的数据项再通过 Log replication 进行同步。 基本概念 任期 term： 数据状态 对于一个 Raft 节点而言，需要维护自身的一些状态，这些状态在论文的 Figure 2 中，主要分了三类： 在所有节点上都需要使用的可持久化状态，此类状态每次在更改之后就需要保存到持久化存储中，并在节点重启后载入对应的状态： currentTerm：节点当前的 term，初始时为 0，只增不减，每次收到 RPC 请求时，如果 RPC 中的 term 比 currentTerm 大，便更新 currentTerm = term voteFor：节点在 Leader 选举中所投的 Candidate ID，如果未投票则为 null log[]：节点的日志序列，每个日志都包含一个 command，以及 command 对应的 term 在所有节点上都需要使用的临时状态，此类状态不必持久化，在每次节点重启后重新初始化即可： commitIndex：已知的日志序列中可提交的日志 Index 的最大值。初始值为 0， 只增不减 lastApplied：已应用到状态机的日志 Index。初始值为 0，随 commitIndex 递增 只在 Leader 节点上使用的临时状态，此类状态不必持久化，并只有选举成为 Leader 后进行初始化即可： nextIndex[]：对于每个节点，存储需要向其发送的日志项的下一个日志的 Index。初始时为 Leader 的最大的 Log Index + 1 matchIndex[]：对于每个节点，保存已知的复制成功的 Log Index 的最大值。初始时为 0，随着日志复制过程递增 （Figure 13 增加了快照功能之后）增加两个在所有节点上都需要使用的可持久化状态，状态同第一类一样需要持久化保存和载入： lastIncludedIndex：节点所保存的快照中最后一个日志项的 Index，同时说明 所有 index &lt;= lastIncludedIndex 的日志项已经被废弃 lastIncludedTerm：节点所保存的快照中最后一个日志项的 Term Leader Election Raft 使用 Strong Leader 作为共识协议的发起点，因此需要进行选举过程。选举过程的发起需要条件，也就是如果一个 Follower 在设定的时间间隔内一直无法收到 Leader 的消息（心跳），则可以认为之前的 Leader 已经下线或者出现故障， Follower 便会将自身的 currentTerm += 1 ，并转变为 Candidate，向所有的节点发送 RequestVote 的 RPC 请求。 RPC 请求中所包含的参数为： term：Candidate 的 currentTerm candidateId：Candidate 的身份 lastLogIndex： Candidate 最后一条日志的 Index lastLogTerm：Candidate 最后一条日志的 term 同样的，作为此 RPC的接收方，需要对其进行处理并回复，处理的结果如下： term：最新的 term，也即为 Candidate 发送的 RPC 中的 term 与节点自身 currentTerm 中的最大值。 voteGranted：是否给此 RPC 请求投票，投票时为 true 具体的处理逻辑如下： 如果 RPC 中的 term 大于节点的 currentTerm，可知当前的 currentTerm 任期已经结束，因此节点首先更新自身的 currentTerm = term，将身份改为 Follower，并清除 voteFor 如果 RPC 中的 term 小于节点的 currentTerm，不投票，并返回更新的 currentTerm 此时，节点的 currentTerm 一定等于 RPC 中的 term，是否投票从以下两方面考虑： RPC中的最新日志信息：只有当RPC中的日志信息比节点的日志信息更新时，才会投票。这个“更新”的意思为：RPC中的 lastLogTerm 大于节点最新日志的 term，或者RPC中的 lastLogTerm 等于节点最新日志的 term，但RPC中的 lastLogIndex 大于节点最新日志的 index。这一点保证了 Follower 只会给知道的信息比它多的节点投票，从而保证了日志记录的完整性 是否在当前任期已经投票：只有在当前任期内此节点未投票或已经给此RPC的id投票时才会确定投票。也即为先到先得。 Candidate 需要收集所有的 RPC 回复，并累计所得票数，只有所得的票数超过总数的一半（majority）时，节点才可以成为新一任的 Leader。 安全性保证：对比 commitIndex 的算法逻辑，Leader 只有在超过一半的节点都确认了一个Log的时候，才会将其提交，也就是说：所有提交的日志一定会出现的超过一半以上的节点中。而在选举过程中，如果一个节点不包含这条已经提交的日志，那么它无论无何都无法获得超过一半的选票，也即无法成为 Leader。这保证了所有提交过的日志不会被覆盖，保证了所有节点中应用到状态机的日志序列的一致性。相反地，未提交的日志都有一定的可能会被丢弃。 Log Replication Raft 算法需要实现日志在不同节点间的同步，以及保证所有提交的日志都是一致的，不存在乱序和差错。因此，Raft 节点需要定期与其他节点进行交互，这个交互是通过 RPC 请求完成的，也就是下面将要说的 AppendEntries。在实际使用中，Leader 需要定期发送此 RPC，目的有两个，一是将新增的 Log 数据复制到 Follower 中，另一个是为了保证 Leader 的存活，毕竟如果 Follower 长时间收不到 Leader 的消息，就会主动发起选举。 AppendEntries RPC所使用的参数如下： term：Leader 当前的任期 leaderId：Leader 的身份 prevLogIndex：在 entries[] 中所包含日志项的前一个日志的 index prevLogTerm：在 entries[] 中所包含日志项的前一个日志的 term entries[]：当前 RPC 中所包含的日志项（可以一次发送多个日志以提高效率）。可以为空，表示没有最新的日志项需要发送，只更新 Follower 的心跳。 leaderCommit：Leader 当前所提交的日志的 Index，Follower 收到此数据之后便可更新自身的 comitIndex，并向自己的状态机应用相关的日志 RPC 的结果所包含的字段如下： term：最新的 term，也即为 Candidate 发送的 RPC 中的 term 与节点自身 currentTerm 中的最大值。 success：此次日志复制是否成功，在有冲突时返回 false 作为 RPC 请求的接收方，处理的逻辑如下： 如果 RPC 中的 term 大于节点的 currentTerm，可知当前的 currentTerm 任期已经结束，因此节点首先更新自身的 currentTerm = term，将身份改为 Follower 如果 RPC 中的 term 小于节点的 currentTerm，说明此 RPC 来自旧的 Leader，不复制日志，返回更新的 currentTerm 此时，节点的 currentTerm 一定等于 RPC 中的 term，节点先更新自身的心跳计时，之后考虑日志复制（如果不包含日志则直接返回成功）： **由 Raft 的日志性质，一条日志可以由 index 和 term 唯一确定。**这是由于在每一个 term 内，最多只会产生一个 Leader，因此在相同任期内，日志总是由 Leader 首先接收并复制到 Follower 中，那么 Leader 中日志序列的顺序便是当前 term 中所有日志的顺序。因此，如果两个日志的 term 不同，那么这两条日志一定不是同一个日志；如果两个日志 term 相同，但 index 不同，同样也不是同一条日志。只有 index 和 term 都相同的日志，才能说明此条日志是从相同的 Leader 处复制得到，也就是同一条日志。 由于日志复制顺序总是从前向后，只有前面的日志都复制成功后，才会复制下一条日志，因此如果在某条日志处确认了其 index 和 term 都和 RPC 中的一致，那么只需要考虑此条日志之后的日志进行复制，再次之前的日志可以确定都已经与 Leader 处的一致。 Leader 在 RPC 中会附上 prevLogIndex 和 prevLogTerm，作为一个日志的锚点，如果 Follower 处存在相同 index 和 term 的日志，便可以进行之后的日志复制，Follower 便可以将 RPC 中的 entries[] 批量添加到此锚点日志的后面，并在 RPC 中确认复制成功（success = true）。最后，Follower 根据 Leader 的leaderCommit，更新自己本地的 commitIndex，并提交相关的日志项。 如果 prevLogIndex 和 prevLogTerm 无法对应到 Follower 的日志，说明尚未找到同步点，返回失败（success = false） 在 Leader 处，当接收到了 Follower 的 RPC 的回复后，在此，我们假设此 Follower 的 ID 为 i： 如果 reply 中的 term 更大，则变为 Follower 如果 success == true：说明复制成功，Leader 需要维护 Follower 的状态，也就是 nextIndex 和 matchIndex： 在这里令发送的日志项的最后一个日志的 index 为 upper_log_index 更新 nextIndex[i] 为已经发送的日志中的最大的 index + 1。即 nextIndex[i] = upper_log_index + 1。 更新 matchIndex[i] 为已经发送的日志中的最大的 index，即 matchIndex[i] = upper_log_index。 根据 matchIndex 进行判断，如果存在超过一半的节点的 matchIndx[i] &gt; N，则可以更新 Leader 的 commitIndex，并应用相关日志到状态机。 如果 success == false：说明复制失败，也就是没有找到同步点： 递减 nextIndex[i]，后退一条日志继续尝试同步 。即 nextIndex[i] -= 1。 一些讨论： 初始时，nextIndex 均初始化为 最大的 Log 的 index + 1，因此在第一次发送 AppendEntries RPC 时，prevLogIndex 等于 nextIndex[i] - 1，也即为最大的 Log index，因此此时 entries 为空，即不包含日志数据。 日志的复制过程是从后向前，逐渐尝试进行同步的。对于不同的节点，每次的 RPC 参数会不一样（根据 nextIndex 确定）。 如何快速找到日志中不一致的地方？这是 Raft 中所使用的一种优化。如果按照原协议，每次日志复制不成功就仅仅将 nextIndex 减一，如果日志项比较多，可能会需要很长时间才能完成同步。在这里介绍一个比较常用的回滚算法，加快同步的速度： 在 AppendEntries RPC 的回复中新增两个字段：conflictIndex 和 conflictTerm，其中，conflictTerm 为 Follower 处与 Leader 发送的 prevLogIndex 所冲突的日志项的 term，conflictIndex 为 Follower 处日志的 term 等于 conflictTerm 的第一条日志的 index Leader 接收到这个回复后，检查自己是否包含 conflictIndex 和 conflictTerm 的此条日志，如果包含此条日志，则可以确定冲突的日志在此之后，因此将 nextIndex[i] 更新为 Leader 处的 conflictTerm 的最后一条日志的 index；如果不包含，则冲突的日志在此之前，则将 nextIndex[i] 更新为 Leader 处的 conflictTerm 的第一条日志的 index。 再次补充：为什么将 nextIndex[i] 更新为 Leader 处的 conflictTerm 的最后一条日志的 index？首先，如果 Leader 包含 conflictIndex 和 conflictTerm 的此条日志，同时说明 Follower 也有此条日志，因此日志复制失败的原因一定是因为这个 term 下，Follower 处的日志条目不全，否则冲突的位置不会发生在此 term 内。因此将 nextIndex 更新到这个 term 的最后一条日志的 index，之后再次尝试进行同步。 这样的方式可以保证一次跳过一个任期，而不仅仅是一条日志，因此大大加快了同步的速度。 Log Compaction 随着 Raft 节点日志的不断增加，过多的日志会影响节点的性能开销，因此对日志数据进行压缩是很有必要的。在实现了 Leader Election 和 Log replicate 之后，节点已经实现了基本的 Raft 算法所需的内容，而日志压缩功能则是更进一步，补充之前的协议中缺失的部分内容。 首先，需要明确的是，为什么可以进行日志压缩？回想一下之前所提到的内容，Raft 协议主要关心的并不是全部日志，由于日志顺序的一致性，Raft 协议只需要关注于最新的日志（或最新一部分的日志），而对于陈旧的日志是不会再使用的。比如说，我们选取一个日志作为锚点，那么只要能将此锚点日志对应起来，便可以保证日志的一致性，因此可以丢弃此锚点日志之前的数据，取而代之保存相应的状态机的快照副本。从而，在进行日志复制时，如果需要复制的日志位于此锚点日志之后，那么继续像之前一样传递日志数据；如果位于锚点日志之前，那么首先向其发送快照副本，再发送快照副本之后的日志数据，同样能保证日志的一致性。 其次，什么时候需要创建快照副本？由于创建快照的目的是为了压缩日志，因此可以设置一些阈值，比如已提交但未压缩的日志文件超过一定的大小，或者简单的通过日志数目来衡量是否应该压缩日志。快照的创建是一个本地命令，也就是说不同的节点处可能会存在不同的快照（但均为相同的日志序列，只不过快照所压缩的日志长度有所不同）。 如何确定快照所包含的日志序列？由日志的一致性，可以通过保存快照中最后一条日志的 index 和 term 实现。因此需要向节点添加两个额外的状态，lastIncludedIndex 和 lastIncludedTerm，并且同样需要持久化。 创建快照后，由于之前的日志被丢弃，因此日志的索引范围也将发生变化。简单地说，创建快照之前，index 为 i 的日志在 log 中的 i - 1 处（index 从 1 开始，而 log 从 0 开始索引），创建快照后，index 为 i 的日志在 log 中的 i - 1 - lastIncludedIndex 处，而对于 index &lt;= lastIncludedIndex 的日志不再存在，只能通过复制完整的快照文件。 在进行日志同步时，如果需要 index &lt;= lastIncludedIndex 的日志，将不再通过 AppendEntries RPC 发送日志数据，取而代之我们使用第三种 RPC 命令 InstallSnapshot ，用于发送快照副本文件。 InstallSnapshot RPC 所需的参数如下： term：Leader 的当前任期 leaderId： Leader 的身份 lastIncludedIndex：快照所包含的最后一条日志的 index lastIncludedTerm：快照所包含的最后一条日志的 term offset：快照文件可能会比较大，需要分片发送，offset 标识当前的偏移位置 data[]：此次发送的快照数据 done：是否已经发送完毕，如果后面不再有数据，则发送 true RPC 的回复只包含 term 一项，用于表示是否成功收到此 RPC。 对于 RPC 请求的处理过程如下： 如果 RPC 中的 term 大于节点的 currentTerm，可知当前的 currentTerm 任期已经结束，因此节点首先更新自身的 currentTerm = term，将身份改为 Follower 如果 RPC 中的 term 小于节点的 currentTerm，说明此 RPC 来自旧的 Leader，不复制快照，返回更新的 currentTerm 如果当前没有快照文件，则首先新建一个空文件 将此 RPC 中的快照数据 data 复制到指定的 offset 处，并逐渐等待更新的快照数据，直至 done 为 true 丢弃快照文件中所包含的全部日志 如果节点当前的日志中存在与 lastIncludedIndex 和 lastIncludedTerm 相同的日志，则保留此日志之后的日志；如果不存在，则丢弃全部日志 通过快照文件重置节点的状态机 一些讨论： 快照中能否包含未提交的日志？不能，因为快照是通过状态机创建的，而应用到状态机中的所有日志都必须是已经提交的日志。 节点在收到快照后，如何将其应用到状态机？可以设置一个单独的命令，在提交日志时标识当前提交的是日志还是快照，如果是日志，则应用到状态机；如果是快照，则重置状态机 Membership Changes 在实际的使用中，Raft 节点的成员配置可能会发生改变，比如增加或减少节点数等。尽管这个步骤可以使用离线更新来实现，但是在离线过程中，会形成一个无法提供服务的窗口。并且离线手动更新难以保证安全性，因此 Raft 协议提供了可以在线更新成员配置的内容。 为了确保安全性，直接在两个配置中进行转变是不行的，因为这有可能导致在同一个 term 下选举出了两个 Leader。因此我们必须将这个步骤拆分为两个阶段。比如第一步中先停止先前的配置文件并暂停服务，第二步载入更新的配置并恢复。 在 Raft 中，集群首先进入一个临时的配置状态，称之为 joint consensus；一旦 joint consensus 被提交到日志，整个系统便过渡到最终的阶段，并可以使用更新的配置。 参考资料 http://nil.csail.mit.edu/6.824/2018/notes/l-raft2.txt","link":"/p/23fbe6c4/"},{"title":"tinykv","text":"","link":"/p/ae54ec2/"},{"title":"Zeek 简介","text":"zeek 是一个被动的开源网络流量分析器，可深入检查网络连接上的所有流量以查找可疑活动的迹象。因其可扩展性强、可开箱即用等特点，被称为 “流量分析里的瑞士军刀”。 不同于 Snort 等基于流量签名检测的入侵检测系统（IDS），zeek 是基于网络连接来分析可疑行为的。具体地说，Zeek 会对每个网络中传输的数据包，从中提取出发送端的 IP 和端口以及接收端的 IP 和端口，从而通过四元组定义一个网络连接，并且将具有相同四元组的数据包收集在一起，再通过对应的 TCP、UDP 协议解析，对数据包进行排序重组，最后将其中携带的应用层数据交由应用层协议解析器，从而提取出数据包中所包含的所有内容，包括但不限于：应用层协议字段、传输的文件内容、协议记录等。 但是，了解Zeek的关键在于认识到，即使该系统具有开箱即用的强大功能，但从根本上来说，它还是一个可完全自定义和扩展的流量分析平台：Zeek为用户提供了特定于域的 Turing-完整的脚本语言用于表达任意分析任务。从概念上讲，您可以将Zeek视为 “特定于网络流量的 Python”：就像Python一样，该系统具有大量的预构建功能（“标准库”），但您不仅限于系统附带的功能，但可以通过编写自己的代码使Zeek以新颖的方式使用。实际上，Zeek的所有默认分析（包括所有日志记录）都是此类脚本的结果。没有硬编码到系统核心中的特定分析。 特征 Zeek通过其脚本语言支持广泛的分析。即使没有进一步的自定义，它也具有强大的功能集。 部署方式 在标准UNIX风格的系统（包括Linux，FreeBSD和MacOS）上的商用硬件上运行。 通过网络分接头或监视端口进行完全被动的流量分析。 用于捕获数据包的标准libpcap接口。 实时和离线分析。 集群支持大规模部署。 统一管理框架，可用于独立和群集设置。 在BSD许可下开源。 分析 全面记录活动，以进行离线分析和取证。 与应用程序层协议无关的端口分析。 支持许多应用程序层协议（包括DNS，FTP，HTTP，IRC，SMTP，SSH，SSL）。 分析通过应用层协议交换的文件内容，包括用于指纹识别的MD5 / SHA1计算。 全面的IPv6支持。 隧道检测和分析（包括Ayiya，Teredo，GTPv1）。Zeek将隧道解封装，然后继续分析其内容，就好像没有适当的隧道一样。 在协议分析过程中进行全面的健全性检查。 支持IDS样式的模式匹配。 脚本语言 图灵完备的语言，用于表达任意分析任务。 基于事件的编程模型。 特定于域的数据类型，例如IP地址（透明地处理IPv4和IPv6），端口号和计时器。 广泛支持随着时间的推移跟踪和管理网络状态。 界面 默认输出为结构良好的ASCII日志。 ElasticSearch和DataSeries的备用后端。正在准备其他数据库接口。 外部输入实时集成到分析中。正在准备实时数据库输入。 外部C库，用于与外部程序交换Zeek事件。带有Perl，Python和Ruby绑定。 能够从脚本语言内部触发任意外部进程。 历史 Architecture 下图说明了Zeek群集的主要组件。 有关Zeek流程的连接方式，它们如何运行以及如何相互通信的更多特定信息，请参阅 Broker Framework文档。 Tap Tap 是一种机制，用于拆分数据包流，以使副本可用于流量检查。示例包括交换机上的监视端口和光纤网络上的光分路器。 Frontend Frontend 是一种离散的硬件设备或主机技术，可将流量分成许多流或流。Zeek二进制文件不执行此工作。有多种方法可以完成此任务。 Manager Manager 是一个Zeek流程，它使用 Zeek 通信协议从群集中其余节点接收日志消息和通知（请注意，如果使用单独的 Logger 节点，那么 Logger 将接收所有日志，而不是 Manager）。 Logger Logger 是一个可选的Zeek进程，它使用Zeek通信协议从群集中其余节点接收日志消息。让 Logger 代替 Manager 接收日志的目的是为了减轻管理员的负担。如果不需要 Logger，则 Manager 将改为接收日志。 Proxy 代理是Zeek进程，可用于卸载数据存储或任何任意工作负载。一个群集可能包含多个代理节点。Zeek随附的默认脚本使用的代理最少，因此仅使用一个代理就足够了，但是自定义使用它们来分区数据或工作负载提供了更大的群集可扩展性，而不仅仅是在单个集中式Manager节点上执行类似任务。 充当代理的Zeek进程在CPU或内存上的使用并不十分困难，并且用户经常在与管理器相同的物理主机上运行代理进程。 Worker 工作进程是Zeek进程，用于嗅探网络流量并对重组后的流量进行协议分析。活动集群的大部分工作都在工作程序上进行，因此，工作程序通常代表集群中正在运行的大部分Zeek进程。由于所有协议解析和大多数分析都将在此处进行，因此建议您使用负担得起的最快内存和CPU核心速度。对工作器中的磁盘没有特殊要求，因为几乎所有日志记录都是在远程对管理器进行的，并且通常很少写入磁盘。","link":"/p/682f53b3/"},{"title":"Zeek 的安装与使用","text":"Zeek Zeek 官方文档 依赖安装 Zeek 需要下列的依赖才能进行运行： Libpcap (http://www.tcpdump.org) OpenSSL libraries (http://www.openssl.org) BIND8 library Libz Bash (for ZeekControl) Python 2.6 or greater (for ZeekControl) 如果想要从源码编译 zeek，下面这些附加的依赖也需要安装： CMake 3.0 or greater (http://www.cmake.org) Make C/C++ compiler with C++17 support (GCC 7+ or Clang 4+) SWIG (http://www.swig.org) Bison 2.5 or greater (https://www.gnu.org/software/bison/) Flex (lexical analyzer generator) (https://github.com/westes/flex) Libpcap headers (http://www.tcpdump.org) OpenSSL headers (http://www.openssl.org) zlib headers (https://zlib.net/) Python (https://www.python.org/) 可以通过以下的命令来安装这些依赖： 基于 RPM/RedHat 的 Linux 发行版: 1sudo yum install cmake make gcc gcc-c++ flex bison libpcap-devel openssl-devel python-devel swig zlib-devel 在 RHEL/CentOS 6/7, 可以通过 devtoolset 来安装最新的 gcc 版本。 12sudo yum install cmake3 devtoolset-7scl enable devtoolset-7 bash 基于 DEB/Debian 的 Linux 发行版: 1sudo apt-get install cmake make gcc g++ flex bison libpcap-dev libssl-dev python-dev swig zlib1g-dev 如果你的系统中安装的是 Python 2.7， 你还需要安装 python-ipaddress。 安装 Zeek 从源码安装 123456git clone --recursive https://github.com/zeek/zeekcd zeek./configure --prefix=/opt/zeek --with-pcap=/opt/PF_RINGmakesudo make installexport PATH=/opt/zeek/bin:$PATH 检查 zeek 是否正确使用了 PF_RING: 12ldd /opt/zeek/bin/zeek | grep pcap libpcap.so.1 =&gt; /opt/pf_ring/lib/libpcap.so.1 (0x00007fa371e33000) 从二进制文件安装 从这个下载页面可以下载各个版本的 zeek 程序. 使用 Docker 安装 请查看这个 Github 仓库 启动 zeek 直接启动 假设配置文件为 hello.zeek: 捕获网卡p1p2的流量: 1/opt/zeek/bin/zeek hello.zeek -C -i p1p2 从test.pcap输入流量: 1/opt/zeek/bin/zeek hello.zeek -C -r test.pcap 使用 zeekctl 修改以下文件: $PREFIX/etc/node.cfg, 修改单机或集群设置 $PREFIX/etc/networks.cfg, 修改本地网络的定义 $PREFIX/etc/zeekctl.cfg, 修改部分配置 主要的改动在 $PREFIX/etc/node.cfg: 单机启动 1234[zeek]type=standalonehost=localhostinterface=p1p2 集群配置(流量分配有问题, 暂时不用) 1234567891011121314151617181920[logger]type=loggerhost=localhost[manager]type=managerhost=localhost[proxy-1]type=proxyhost=localhost[worker-1]type=workerhost=localhostinterface=p1p2lb_method=pf_ringlb_procs=4pin_cpus=4,5,6,7env_vars=PCAP_PF_RING_CLUSTER_ID=99 之后启动 ZeekControl : 1/opt/zeek/bin/zeekctl 使用 deploy 部署 zeek: 1[ZeekControl] &gt; deploy","link":"/p/b8bdff8e/"},{"title":"Gas station problem","text":"问题说明 这是一道来自于 LeetCode No.134 的问题, 问题的定义如下： 在一条环路上有 NNN 个加油站，其中第 iii 个加油站有汽油 gas[i]gas[i]gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 iii 个加油站开往第 i+1i+1i+1 个加油站需要消耗汽油 cost[i]cost[i]cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 −1-1−1。 说明: 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例 1: 1234567891011121314输入: gas = [1, 2, 3, 4, 5]cost = [3, 4, 5, 1, 2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 示例 2: 12345678910111213输入: gas = [2,3,4]cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 编写测试程序 1234567891011121314151617181920212223# TEST ONLYimport unittestclass SolutionTest(unittest.TestCase): @classmethod def setUpClass(cls): cls._func = Solution().canCompleteCircuit def test_1(self): args = [[1, 2, 3, 4, 5], [3, 4, 5, 1, 2]] ans = 3 cur_ans = self._func(*args) self.assertEqual(cur_ans, ans) def test_2(self): args = [[2, 3, 4], [3, 3, 4]] ans = -1 cur_ans = self._func(*args) self.assertEqual(cur_ans, ans)if __name__ == &quot;__main__&quot;: unittest.main(verbosity=2) 解法 1 - 暴力求解 首先，先尝试暴力法。简单地说，既然问题最终的结果是出发点的索引，那么对于每一个加油站，都将其作为出发点进行尝试，如果能够实现返程，那么此加油站即为答案。如果所有加油站都不能实现返程，那么便返回 -1 作为结果。 123456789101112131415161718class Solution(object): def canCompleteCircuit(self, gas, cost): &quot;&quot;&quot; :type gas: List[int] :type cost: List[int] :rtype: int &quot;&quot;&quot; n = len(gas) for start in range(n): # 对于每一个加油站， 都将其作为起点 curr_tank = 0 # 初始时汽油量为 0 i = 0 while i &lt; n and curr_tank &gt;= 0: curr_station = (start + i) % n curr_tank += gas[curr_station] - cost[curr_station] i += 1 if i == n and curr_tank &gt;= 0: # 跑完 n 个站 且汽油量足够 return start # 得到索引 return -1 很明显，这种解法的时间复杂度为 O(N2)O(N^2)O(N2)，这样的算法效率自然不能够满足要求。 解法 2 - 贪心策略 现在的问题是，对于这个问题，能否有一种一次遍历的方式求解呢，也就是说算法的时间复杂度需要控制在 O(N)O(N)O(N) 。 答案当然是有的，下面我们来慢慢分析。 问题分析 能否跑完全程 首先，对于这个问题，至少可以明确的一点是，如果 gas 的元素之和小于 cost 的元素之和，那么肯定不存在这样的行驶路线。 也就是说如果总的汽油量都填补不了总的消耗量，那么无论如何也跑不完全程。在这种情况下算法一定会返回 -1。 推论 1： 若 sum(gas) &lt; sum(cost)，则结果为 -1 但是当 sum(gas) &gt;= sum(cost) 时，该怎么确定呢？ 为了再次简化问题，我们将 gas 和 cost 进行合并， 得到 res，其中： res[i] = gas[i] - cost[i] 也即：res 表示的是经过每个站所需要的净汽油量，正负皆可。则有： 推论 2： 若 sum(res) &lt; 0，则结果为 -1 能否作为起点 另外，由于出发时汽油量为 0，因此，如果在某个站，使 gas[i] &lt; cost[i]，也即 res[i] &lt; 0，则此点一定不是起点。 推论 3： 若 res[i] &lt; 0，则结果不为 i 同时，如果连续的加油站的净汽油量都大于 0，那么最终的答案只可能在这一串加油站的第一个位置（由于答案唯一），我们也有 若 res[i-1] &gt; 0, res[i] &gt; 0，由于答案唯一，则结果不为 i 如何选择起点 我们先来看一个 sum(res) == 0 的例子： 图中曲线表示的是 res 数组的前缀和，也可以认为是车内剩余的汽油量 参考链接","link":"/p/c954d77a/"},{"title":"位运算算法合集","text":"基本操作 左移 &lt;&lt; 左移运算符实现将数字的所有二进制位向左移动一位，最高位移出数据，最低位补 0。一般也称为逻辑左移。 如果 n 为32位二进制数据，则左移相当于：(n&lt;&lt;i)=(n∗2i)mod 232=(nmod 231)∗2i(n &lt;&lt; i) = (n * 2^i) \\mod 2^{32} = (n \\mod 2^{31}) * 2^i(n&lt;&lt;i)=(n∗2i)mod232=(nmod231)∗2i 右移 &gt;&gt; 右移运算符实现将数字的所有二进制位向右移动一位，最低位移出数据，最高位补 0 或 符号位。根据最高位的不同，可以分为两种，一种为逻辑右移，最高位全部补 0，一种为算术右移，最高位补符号位，也即正数补 0，负数补 1。 一般情况下，编程语言中对右移运算符的实现为：若操作数为无符号数，则使用逻辑右移；若为有符号数，则使用算术右移。 如果 n 为32位二进制数据，则右移相当于：(n&gt;&gt;i)=(n−(n%2i))/2i(n &gt;&gt; i) = (n - (n \\% 2^i)) / 2^i(n&gt;&gt;i)=(n−(n%2i))/2i 与 &amp; x y z = x &amp; y 0 0 0 0 1 0 1 0 0 1 1 1 如果固定 x = 0，则输出 z = 0。使用此性质可以实现对特定的位进行置 0。 如果固定 x = 1，则输出 z = y。使用此性质可以实现对特定的位进行取数。 如果 n 为32位 bit 数据，则通过 (n &gt;&gt; i) &amp; 1 可以得到第 i 位的数字。（下标从 0 开始） 或 | | x | y | z = x | y | | :—: | :—: | :---------: | | 0 | 0 | 0 | | 0 | 1 | 1 | | 1 | 0 | 1 | | 1 | 1 | 1 | 如果固定 x = 0，则输出 z = y。使用此性质可以实现对特定的位进行取数。 如果固定 x = 1，则输出 z = 1。使用此性质可以实现对特定的位进行置 1。 非 ~ x ~ x 0 1 1 0 非门可用于求操作数的补码，根据补码定义，数 n 的补码为：(~ n) + 1 异或 ^ x y z = x ^ y 0 0 0 0 1 1 1 0 1 1 1 0 如果固定 x = 0，则输出 z = y。使用此性质可以实现对特定的位进行取数。 如果固定 x = 1，则输出 z = ~ y。等同于非运算符。 x ^ x = 0 x ^ y = z 可以得到：x ^ z = y， y ^ z = x 同或 ~^ x y z = ~ (x ^ y) 0 0 1 0 1 0 1 0 0 1 1 1 用得较少，性质与异或相似。 基本操作 在这里，我们假设所有的数字都是 32 位无符号数，用 x, y, z, n 表示，在需要有符号数处会进行说明。 使用 i, j, k 来表示数据的特定位，其中 0 &lt;= i, j, k &lt; 32。 同时，我们使用 a, b, c 来表示单个 bit 数据，也就是 0 / 1。 生成 2 的 i 次幂 左移：1 &lt;&lt; i 取第 i 位数字 右移 + 与门：(n &gt;&gt; i) &amp; 1 与门 + 右移：(n &amp; (1 &lt;&lt; i)) &gt;&gt; i 右移 + 取余 + 或门：((n &gt;&gt; i) % 2) | 0 对第 i 位置 0 左移 + 非门 + 与门：n &amp; (~ (1 &lt;&lt; i)) 对第 i 位置 1 左移 + 或门：n | (1 &lt;&lt; i) 清除最后的 1 减法 + 与门：n &amp; (n - 1) #136 - 只出现一次的数字 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 对于这道题，最简单的办法就是使用一个哈希表，统计所有元素出现的次数，最后返回只出现一次的那个元素。但是这样的方法需要 O(n)O(n)O(n) 的空间，并不是一个很优秀的算法。 那么，如果使用位运算来做这个题，该怎么办呢？ 首先，我们想要保留的是只出现一次的数字，也就是说出现两次的数字都需要消除掉，而这样的要求可以通过异或来实现： 由于 x ^ x = 0，因此可以保证任何出现两次的数字都会相互抵消，只剩下 0 由于 x ^ 0 = x，因此可以保证只出现一次的数字可以保留在结果之中 有了这样的思路，程序的编写就很简单了。首先，我们初始化一个变量 ans = 0，接着遍历整个数组，将 ans 与每个数字都进行异或，最终遍历完成之后 ans 中的数字便是本题想要得到的元素。 123456class Solution: def singleNumber(self, nums: List[int]) -&gt; int: ans = 0 for x in nums: ans ^= x return ans 其他变体 #137 - 只出现一次的数字 II 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 与上面那道题比起来，本题只修改了一处，即是重复的数字每个出现三次。由于异或运算对于出现奇数次的数字都会保留下来，因此无法再像上面那道题一样对所有元素进行一遍异或求解。 但是，考虑到空间复杂度，我们仍然希望能够使用 O(1)O(1)O(1) 的空间，因此还是使用异或运算进行求解。 如果，对于一个元素，我们能够区分出它是否是第三次出现，从而在其第三次出现时，我们不将其加入到异或结果中，那么本题就和上面一道题是一致的。也就是说，我们的异或运算中，只包含出现一次的数字，和出现三次数字的前两次，因此最终的异或结果就是只出现一次的数字。 那么，现在的问题就是，如何在异或中区分出现第一次和第三次出现的数字。或者说，如何使第三次出现的元素不会加入到异或结果中。 假设我们的异或结果为 ans，其中数字 x 出现了 3 次。在与 x 完成两次异或后，此时 ans = 0，如果我们可以知道 x 是出现过两次的数字，那么在第三次时，可以通过 ans = ~x &amp; (ans ^ x) = ~x &amp; x = 0，使得第三个 x 对异或结果不产生任何影响。 那么怎么去判断 x 是出现过两次的数字呢？在这里我们使用另外一个变量 t，在每个 x 出现时，我们令： ans = ~t &amp; (ans ^ x) t = ~ans &amp; (t ^ x) 那么，我们可以来看一下运算的结果： 初始时：ans = 0, t = 0 第一次出现 x： ans = x, t = 0 ，ans 保留了出现一次的 x 第二次出现 x： ans = 0, t = x ，ans 中重复出现的数字抵消，t 中保存了重复出现的数字 第三次出现 x： ans = 0, t = 0 ，回到初始值。 因此，在这样的算法下，ans 中只会保存出现一次的数字，而当数字重复出现时，均会被抵消。 具体的算法如下，在算法中，为了更有意义地命名，将 ans 写为 seen_once，将 t 写为 seen_twice： 1234567891011class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; seen_once = seen_twice = 0 for x in nums: seen_once = ~seen_twice &amp; (seen_once ^ x) seen_twice = ~seen_once &amp; (seen_twice ^ x) return seen_once 扩展：出现 n 次时如何求解 让我们顺势思考下面的问题： 如果有一个数字只出现 1 次，其余的数字均出现 n 次，该如何求解？ 问题分析 我们可以对 n 做一个归纳：（显然 n&gt;1n &gt; 1n&gt;1 ） 当 n = 2 或 n = 3 时，上面的算法已经给出答案 当 n 为偶数时，均可使用 n = 2 地算法来解决，因为异或运算对于偶数次的运算结果是一致的 当 n 为奇数的时候呢？看起来没有一个简单的办法。 我们先来回顾一下 n = 3 时，列个表格看一下三次重复出现的数字产生了哪些变化： seen_once seen_twice 初始值 0 0 x x 0 x 0 x x 0 0 那么，如果 n = 5 呢，我们应该想要的也是一个类似于上面的表格： a b c d 初始值 0 0 0 0 x x 0 0 0 x 0 x 0 0 x 0 0 x 0 x 0 0 0 x x 0 0 0 0 从而，我们可以写出下面的迭代算法： a = ~b &amp; ~c &amp; ~d &amp; (a ^ x) b = ~a &amp; ~c &amp; ~d &amp; (b ^ x) c = ~a &amp; ~b &amp; ~d &amp; (c ^ x) d = ~a &amp; ~b &amp; ~c &amp; (d ^ x) 为什么可以这样写呢？首先，从算法上来看，每个变量都是其他所有变量的 &amp; 并且再 &amp; 上它与 x 的异或。 那么，什么时候当前变量会进行改变呢？很明显，就是当其他的变量都是 0，自身也是 0 的时候，这个变量会变成 x；而当其他的变量都是 0，自身是 x 的时候，这个变量会变成 0。 首先来看第一轮，由于初始值全是 0，因此 a 在第一步变为 x，而由于 a = x，因此第一轮中其他变量均不会发生变化，最后的结果为 a = x, b = 0, c = 0, d = 0 接着是第二轮，当 a 再次进行迭代时，由于其他变量全为 0，而 a = x，因此 a 会变成 0；此时轮到 b，显然此时所有变量都为 0，因此在 b 运算结束后，b 会变成 x；同时剩余的 c 和 d 均不满足变化的条件，因此仍然为 0。最后的结果为 a = 0, b = x, c = 0, d = 0 第三轮的变化也是类似的，b 从 x 变为 0，然后给了 c 一个机会从 0 变为 x，最后的结果为 a = 0, b = 0, c = x, d = 0 第四轮同样，最后的结果为 a = 0, b = 0, c = 0, d = x 到了第五轮，最终 d 由 x 变为了 0，运算结束，最后的结果为 a = 0, b = 0, c = 0, d = 0，再次回到初始值，可以进行下一次运算。 从算法的过程中可以看出，这样的运算本质上是数字 x 在相邻变量中的传递过程，最终将其清零回归初始状态。而这个算法事实上不仅仅适用于 n 为奇数，n 为偶数也同样适用，只不过偶数的情况下有更适合的算法。 算法归纳 最后，我们可以归纳出这样的算法： 对于问题：如果有一个数字只出现 1 次，其余的数字均出现 n 次，该如何求解？ 首先，初始化 n - 1 个变量，均为 0，依次命名为 x1,...xn−1x_1, ... x_{n-1}x1​,...xn−1​ 对于每个在数组中出现的数字 t： x1= x2&amp;...&amp;xn−1&amp;(x1⊕t)x_1 = ~x_2 \\&amp; ... \\&amp; x_{n-1} \\&amp; (x_1 \\oplus t)x1​= x2​&amp;...&amp;xn−1​&amp;(x1​⊕t) ......... xn−1= x1&amp;...&amp;xn−2&amp;(xn−1⊕t)x_{n-1} = ~x_1 \\&amp; ... \\&amp; x_{n-2} \\&amp; (x_{n-1} \\oplus t)xn−1​= x1​&amp;...&amp;xn−2​&amp;(xn−1​⊕t) 返回 x1x_1x1​ 再次扩展 最后，如果将问题再次扩展：如果有一个数字只出现 m 次，其余的数字均出现 n 次，该如何求解？ 其中 m &lt; n 其实观察上面的表格就可以看出，如果是要求出现 m 次的数字，只需要最后返回 xmx_mxm​ 就可以实现。 程序语言编写算法 1234567891011class Solution(object): # 有一个数字只出现 m 次，其余的数字均出现 n 次 def singleNumber(self, nums，m, n): seen = [0] * (n - 1) for x in nums: # 对于每个数字 for i in range(len(seen)): # 对于每个变量 seen[i] ^= t # 先计算异或的值 for j in range(len(seen)): if i != j: # 对于所有其他变量 seen[i] &amp;= ~seen[j] # 进行与运算 return seen[m - 1] # 返回第 m 个变量 #260 - 只出现一次的数字 III 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。 这个问题稍微简单一点，首先，如果我们对所有元素进行依次异或遍历，假设只出现一次的元素为 x 和 y，那么遍历的结果为 bitmask = x ^ y，由于 x != y，那么 bitmask != 0。 如果我们按位查看 bitmask，那么一定有一位不为 0，并且在这一位上，x 和 y 一定一个为 1，一个为 0。 因此我们可以找到这一位，在这里有个技巧是 diff = bitmask &amp; (-bitmask)，可以直接得到 bitmask 中最后一个 1 的掩码。 接着再次进行遍历，在这次遍历中，如果元素与 diff 相与为 1，说明该元素在对应位置上为 1，便将其进入到异或中，否则就略过。这样可以保证这一次的异或结果中只包含 x 和 y 其中的一个，最后返回 [x, bitmask^x] 即可。 1234567891011121314151617181920class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; bitmask = 0 for num in nums: bitmask ^= num # rightmost 1-bit diff between x and y diff = bitmask &amp; (-bitmask) x = 0 for num in nums: # bitmask which will contain only x if num &amp; diff: x ^= num return [x, bitmask^x] #191 - 位1的个数 本题可以利用之前提到的，n &amp;= n - 1 将数字最后一位 1 清除。 反复进行此操作，直至 n == 0，记录操作的次数，即为所求答案。 1234567891011class Solution(object): def hammingWeight(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; ans = 0 while n: n &amp;= n - 1 ans += 1 return ans #231 - 2的幂 如果一个数字是 2 的幂，那么在二进制表示形式上，它一定只有一位为 1，因此如果使用 n &amp; (n - 1)，那么结果一定为 0。为了消除数字 0 的影响，加上 n &gt; 0 条件即可。 1234567class Solution(object): def isPowerOfTwo(self, n): &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; return n &gt; 0 and (n &amp; (n - 1)) == 0 #342 - 4的幂 如果一个数字是 4 的幂，那么首先它一定是 2 的幂，因此先加上判定条件：num &gt; 0 and (num &amp; (num - 1)) == 0。通过这个条件的数字中有且只有一位 1。 同时，数字是 4 的幂可以表示为：num=4n=22nnum = 4^n = 2^{2n}num=4n=22n，因此，从二进制表示上来看，1 所在的位一定是奇数位，比如：1 = 0000 0001， 4 = 0000 0100， 16 = 0001 0000，…… 因此我们可以再使用一个掩码：0x55555555 = b'0101 0101 ... 0101，来判断数字 1 是否出现在奇数位。如果 num &amp; 0x55555555 &gt; 0，说明出现在奇数位，则数字为 4 的幂；否则不是。 同样，我们也可以使用另外一个掩码：0xAAAAAAAA = b'1010 1010 ... 1010，判定条件相应变为：num &amp; 0xAAAAAAAA == 0。 12345678910class Solution(object): def isPowerOfFour(self, num): &quot;&quot;&quot; :type num: int :rtype: bool &quot;&quot;&quot; return num &gt; 0 and \\ (num &amp; (num - 1)) == 0 and \\ (num &amp; 0x55555555) &gt; 0 数字范围按位与 颠倒二进制位","link":"/p/cdd10903/"},{"title":"字符串匹配算法","text":"字符串匹配算法是一个经常使用的算法。具体地说，字符串匹配的任务是：给定一个待搜索的字符串（往往较长，通常称为 haystack），以及一个想要搜索的字符串（往往较短，通常称为 needle），查找 needle 在 haystack 中出现的第一个位置（从 0 开始）。如果不存在，则返回 -1。 特别的，当 needle 为空字符串时，应该返回什么值呢？在 C 语言的 strstr() 以及 Java 的 indexOf() 定义中，此情况下的返回值为0。 问题定义 实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从 0 开始)。如果不存在，则返回 -1。 记：NNN 为 haystack 字符串的长度，LLL 为 needle 字符串的长度。 Brute force - 暴力法 子串逐一比较 Brute force 方法，也成为暴力法，思路是直接对 haystack 中每个长度等于 needle 的子字符串进行比较，若其内容与 needle 相同，则搜索成功，返回首个字符的索引。如果遍历到字符串结尾仍然未找到结果，则搜索失败，返回 -1。 12345678def strStr(self, haystack: str, needle: str) -&gt; int: L, n = len(needle), len(haystack) # 当 L == 0 时，会使 haystack[start: start + L] 也为空 # 因此不必对 L == 0 额外进行判断 for start in range(n - L + 1): if haystack[start: start + L] == needle: return start return -1 复杂度分析 时间复杂度：O((N−L)L)O((N - L)L)O((N−L)L)。内循环中比较字符串的复杂度为 LLL，总共需要比较 (N−L)(N - L)(N−L) 次。 空间复杂度：O(1)O(1)O(1)。 双指针 在初始的 Brute force 方法中，由于会将 haystack 所有长度为 L 的子串都与 needle 字符串比较，实际上是不需要这么做的。 首先，只有子串的第一个字符跟 needle 字符串第一个字符相同的时候才需要比较。 其次，可以一个字符一个字符比较，一旦不匹配了就立刻终止。 因此，可以对其进行改进，使用两个指针，算法流程为： 移动 pn 指针，直到 pn 所指向位置的字符与 needle 字符串第一个字符相等。 通过 pn，pL，curr_len 计算匹配长度。 如果完全匹配（即 curr_len == L），返回匹配子串的起始坐标（即 pn - L）。 如果不完全匹配，回溯。使 pn = pn - curr_len + 1， pL = 0， curr_len = 0。 1234567891011121314151617181920def strStr(self, haystack: str, needle: str) -&gt; int: L, n = len(needle), len(haystack) if L == 0: return 0 pn = 0 # 子串头指针 while pn &lt; n - L + 1: # 待匹配指针 pL = 0 # 计算最长的匹配长度 while pL &lt; L and haystack[pn + pL] == needle[pL]: pL += 1 # 如果匹配了 needle 的全部字符，则返回当前子串头指针位置 if pL == L: return pn # 否则，头指针后移，继续查找 pn += 1 return -1 复杂度分析 时间复杂度：最坏时间复杂度为 O((N−L)L)O((N - L)L)O((N−L)L)，最优时间复杂度为 O(N)O(N)O(N)。 空间复杂度：O(1)O(1)O(1)。 Knuth–Morris–Pratt http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html KMP 算法，是在字符串匹配算法中比较经典的一个算法，它以三个发明者 Knuth-Morris-Pratt 的名称命名，起头的那个 K 就是著名科学家 Donald Knuth。 首先，让我们回顾一下上面的暴力法，暴力法的效率问题主要体现在，当出现位置不匹配时，它会同时回退 haystack 和 needle 的位置，具体地说，haystack 的搜索位置从 pn + pL 回退到 pn，needle 的搜索位置从 pL 回退到 0，这种回退机制导致了算法往往会进行很多不必要的操作。 比如，如果 haystack 为 aaacaaadaaa，而 needle 为 aaaa，算法在第一次会对 aaac 和 aaaa 进行比较，然后第二次对 aaca 和 aaaa 进行比较…这就导致了一个问题，由于 needle 中根本就没有 c 这个字符，所有这几次比较注定是失败的。这也就是暴力法效率差的主要原因。 那么，在 KMP 中，如何利用已知的比较信息，从而不要把“haystack 中的搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。 想要做到这一点，需要针对于 needle，产生一个部分匹配表，例如，当 needle 为 ABCDABD 时，部分匹配表如下： 搜索词 A B C D A B D 部分匹配值 0 0 0 0 1 2 0 对于这张表的介绍，以及如何使用，这篇文章已经写的非常清楚，本文中不再赘述 计算部分匹配表 首先，要了解两个概念：“前缀” 和 “后缀”。 “前缀” 指除了最后一个字符以外，一个字符串的全部头部组合；“后缀” 指除了第一个字符以外，一个字符串的全部尾部组合。 “部分匹配值” 就是 “前缀” 和 “后缀” 的最长的共有元素的长度。以 “ABCDABD” 为例： 子串 前缀集 后缀集 共有元素 部分匹配值 A ϕ\\phiϕ ϕ\\phiϕ ϕ\\phiϕ 0 AB A B ϕ\\phiϕ 0 ABC A, AB BC, C ϕ\\phiϕ 0 ABCD A, AB, ABC BCD, CD, D ϕ\\phiϕ 0 ABCDA A, AB, ABC, ABCD BCDA, CDA, DA, A A 1 ABCDAB A, AB, ABC, ABCD, ABCDA BCDAB, CDAB, DAB, AB, B AB 2 ABCDABD A, AB, ABC, ABCD, ABCDA, ABCDAB BCDABD, CDABD, DABD, ABD, BD, D ϕ\\phiϕ 0 “部分匹配” 的实质是，有时候，字符串头部和尾部会有重复。比如，“ABCDAB” 之中有两个 “AB”，那么它的 “部分匹配值” 就是 2（“AB” 的长度）。搜索词移动的时候，第一个 “AB” 向后移动 4 位（字符串长度 - 部分匹配值），就可以来到第二个 “AB” 的位置。 Sunday https://leetcode-cn.com/problems/implement-strstr/solution/python3-sundayjie-fa-9996-by-tes/ Horspool https://www.cnblogs.com/cobbliu/archive/2012/05/29/2524244.html Boyer-Moore https://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html Rabin Karp https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode/","link":"/p/7458611/"},{"title":"在 LeetCode 上做脑筋急转弯","text":"这篇文章主要包含以下内容： #292 - Nim 游戏 #319 - 灯泡开关 #521 - 最长特殊序列 Ⅰ #777 - 在LR字符串中交换相邻字符 #1033 - 移动石子直到连续 #1227 - 飞机座位分配概率 #1503 - 所有蚂蚁掉下来前的最后一刻 #292 - Nim 游戏 你和你的朋友，两个人一起玩 Nim 游戏： 桌子上有一堆石头。 你们轮流进行自己的回合，你作为先手。 每一回合，轮到的人拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。 假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。 由于每个人最多只能拿 3 块石头，那么如果桌上还剩 4 块的话，一个人是一定不能一次拿完的。那么只要在一个人拿 x 块石头之后，另一个人继续拿 4 - x 块，就能保证一开始拿的那个人一定不可能赢。 因此，因为你作为先手，如果桌上的石头一开始就是 4 的倍数，那么你就是一开始拿的人，也就是说你会输；如果不是 4 的倍数，你就可以拿 n % 4 块，那么你的对手就不可能赢，因此你会获得胜利。 所以胜利与否只取决于桌上原始的石头数。解法如下： 123class Solution: def canWinNim(self, n: int) -&gt; bool: return n % 4 != 0 #319 - 灯泡开关 初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。 第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。 首先，初始时每个灯泡都是灭的。 那么，什么时候灯泡会转变一次状态呢？由题意，对于第 i 轮，如果 k % i == 0，也就是 k 是 i 的倍数，此时灯泡 k 会转变一次状态。另一方面，在第 k / i 轮，灯泡 k 同样会转变一次状态。因此，如果 i != k / i，那么灯泡会转变两次，最终还是灭的；而只有 i == k / i，也就是 k == i * i，即 k 是个平方数，此时灯泡 k 只会转变一次，因此最后的状态是亮的。 举个例子，比如 12，由于 12 = 1 * 12 = 2 * 6 = 3 * 4，因此会分别在第 1, 2, 3, 4, 6, 12 轮转换六次状态，最终还是灭的；而对于 16，由于 16 = 1 * 16 = 2 * 8 = 4 * 4，由于在 4 处只变了一次，最终在第 1, 2, 4, 8, 16 轮转换五次，最终是亮的。 因此，亮着的灯泡的个数就等同于 [1, n] 内的平方数的个数。解法如下： 123class Solution: def bulbSwitch(self, n: int) -&gt; int: return floor(sqrt(n)) #521 - 最长特殊序列 Ⅰ 给你两个字符串，请你从这两个字符串中找出最长的特殊序列。 「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。 子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。 输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。 123456class Solution: def findLUSlength(self, a: str, b: str) -&gt; int: if a == b: return -1 else: return max(len(a), len(b)) #777 - 在LR字符串中交换相邻字符 在一个由 ‘L’ , ‘R’ 和 ‘X’ 三个字符组成的字符串（例如&quot;RXXLRXRXL&quot;）中进行移动操作。一次移动操作指用一个&quot;LX&quot;替换一个&quot;XL&quot;，或者用一个&quot;XR&quot;替换一个&quot;RX&quot;。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。 #1033 - 移动石子直到连续 三枚石子放置在数轴上，位置分别为 a，b，c。 每一回合，我们假设这三枚石子当前分别位于位置 x, y, z 且 x &lt; y &lt; z。从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x &lt; k &lt; z 且 k != y。 当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。 要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves] 123456789class Solution: def numMovesStones(self, a: int, b: int, c: int) -&gt; List[int]: a, b, c = sorted([a, b, c]) if a + 1 == b and b + 1 == c: return [0, 0] elif b - a &lt;= 2 or c - b &lt;= 2: return [1, c - a - 2] else: return [2, c - a - 2] #1227 - 飞机座位分配概率 有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。 剩下的乘客将会： 如果他们自己的座位还空着，就坐到自己的座位上， 当他们自己的座位被占用时，随机选择其他座位 第 n 位乘客坐在自己的座位上的概率是多少？ 123class Solution: def nthPersonGetsNthSeat(self, n: int) -&gt; float: return 1 if n == 1 else 0.5 #1503 - 所有蚂蚁掉下来前的最后一刻 有一块木板，长度为 n 个 单位 。一些蚂蚁在木板上移动，每只蚂蚁都以 每秒一个单位 的速度移动。其中，一部分蚂蚁向 左 移动，其他蚂蚁向 右 移动。 当两只向 不同 方向移动的蚂蚁在某个点相遇时，它们会同时改变移动方向并继续移动。假设更改方向不会花费任何额外时间。 而当蚂蚁在某一时刻 t 到达木板的一端时，它立即从木板上掉下来。 给你一个整数 n 和两个整数数组 left 以及 right 。两个数组分别标识向左或者向右移动的蚂蚁在 t = 0 时的位置。请你返回最后一只蚂蚁从木板上掉下来的时刻。 题目写的花里胡哨的，但是想想看，两只蚂蚁碰面的时候，究竟发生了什么？ 改变移动方向并继续移动，这是不是等同于他们穿过了彼此，然后继续移动？ 所以就不用考虑碰不碰面的问题，就当每只蚂蚁都是独立的，而现在要求的就是行走最远的蚂蚁走了多久。 因此答案就是： 向左走的蚂蚁要走到 0 的位置，走的最远的路程就是他们所在的位置的最大值，也就是 max(left) 向右走的蚂蚁要走到 n 的位置，走的最远的路程就是 n 减去他们所在的位置的最小值，也就是 n - max(right) 最终的结果就是上面两个的最大值。 解答如下： 12345678class Solution: def getLastMoment(self, n: int, left: List[int], right: List[int]) -&gt; int: ans = 0 if left: ans = max(ans, max(left)) if right: ans = max(ans, n - min(right)) return ans","link":"/p/7c7bac08/"},{"title":"Typora 快捷键","text":"原文地址：https://support.typora.io/Shortcut-Keys/ Shortcut Keys January 5, 2019 by typora.io TOC Summary Frequently Used Shortcut Keys Autocomplete File Edit Paragraph Format View Change Shortcut Keys macOS Windows / Linux Q: Shortcut keys does not work on Ubuntu Summary You can use shortcut keys to quickly insert or modify styles or do other operations supported by Typora. You can find shortcut keys in the right side of each menu items from menu bar. Frequently Used Shortcut Keys Autocomplete On macOS, you can press Esc key to open inline preview for inline math, auto-complete for emoji, etc. File Function Hotkey (Windows/Linux) Hotkey (macOS) New Ctrl + N Command + N New Window Ctrl + Shift + N Command +Shift + N New Tab (Not Supported) Command + T Open Ctrl + O Command + O Open Quickly Ctrl + P Command + Shift + O Reopen Closed File Ctrl + Shift + T Command + Shift + T Save Ctrl + S Command + S Save As / Duplicate Ctrl + Shift + S Command + Shift + S Preference Ctrl + , Command + , Close Ctrl + W Command + W Edit Function Hotkey (Windows/Linux) Hotkey (macOS) New Paragraph Enter Enter New Line Shift + Enter Shift + Enter Cut Ctrl + X Command + X Copy Ctrl + C Command + C Paste Ctrl + V Command + V Copy As Markdown Ctrl + Shift + C Command + Shift + C Paste As Plain Text Ctrl + Shift + V Command + Shift + V Select All Ctrl + A Command + A Select Line/Sentence Select Row (in table) Ctrl + L Command + L Delete Row (in table) Ctrl + Shift + Backspace Command + Shift + Backspace Select Style Scope Select Cell (in table) Ctrl + E Command + E Select Word Ctrl + D Command + D Delete Word Ctrl + Shift + D Command + Shift + D Jump to Top Ctrl + Home Command + ↑ Jump to Selection Ctrl + J Command + J Jump to Buttom Ctrl + End Command + ↓ Find Ctrl + F Command + F Find Next F3 / Enter Command + G / Enter Find Previous Shift + F3 / Shift + Enter Command + Shift + G / Shift + Enter Replace Ctrl + H Command + H Paragraph Function Hotkey (Windows/Linux) Hotkey (macOS) Heading 1 to 6 Ctrl + 1/2/3/4/5/6 Command + 1/2/3/4/5/6 Paragraph Ctrl + 0 Command + 0 Increase Heading Level Ctrl + = Command + = Decrease Heading Level Ctrl + - Command + - Table Ctrl + T Command + Option + T Code Fences Ctrl + Shift + K Command + Option + C Math Block Ctrl + Shift + M Command + Option + B Quote Ctrl + Shift + Q Command + Option + Q Ordered List Ctrl + Shift + [ Command + Option + O Unordered List Ctrl + Shift + ] Command + Option + U Indent Ctrl + [ / Tab Command + [ / Tab Outdent Ctrl + ] / Shift + Tab Command + ] / Shift + Tab Format Function Hotkey (Windows/Linux) Hotkey (macOS) Strong Ctrl + B Command + B Emphasis Ctrl + I Command + I Underline Ctrl + U Command + U Code Ctrl + Shift + ` Command + Shift + ` Strike Alt + Shift + 5 Control + Shift + ` Hyperlink Ctrl + K Command + K Image Ctrl + Shift + I Command + Control + I Clear Format Ctrl + \\ Command + \\ View Function Hotkey (Windows/Linux) Hotkey (macOS) Toggle Sidebar Ctrl + Shift + L Command + Shift + L Outline Ctrl + Shift + 1 Command + Control + 1 Articles Ctrl + Shift + 2 Command + Control + 2 File Tree Ctrl + Shift + 3 Command + Control + 3 Source Code Mode Ctrl + / Command + / Focus Mode F8 F8 Typewriter Mode F9 F9 Toggler Fullscreen F11 Command + Option + F Actual Size Ctrl + Shift + 0 (Not Supported) Zoom In Ctrl + Shift + = (Not Supported) Zoom Out Ctrl + Shift + - (Not Supported) Switch Between Opened Documents Ctrl + Tab Command + ` Toggle DevTools Ctrl + Shift + I - Change Shortcut Keys Users can set or reassign shortcut keys for commands in Typora’s menu bar. This article will shows how to do this. macOS We use macOS’s system feature to customize Typora’s key binding on macOS. Open System Preference → Keyboard, select tab Shortcuts. Select App Shortcuts in its left panel. Click the “+” button, a dialog sheet would pop up. Select “Typora.app” from field Application, then enter the exact name of the menu command you want to add, and then type the shortcut key combination you want to assign. For example, assume you want to add/change the shortcut key to pin Typora’s window, you can fill the dialog box as follows: Then Command+Shift+P will be the shortcut key for menu command “always On Top” Windows / Linux Tip: This requires a version of Typora ≥ v0.9.16. Open Menu → Preference in Typora, then click “Open Advanced Settings”. Open and edit conf.user.json from opened “File Explore”. If there’s no such file, create one. Set or add JSON object which represents a key binding, for example: Restart Typora, and the new key binding will be applied. You can set or change shortcut keys for menu items in the menu bar in native window style. Q: Shortcut keys does not work on Ubuntu For solutions to this problem please see: https://help.ubuntu.com/community/KeyboardShortcuts and https://askubuntu.com/questions/208310/ctrl-a-doesnt-work-in-browsers.","link":"/p/e402bc62/"},{"title":"Vim 基本配置","text":"配置方式 Vim 有许多种配置方式, 主要有: 单次配置项 (命令模式下输入) 用户配置文件 ~/.vimrc 全局配置文件 /etc/vim/vimrc 或者 /etc/vimrc 单次配置项主要是通过在命令模式下，先输入一个冒号，再输入配置. 举例来说，set number这个配置可以写在.vimrc里面，也可以在命令模式输入。 1:set number 配置项一般都有&quot;打开&quot;和&quot;关闭&quot;两个设置。“关闭&quot;就是在&quot;打开&quot;前面加上前缀&quot;no”。 12345&quot; 打开set number&quot; 关闭set nonumber 上面代码中，双引号开始的行表示注释。 查询某个配置项是打开还是关闭，可以在命令模式下，输入该配置，并在后面加上问号。 1:set number? 上面的命令会返回number或者nonumber。 如果想查看帮助，可以使用help命令。 1:help number 常用配置总览 1234567891011121314151617181920212223242526272829303132&quot; 行号相关set number &quot; 行号 = nuset relativenumber &quot; 显示相对行号set cursorline &quot; 高亮当前行 = culset cursorcolumn &quot; 高亮当前列 = culset textwidth=80 &quot; 行宽, 用于自动换行set wrap &quot; 自动换行set linebreak &quot; 换行不分割单词syntax on &quot; 语法高亮set showmatch &quot; 高亮对应括号set paste &quot; 设置粘贴模式set nocompatible &quot; 是否兼容 viset showmode &quot; 底部显示当前模式set showcmd &quot; 底部显示当前命令set ruler &quot; 显示光标位置set mouse=a &quot; 支持鼠标操作set encoding=utf-8 &quot; 编码set t_Co=256 &quot; 启用256色set noerrorbells &quot; 出错时不发出响声filetype indent on &quot; 开启文件类型检查&quot; 缩进相关set autoindent &quot; 自动缩进set tabstop=4 &quot; tab 表示的空格数set expandtab &quot; tab 自动转空格set softtabstop=2 &quot; tab 转换的空格数&quot; 搜索高亮set hlsearch &quot; 高亮搜索结果set incsearch &quot; 自动跳转到第一个搜索结果set ignorecase &quot; 搜索忽略大小写 基本配置 （1） 1set nocompatible 不与 Vi 兼容（采用 Vim 自己的操作命令）。 （2） 1syntax on 打开语法高亮。自动识别代码，使用多种颜色显示。 （3） 1set showmode 在底部显示，当前处于命令模式还是插入模式。 （4） 1set showcmd 命令模式下，在底部显示，当前键入的指令。比如，键入的指令是2y3d，那么底部就会显示2y3，当键入d的时候，操作完成，显示消失。 （5） 1set mouse=a 支持使用鼠标。 （6） 1set encoding=utf-8 使用 utf-8 编码。 （7） 1set t_Co=256 启用256色。 （8） 1filetype indent on 开启文件类型检查，并且载入与该类型对应的缩进规则。比如，如果编辑的是.py文件，Vim 就是会找 Python 的缩进规则~/.vim/indent/python.vim。 缩进 （9） 1set autoindent 按下回车键后，下一行的缩进会自动跟上一行的缩进保持一致。 （10） 1set tabstop=2 按下 Tab 键时，Vim 显示的空格数。 （11） 1set shiftwidth=4 在文本上按下&gt;&gt;（增加一级缩进）、&lt;&lt;（取消一级缩进）或者==（取消全部缩进）时，每一级的字符数。 （12） 1set expandtab 由于 Tab 键在不同的编辑器缩进不一致，该设置自动将 Tab 转为空格。 （13） 1set softtabstop=2 Tab 转为多少个空格。 外观 （14） 1set number 显示行号 （15） 1set relativenumber 显示光标所在的当前行的行号，其他行都为相对于该行的相对行号。 （16） 1set cursorline 光标所在的当前行高亮。 （17） 1set textwidth=80 设置行宽，即一行显示多少个字符。 （18） 1set wrap 自动折行，即太长的行分成几行显示。 1set nowrap 关闭自动折行 （19） 1set linebreak 只有遇到指定的符号（比如空格、连词号和其他标点符号），才发生折行。也就是说，不会在单词内部折行。 （20） 1set wrapmargin=2 指定折行处与编辑窗口的右边缘之间空出的字符数。 （21） 1set scrolloff=5 垂直滚动时，光标距离顶部/底部的位置（单位：行）。 （22） 1set sidescrolloff=15 水平滚动时，光标距离行首或行尾的位置（单位：字符）。该配置在不折行时比较有用。 （23） 1set laststatus=2 是否显示状态栏。0 表示不显示，1 表示只在多窗口时显示，2 表示显示。 （24） 1set ruler 在状态栏显示光标的当前位置（位于哪一行哪一列）。 搜索 （25） 1set showmatch 光标遇到圆括号、方括号、大括号时，自动高亮对应的另一个圆括号、方括号和大括号。 （26） 1set hlsearch 搜索时，高亮显示匹配结果。 （27） 1set incsearch 输入搜索模式时，每输入一个字符，就自动跳到第一个匹配的结果。 （28） 1set ignorecase 搜索时忽略大小写。 （29） 1set smartcase 如果同时打开了ignorecase，那么对于只有一个大写字母的搜索词，将大小写敏感；其他情况都是大小写不敏感。比如，搜索Test时，将不匹配test；搜索test时，将匹配Test。 编辑 （30） 1set spell spelllang=en_us 打开英语单词的拼写检查。 （31） 1set nobackup 不创建备份文件。默认情况下，文件保存时，会额外创建一个备份文件，它的文件名是在原文件名的末尾，再添加一个波浪号（〜）。 （32） 1set noswapfile 不创建交换文件。交换文件主要用于系统崩溃时恢复文件，文件名的开头是.、结尾是.swp。 （33） 1set undofile 保留撤销历史。 Vim 会在编辑时保存操作历史，用来供用户撤消更改。默认情况下，操作记录只在本次编辑时有效，一旦编辑结束、文件关闭，操作历史就消失了。 打开这个设置，可以在文件关闭后，操作记录保留在一个文件里面，继续存在。这意味着，重新打开一个文件，可以撤销上一次编辑时的操作。撤消文件是跟原文件保存在一起的隐藏文件，文件名以.un~开头。 （34） 123set backupdir=~/.vim/.backup// set directory=~/.vim/.swp//set undodir=~/.vim/.undo// 设置备份文件、交换文件、操作历史文件的保存位置。 结尾的//表示生成的文件名带有绝对路径，路径中用%替换目录分隔符，这样可以防止文件重名。 （35） 1set autochdir 自动切换工作目录。这主要用在一个 Vim 会话之中打开多个文件的情况，默认的工作目录是打开的第一个文件的目录。该配置可以将工作目录自动切换到，正在编辑的文件的目录。 （36） 1set noerrorbells 出错时，不要发出响声。 （37） 1set visualbell 出错时，发出视觉提示，通常是屏幕闪烁。 （38） 1set history=1000 Vim 需要记住多少次历史操作。 （39） 1set autoread 打开文件监视。如果在编辑过程中文件发生外部改变（比如被别的编辑器编辑了），就会发出提示。 （40） 12set listchars=tab:»■,trail:■set list 如果行尾有多余的空格（包括 Tab 键），该配置将让这些空格显示成可见的小方块。 （41） 12set wildmenuset wildmode=longest:list,full 命令模式下，底部操作指令按下 Tab 键自动补全。第一次按下 Tab，会显示所有匹配的操作指令的清单；第二次按下 Tab，会依次选择各个指令。 参考链接 Turn your vim editor into a productivity powerhouse A Good Vimrc Vim documentation: options","link":"/p/e2b505f0/"},{"title":"The Art Of Command Line","text":"The Art Of Command Line 这是Github项目the-art-of-command-line的备份, 其中添加了一些相关的内容. 命令行的艺术 熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。 这篇文章是许多作者和译者共同的成果。 这里的部分内容 首次 出现 于 Quora， 但已经迁移到了 Github，并由众多高手做出了许多改进。 如果你在本文中发现了错误或者存在可以改善的地方，请贡献你的一份力量。 前言 涵盖范围： 这篇文章不仅能帮助刚接触命令行的新手，而且对具有经验的人也大有裨益。本文致力于做到覆盖面广（涉及所有重要的内容），具体（给出具体的最常用的例子），以及简洁（避免冗余的内容，或是可以在其他地方轻松查到的细枝末节）。在特定应用场景下，本文的内容属于基本功或者能帮助您节约大量的时间。 本文主要为 Linux 所写，但在仅限 OS X 系统章节和仅限 Windows 系统章节中也包含有对应操作系统的内容。除去这两个章节外，其它的内容大部分均可在其他类 Unix 系统或 OS X，甚至 Cygwin 中得到应用。 本文主要关注于交互式 Bash，但也有很多技巧可以应用于其他 shell 和 Bash 脚本当中。 除去“标准的”Unix 命令，本文还包括了一些依赖于特定软件包的命令（前提是它们具有足够的价值）。 注意事项： 为了能在一页内展示尽量多的东西，一些具体的信息可以在引用的页面中找到。我们相信机智的你知道如何使用 Google 或者其他搜索引擎来查阅到更多的详细信息。文中部分命令需要您使用 apt-get，yum，dnf，pacman，pip 或 brew（以及其它合适的包管理器）来安装依赖的程序。 遇到问题的话，请尝试使用 Explainshell 去获取相关命令、参数、管道等内容的解释。 基础 学习 Bash 的基础知识。具体地，在命令行中输入 man bash 并至少全文浏览一遍; 它理解起来很简单并且不冗长。其他的 shell 可能很好用，但 Bash 的功能已经足够强大并且到几乎总是可用的（ 如果你只学习 zsh，fish 或其他的 shell 的话，在你自己的设备上会显得很方便，但过度依赖这些功能会给您带来不便，例如当你需要在服务器上工作时）。 熟悉至少一个基于文本的编辑器。通常而言 Vim （vi） 会是你最好的选择，毕竟在终端中编辑文本时 Vim 是最好用的工具（甚至大部分情况下 Vim 要比 Emacs、大型 IDE 或是炫酷的编辑器更好用）。 学会如何使用 man 命令去阅读文档。学会使用 apropos 去查找文档。知道有些命令并不对应可执行文件，而是在 Bash 内置好的，此时可以使用 help 和 help -d 命令获取帮助信息。你可以用 type 命令 来判断这个命令到底是可执行文件、shell 内置命令还是别名。 学会使用 &gt; 和 &lt; 来重定向输出和输入，学会使用 | 来重定向管道。明白 &gt; 会覆盖了输出文件而 &gt;&gt; 是在文件末添加。了解标准输出 stdout 和标准错误 stderr。 学会使用通配符 * （或许再算上 ? 和 […]） 和引用以及引用中 ' 和 &quot; 的区别（后文中有一些具体的例子）。 熟悉 Bash 中的任务管理工具：&amp;，ctrl-z，ctrl-c，jobs，fg，bg，kill 等。 学会使用 ssh 进行远程命令行登录，最好知道如何使用 ssh-agent，ssh-add 等命令来实现基础的无密码认证登录。 学会基本的文件管理工具：ls 和 ls -l （了解 ls -l 中每一列代表的意义），less，head，tail 和 tail -f（甚至 less +F），ln 和 ln -s （了解硬链接与软链接的区别），chown，chmod，du （硬盘使用情况概述：du -hs *）。 关于文件系统的管理，学习 df，mount，fdisk，mkfs，lsblk。知道 inode 是什么（与 ls -i 和 df -i 等命令相关）。 学习基本的网络管理工具：ip 或 ifconfig，dig。 学习并使用一种版本控制管理系统，例如 git。 熟悉正则表达式，学会使用 grep／egrep，它们的参数中 -i，-o，-v，-A，-B 和 -C 这些是很常用并值得认真学习的。 学会使用 apt-get，yum，dnf 或 pacman （具体使用哪个取决于你使用的 Linux 发行版）来查找和安装软件包。并确保你的环境中有 pip 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 pip 来安装会很方便）。 日常使用 在 Bash 中，可以通过按 Tab 键实现自动补全参数，使用 ctrl-r 搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下 ctrl-r 会向后查找匹配项，按下 Enter 键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。 在 Bash 中，可以按下 ctrl-w 删除你键入的最后一个单词，ctrl-u 可以删除行内光标所在位置之前的内容，alt-b 和 alt-f可以以单词为单位移动光标，ctrl-a 可以将光标移至行首，ctrl-e 可以将光标移至行尾，ctrl-k 可以删除光标至行尾的所有内容，ctrl-l 可以清屏。键入 man readline 可以查看 Bash 中的默认快捷键。内容有很多，例如 alt-. 循环地移向前一个参数，而 alt-* 可以展开通配符。 你喜欢的话，可以执行 set -o vi 来使用 vi 风格的快捷键，而执行 set -o emacs 可以把它改回来。 为了便于编辑长命令，在设置你的默认编辑器后（例如 export EDITOR=vim），ctrl-x ctrl-e 会打开一个编辑器来编辑当前输入的命令。在 vi 风格下快捷键则是 escape-v。 键入 history 查看命令行历史记录，再用 !n（n 是命令编号）就可以再次执行。其中有许多缩写，最有用的大概就是 !$， 它用于指代上次键入的参数，而 !! 可以指代上次键入的命令了（参考 man 页面中的“HISTORY EXPANSION”）。不过这些功能，你也可以通过快捷键 ctrl-r 和 alt-. 来实现。 cd 命令可以切换工作路径，输入 cd ~ 可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀 ~（例如 ~/.bashrc）。在 sh 脚本里则用环境变量 $HOME 指代 home 目录的路径。 回到前一个工作路径：cd -。 如果你输入命令的时候中途改了主意，按下 alt-# 在行首添加 # 把它当做注释再按下回车执行（或者依次按下 ctrl-a， #， enter）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。 使用 xargs （ 或 parallel）。他们非常给力。注意到你可以控制每行参数个数（-L）和最大并行数（-P）。如果你不确定它们是否会按你想的那样工作，先使用 xargs echo 查看一下。此外，使用 -I{} 会很方便。例如： 12find . -name '*.py' | xargs grep some_functioncat hosts | xargs -I{} ssh root@{} hostname pstree -p 以一种优雅的方式展示进程树。 使用 pgrep 和 pkill 根据名字查找进程或发送信号（-f 参数通常有用）。 了解你可以发往进程的信号的种类。比如，使用 kill -STOP [pid] 停止一个进程。使用 man 7 signal 查看详细列表。 使用 nohup 或 disown 使一个后台进程持续运行。 使用 netstat -lntp 或 ss -plat 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 -u 则检查 UDP 端口）或者 lsof -iTCP -sTCP:LISTEN -P -n (这也可以在 OS X 上运行)。 lsof 来查看开启的套接字和文件。 使用 uptime 或 w 来查看系统已经运行多长时间。 使用 alias 来创建常用命令的快捷形式。例如：alias ll='ls -latr' 创建了一个新的命令别名 ll。 可以把别名、shell 选项和常用函数保存在 ~/.bashrc，具体看下这篇文章。这样做的话你就可以在所有 shell 会话中使用你的设定。 把环境变量的设定以及登陆时要执行的命令保存在 ~/.bash_profile。而对于从图形界面启动的 shell 和 cron 启动的 shell，则需要单独配置文件。 要想在几台电脑中同步你的配置文件（例如 .bashrc 和 .bash_profile），可以借助 Git。 当变量和文件名中包含空格的时候要格外小心。Bash 变量要用引号括起来，比如 &quot;$FOO&quot;。尽量使用 -0 或 -print0选项以便用 NULL 来分隔文件名，例如 locate -0 pattern | xargs -0 ls -al 或 find / -print0 -type d | xargs -0 ls -al。如果 for 循环中循环访问的文件名含有空字符（空格、tab 等字符），只需用 IFS=$'\\n' 把内部字段分隔符设为换行符。 在 Bash 脚本中，使用 set -x 去调试输出（或者使用它的变体 set -v，它会记录原始输入，包括多余的参数和注释）。尽可能地使用严格模式：使用 set -e 令脚本在发生错误时退出而不是继续运行；使用 set -u 来检查是否使用了未赋值的变量；试试 set -o pipefail，它可以监测管道中的错误。当牵扯到很多脚本时，使用 trap 来检测 ERR 和 EXIT。一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息： 12set -euo pipefailtrap &quot;echo 'error: Script failed: see failed command above'&quot; ERR 在 Bash 脚本中，子 shell（使用括号 (...)）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下： 123# do something in current dir(cd /some/other/dir &amp;&amp; other-command)# continue in original dir 在 Bash 中，变量有许多的扩展方式。${name:?error message} 用于检查变量是否存在。此外，当 Bash 脚本只需要一个参数时，可以使用这样的代码 input_file=${1:?usage: $0 input_file}。在变量为空时使用默认值：${name:-default}。如果你要在之前的例子中再加一个（可选的）参数，可以使用类似这样的代码 output_file=${2:-logfile}，如果省略了 $2，它的值就为空，于是 output_file 就会被设为 logfile。数学表达式：i=$(( (i + 1) % 5 ))。序列：{1..10}。截断字符串：${var%suffix} 和 ${var#prefix}。例如，假设 var=foo.pdf，那么 echo ${var%.pdf}.txt 将输出 foo.txt。 使用括号扩展（{…}）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 mv foo.{txt,pdf} some-dir（同时移动两个文件），cp somefile{,.bak}（会被扩展成 cp somefile somefile.bak）或者 mkdir -p test-{a,b,c}/subtest-{1,2,3}（会被扩展成所有可能的组合，并创建一个目录树）。 通过使用 &lt;(some command) 可以将输出视为文件。例如，对比本地文件 /etc/hosts 和一个远程文件： 1diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) 编写脚本时，你可能会想要把代码都放在大括号里。缺少右括号的话，代码就会因为语法错误而无法执行。如果你的脚本是要放在网上分享供他人使用的，这样的写法就体现出它的好处了，因为这样可以防止下载不完全代码被执行。 123{ # 在这里写代码} 了解 Bash 中的“here documents”，例如 cat &lt;&lt;EOF ...。 在 Bash 中，同时重定向标准输出和标准错误：some-command &gt;logfile 2&gt;&amp;1 或者 some-command &amp;&gt;logfile。通常，为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上，在命令后添加 &lt;/dev/null 是一个好习惯。 使用 man ascii 查看具有十六进制和十进制值的ASCII表。man unicode，man utf-8，以及 man latin1 有助于你去了解通用的编码信息。 使用 screen 或 tmux 来使用多份屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。而 byobu 可以为它们提供更多的信息和易用的管理工具。另一个轻量级的 session 持久化解决方案是 dtach。 ssh 中，了解如何使用 -L 或 -D（偶尔需要用 -R）开启隧道是非常有用的，比如当你需要从一台远程服务器上访问 web 页面。 对 ssh 设置做一些小优化可能是很有用的，例如这个 ~/.ssh/config 文件包含了防止特定网络环境下连接断开、压缩数据、多通道等选项： 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes 一些其他的关于 ssh 的选项是与安全相关的，应当小心翼翼的使用。例如你应当只能在可信任的网络中启用 StrictHostKeyChecking=no，ForwardAgent=yes。 考虑使用 mosh 作为 ssh 的替代品，它使用 UDP 协议。它可以避免连接被中断并且对带宽需求更小，但它需要在服务端做相应的配置。 获取八进制形式的文件访问权限（修改系统设置时通常需要，但 ls 的功能不那么好用并且通常会搞砸），可以使用类似如下的代码： 1stat -c '%A %a %n' /etc/timezone 使用 percol 或者 fzf 可以交互式地从另一个命令输出中选取值。 使用 fpp（PathPicker）可以与基于另一个命令(例如 git）输出的文件交互。 将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用： python -m SimpleHTTPServer 7777 （使用端口 7777 和 Python 2）或python -m http.server 7777 （使用端口 7777 和 Python 3）。 以其他用户的身份执行命令，使用 sudo。默认以 root 用户的身份执行；使用 -u 来指定其他用户。使用 -i 来以该用户登录（需要输入_你自己的_密码）。 将 shell 切换为其他用户，使用 su username 或者 sudo - username。加入 - 会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为 root。切换到哪个用户，就需要输入_哪个用户的_密码。 了解命令行的 128K 限制。使用通配符匹配大量文件名时，常会遇到“Argument list too long”的错误信息。（这种情况下换用 find 或 xargs 通常可以解决。） 当你需要一个基本的计算器时，可以使用 python 解释器（当然你要用 python 的时候也是这样）。例如： 12&gt;&gt;&gt; 2+35 文件及数据处理 在当前目录下通过文件名查找一个文件，使用类似于这样的命令：find . -iname '*something*'。在所有路径下通过文件名查找文件，使用 locate something （但注意到 updatedb 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）。 使用 ag 在源代码或数据文件里检索（grep -r 同样可以做到，但相比之下 ag 更加先进）。 将 HTML 转为文本：lynx -dump -stdin。 Markdown，HTML，以及所有文档格式之间的转换，试试 pandoc。 当你要处理棘手的 XML 时候，xmlstarlet 算是上古时代流传下来的神器。 使用 jq 处理 JSON。 使用 shyaml 处理 YAML。 要处理 Excel 或 CSV 文件的话，csvkit 提供了 in2csv，csvcut，csvjoin，csvgrep 等方便易用的工具。 当你要处理 Amazon S3 相关的工作的时候，s3cmd 是一个很方便的工具而 s4cmd 的效率更高。Amazon 官方提供的 aws 以及 saws 是其他 AWS 相关工作的基础，值得学习。 了解如何使用 sort 和 uniq，包括 uniq 的 -u 参数和 -d 参数，具体内容在后文单行脚本节中。另外可以了解一下 comm。 了解如何使用 cut，paste 和 join 来更改文件。很多人都会使用 cut，但遗忘了 join。 了解如何运用 wc 去计算新行数（-l），字符数（-m），单词数（-w）以及字节数（-c）。 了解如何使用 tee 将标准输入复制到文件甚至标准输出，例如 ls -al | tee file.txt。 要进行一些复杂的计算，比如分组、逆序和一些其他的统计分析，可以考虑使用 datamash。 注意到语言设置（中文或英文等）对许多命令行工具有一些微妙的影响，比如排序的顺序和性能。大多数 Linux 的安装过程会将 LANG 或其他有关的变量设置为符合本地的设置。要意识到当你改变语言设置时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降许多倍。某些情况下（例如集合运算）你可以放心的使用 export LC_ALL=C 来忽略掉国际化并按照字节来判断顺序。 你可以单独指定某一条命令的环境，只需在调用时把环境变量设定放在命令的前面，例如 TZ=Pacific/Fiji date 可以获取斐济的时间。 了解如何使用 awk 和 sed 来进行简单的数据处理。 参阅 One-liners 获取示例。 替换一个或多个文件中出现的字符串： 1perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt 使用 repren 来批量重命名文件，或是在多个文件中搜索替换内容。（有些时候 rename 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。） 123456# 将文件、目录和内容全部重命名 foo -&gt; bar:repren --full --preserve-case --from foo --to bar .# 还原所有备份文件 whatever.bak -&gt; whatever:repren --renames --from '(.*)\\.bak' --to '\\1' *.bak# 用 rename 实现上述功能（若可用）:rename 's/\\.bak$//' *.bak 根据 man 页面的描述，rsync 是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用 rsync 代替 scp 可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的最快方法之一： 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir 若要在复制文件时获取当前进度，可使用 pv，pycp，progress，rsync --progress。若所执行的复制为block块拷贝，可以使用 dd status=progress。 使用 shuf 可以以行为单位来打乱文件的内容或从一个文件中随机选取多行。 了解 sort 的参数。显示数字时，使用 -n 或者 -h 来显示更易读的数（例如 du -h 的输出）。明白排序时关键字的工作原理（-t 和 -k）。例如，注意到你需要 -k1，1 来仅按第一个域来排序，而 -k1 意味着按整行排序。稳定排序（sort -s）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 sort -k1，1 | sort -s -k2，2。 如果你想在 Bash 命令行中写 tab 制表符，按下 ctrl-v [Tab] 或键入 $'\\t' （后者可能更好，因为你可以复制粘贴它）。 标准的源代码对比及合并工具是 diff 和 patch。使用 diffstat 查看变更总览数据。注意到 diff -r 对整个文件夹有效。使用 diff -r tree1 tree2 | diffstat 查看变更的统计数据。vimdiff 用于比对并编辑文件。 对于二进制文件，使用 hd，hexdump 或者 xxd 使其以十六进制显示，使用 bvi，hexedit 或者 biew 来进行二进制编辑。 同样对于二进制文件，strings（包括 grep 等工具）可以帮助在二进制文件中查找特定比特。 制作二进制差分文件（Delta 压缩），使用 xdelta3。 使用 iconv 更改文本编码。需要更高级的功能，可以使用 uconv，它支持一些高级的 Unicode 功能。例如，这条命令移除了所有重音符号： 1uconv -f utf-8 -t utf-8 -x '::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ' &lt; input.txt &gt; output.txt 拆分文件可以使用 split（按大小拆分）和 csplit（按模式拆分）。 操作日期和时间表达式，可以用 dateutils 中的 dateadd、datediff、strptime 等工具。 使用 zless、zmore、zcat 和 zgrep 对压缩过的文件进行操作。 文件属性可以通过 chattr 进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：sudo chattr +i /critical/directory/or/file 使用 getfacl 和 setfacl 以保存和恢复文件权限。例如： 12getfacl -R /some/path &gt; permissions.txtsetfacl --restore=permissions.txt 为了高效地创建空文件，请使用 truncate（创建稀疏文件），fallocate（用于 ext4，xfs，btrf 和 ocfs2 文件系统），xfs_mkfile（适用于几乎所有的文件系统，包含在 xfsprogs 包中），mkfile（用于类 Unix 操作系统，比如 Solaris 和 Mac OS）。 系统调试 curl 和 curl -I 可以被轻松地应用于 web 调试中，它们的好兄弟 wget 也是如此，或者也可以试试更潮的 httpie。 获取 CPU 和硬盘的使用状态，通常使用使用 top（htop 更佳），iostat 和 iotop。而 iostat -mxz 15 可以让你获悉 CPU 和每个硬盘分区的基本信息和性能表现。 使用 netstat 和 ss 查看网络连接的细节。 dstat 在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用 glances，它会在一个终端窗口中向你提供一些系统级的数据。 若要了解内存状态，运行并理解 free 和 vmstat 的输出。值得留意的是“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，而与空闲内存无关。 Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 kill -3 &lt;pid&gt; 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准错误或是日志文件。JDK 中的 jps，jstat，jstack，jmap 很有用。SJK tools 更高级。 使用 mtr 去跟踪路由，用于确定网络问题。 用 ncdu 来查看磁盘使用情况，它比寻常的命令，如 du -sh *，更节省时间。 查找正在使用带宽的套接字连接或进程，使用 iftop 或 nethogs。 ab 工具（Apache 中自带）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 siege。 wireshark，tshark 和 ngrep 可用于复杂的网络调试。 了解 strace 和 ltrace。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（-c）和附加到一个运行的进程参数 （-p）。 了解使用 ldd 来检查共享库。但是永远不要在不信任的文件上运行。 了解如何运用 gdb 连接到一个运行着的进程并获取它的堆栈轨迹。 学会使用 /proc。它在调试正在出现的问题的时候有时会效果惊人。比如：/proc/cpuinfo，/proc/meminfo，/proc/cmdline，/proc/xxx/cwd，/proc/xxx/exe，/proc/xxx/fd/，/proc/xxx/smaps（这里的 xxx 表示进程的 id 或 pid）。 当调试一些之前出现的问题的时候，sar 非常有用。它展示了 cpu、内存以及网络等的历史数据。 关于更深层次的系统分析以及性能分析，看看 stap（SystemTap），perf，以及sysdig。 查看你当前使用的系统，使用 uname，uname -a（Unix／kernel 信息）或者 lsb_release -a（Linux 发行版信息）。 无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试 dmesg。 如果你删除了一个文件，但通过 du 发现没有释放预期的磁盘空间，请检查文件是否被进程占用： lsof | grep deleted | grep &quot;filename-of-my-big-file&quot; 单行脚本 一些命令组合的例子： 当你需要对文本文件做集合交、并、差运算时，sort 和 uniq 会是你的好帮手。具体例子请参照代码后面的，此处假设 a 与 b 是两内容不同的文件。这种方式效率很高，并且在小文件和上 G 的文件上都能运用（注意尽管在 /tmp 在一个小的根分区上时你可能需要 -T 参数，但是实际上 sort 并不被内存大小约束），参阅前文中关于 LC_ALL 和 sort 的 -u 参数的部分。 123sort a b | uniq &gt; c # c 是 a 并 bsort a b | uniq -d &gt; c # c 是 a 交 bsort a b b | uniq -u &gt; c # c 是 a - b 使用 grep . *（每行都会附上文件名）或者 head -100 *（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 /sys、/proc、/etc）时特别好用。 计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）： 1awk '{ x += $3 } END { print x }' myfile 如果你想在文件树上查看大小/日期，这可能看起来像递归版的 ls -l 但比 ls -lR 更易于理解： 1find . -type f -ls 假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 acct_id 参数在 URI 中。如果你想计算出每个 acct_id 值有多少次请求，使用如下代码： 1egrep -o 'acct_id=[0-9]+' access.log | cut -d= -f2 | sort | uniq -c | sort -rn 要持续监测文件改动，可以使用 watch，例如检查某个文件夹中文件的改变，可以用 watch -d -n 2 'ls -rtlh | tail'；或者在排查 WiFi 设置故障时要监测网络设置的更改，可以用 watch -d -n 2 ifconfig。 运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）： 12345678function taocl() { curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-zh.md| pandoc -f markdown -t html | iconv -f 'utf-8' -t 'unicode' | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v &quot;(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]&quot; | xmlstarlet unesc | fmt -80} 冷门但有用 expr：计算表达式或正则匹配 m4：简单的宏处理器 yes：多次打印字符串 cal：漂亮的日历 env：执行一个命令（脚本文件中很有用） printenv：打印环境变量（调试时或在写脚本文件时很有用） look：查找以特定字符串开头的单词或行 cut，paste 和 join：数据修改 fmt：格式化文本段落 pr：将文本格式化成页／列形式 fold：包裹文本中的几行 column：将文本格式化成多个对齐、定宽的列或表格 expand 和 unexpand：制表符与空格之间转换 nl：添加行号 seq：打印数字 bc：计算器 factor：分解因数 gpg：加密并签名文件 toe：terminfo 入口列表 nc：网络调试及数据传输 socat：套接字代理，与 netcat 类似 slurm：网络流量可视化 dd：文件或设备间传输数据 file：确定文件类型 tree：以树的形式显示路径和文件，类似于递归的 ls stat：文件信息 time：执行命令，并计算执行时间 timeout：在指定时长范围内执行命令，并在规定时间结束后停止进程 lockfile：使文件只能通过 rm -f 移除 logrotate： 切换、压缩以及发送日志文件 watch：重复运行同一个命令，展示结果并／或高亮有更改的部分 when-changed：当检测到文件更改时执行指定命令。参阅 inotifywait 和 entr。 tac：反向输出文件 shuf：文件中随机选取几行 comm：一行一行的比较排序过的文件 strings：从二进制文件中抽取文本 tr：转换字母 iconv 或 uconv：文本编码转换 split 和 csplit：分割文件 sponge：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 grep -v something some-file | sponge some-file units：将一种计量单位转换为另一种等效的计量单位（参阅 /usr/share/units/definitions.units） apg：随机生成密码 xz：高比例的文件压缩 ldd：动态库信息 nm：提取 obj 文件中的符号 ab 或 wrk：web 服务器性能分析 strace：调试系统调用 mtr：更好的网络调试跟踪工具 cssh：可视化的并发 shell rsync：通过 ssh 或本地文件系统同步文件和文件夹 wireshark 和 tshark：抓包和网络调试工具 ngrep：网络层的 grep host 和 dig：DNS 查找 lsof：列出当前系统打开文件的工具以及查看端口信息 dstat：系统状态查看 glances：高层次的多子系统总览 iostat：硬盘使用状态 mpstat： CPU 使用状态 vmstat： 内存使用状态 htop：top 的加强版 last：登入记录 w：查看处于登录状态的用户 id：用户/组 ID 信息 sar：系统历史数据 iftop 或 nethogs：套接字及进程的网络利用情况 ss：套接字数据 dmesg：引导及系统错误信息 sysctl： 在内核运行时动态地查看和修改内核的运行参数 hdparm：SATA/ATA 磁盘更改及性能分析 lsblk：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息 lshw，lscpu，lspci，lsusb 和 dmidecode：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等 lsmod 和 modinfo：列出内核模块，并显示其细节 fortune，ddate 和 sl：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用” 仅限 OS X 系统 以下是仅限于 OS X 系统的技巧。 用 brew （Homebrew）或者 port （MacPorts）进行包管理。这些可以用来在 OS X 系统上安装以上的大多数命令。 用 pbcopy 复制任何命令的输出到桌面应用，用 pbpaste 粘贴输入。 若要在 OS X 终端中将 Option 键视为 alt 键（例如在上面介绍的 alt-b、alt-f 等命令中用到），打开 偏好设置 -&gt; 描述文件 -&gt; 键盘 并勾选“使用 Option 键作为 Meta 键”。 用 open 或者 open -a /Applications/Whatever.app 使用桌面应用打开文件。 Spotlight：用 mdfind 搜索文件，用 mdls 列出元数据（例如照片的 EXIF 信息）。 注意 OS X 系统是基于 BSD UNIX 的，许多命令（例如 ps，ls，tail，awk，sed）都和 Linux 中有微妙的不同（ Linux 很大程度上受到了 System V-style Unix 和 GNU 工具影响）。你可以通过标题为 “BSD General Commands Manual” 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 gawk 和 gsed 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 perl ）或者经过仔细的测试。 用 sw_vers 获取 OS X 的版本信息。 仅限 Windows 系统 以下是仅限于 Windows 系统的技巧。 在 Winodws 下获取 Unix 工具 可以安装 Cygwin 允许你在 Microsoft Windows 中体验 Unix shell 的威力。这样的话，本文中介绍的大多数内容都将适用。 在 Windows 10 上，你可以使用 Bash on Ubuntu on Windows，它提供了一个熟悉的 Bash 环境，包含了不少 Unix 命令行工具。好处是它允许 Linux 上编写的程序在 Windows 上运行，而另一方面，Windows 上编写的程序却无法在 Bash 命令行中运行。 如果你在 Windows 上主要想用 GNU 开发者工具（例如 GCC），可以考虑 MinGW 以及它的 MSYS 包，这个包提供了例如 bash，gawk，make 和 grep 的工具。MSYS 并不包含所有可以与 Cygwin 媲美的特性。当制作 Unix 工具的原生 Windows 端口时 MinGW 将特别地有用。 另一个在 Windows 下实现接近 Unix 环境外观效果的选项是 Cash。注意在此环境下只有很少的 Unix 命令和命令行可用。 实用 Windows 命令行工具 可以使用 wmic 在命令行环境下给大部分 Windows 系统管理任务编写脚本以及执行这些任务。 Windows 实用的原生命令行网络工具包括 ping，ipconfig，tracert，和 netstat。 可以使用 Rundll32 命令来实现许多有用的 Windows 任务 。 Cygwin 技巧 通过 Cygwin 的包管理器来安装额外的 Unix 程序。 使用 mintty 作为你的命令行窗口。 要访问 Windows 剪贴板，可以通过 /dev/clipboard。 运行 cygstart 以通过默认程序打开一个文件。 要访问 Windows 注册表，可以使用 regtool。 注意 Windows 驱动器路径 C:\\ 在 Cygwin 中用 /cygdrive/c 代表，而 Cygwin 的 / 代表 Windows 中的 C:\\cygwin。要转换 Cygwin 和 Windows 风格的路径可以用 cygpath。这在需要调用 Windows 程序的脚本里很有用。 学会使用 wmic，你就可以从命令行执行大多数 Windows 系统管理任务，并编成脚本。 要在 Windows 下获得 Unix 的界面和体验，另一个办法是使用 Cash。需要注意的是，这个环境支持的 Unix 命令和命令行参数非常少。 要在 Windows 上获取 GNU 开发者工具（比如 GCC）的另一个办法是使用 MinGW 以及它的 MSYS 软件包，该软件包提供了 bash、gawk、make、grep 等工具。然而 MSYS 提供的功能没有 Cygwin 完善。MinGW 在创建 Unix 工具的 Windows 原生移植方面非常有用。 更多资源 awesome-shell：一份精心组织的命令行工具及资源的列表。 awesome-osx-command-line：一份针对 OS X 命令行的更深入的指南。 Strict mode：为了编写更好的脚本文件。 shellcheck：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。 Filenames and Pathnames in Shell：有关如何在 shell 脚本里正确处理文件名的细枝末节。 Data Science at the Command Line：用于数据科学的一些命令和工具，摘自同名书籍。","link":"/p/be0ddb94/"},{"title":"C++ 中的智能指针","text":"在 C++ 中，内存安全和内存泄露是最容易出现的问题，而对于前者，内存安全问题，很大程度上是由于指针的使用不当，比如直接访问未初始化的指针、通过指针访问以及被释放掉的对象等。为了解决这类问题，在 C++11 中，新增了一些现代化的指针工具，旨在替换原始的指针，实现更加智能化的内存数据管理，这些指针也叫智能指针（smart pointer）。 C++11 中新增的智能指针对象如下： 指针类别 备注 unique_ptr 拥有独有对象所有权语义的智能指针 shared_ptr 拥有共享对象所有权语义的智能指针 weak_ptr 到 std::shared_ptr 所管理对象的弱引用 https://juejin.cn/post/6844903993055920141 特点 这三个指针都定义在 memory 头文件下，使用时需要 #include &lt;memory&gt;，并处于 std 中 智能指针会自动进行析构操作，当独占指针结束作用域，或共享指针引用计数为0时，会自动释放指针的对象 unique_ptr","link":"/p/2633d759/"},{"title":"Makefile 入门","text":"在 Linux（ Unix ）环境下使用 GNU 的 make 工具能够比较容易的构建一个属于你自己的工程，整个工程的编译只需要一个命令就可以完成编译、连接以至于最后的执行。不过这需要我们投入一些时间去完成一个或者多个称之为 Makefile 文件的编写。 所要完成的 Makefile 文件描述了整个工程的编译、连接等规则。其中包括： 工程中的哪些源文件需要编译以及如何编译 需要创建哪些库文件以及如何创建这些库文件 如何最后产生我们想要的可执行文件。 … 尽管看起来可能是很复杂的事情，但是为工程编写 Makefile 的好处是能够使用一行命令来完成“自动化编译”，一旦提供一个（通常对于一个工程来说会是多个）正确的 Makefile。编译整个工程你所要做的事就是在 shell 提示符下输入 make 命令。整个工程完全自动编译，极大提高了效率。 make 是一个命令工具，它解释 Makefile 中的指令。在 Makefile 文件中描述了整个工程所有文件的编译顺序、编译规则。Makefile 有自己的书写格式、关键字、函数。像 C 语言有自己的格式、关键字和函数一样。而且在 Makefile 中可以使用系统shell所提供的任何命令来完成想要的工作。Makefile 在绝大多数的 IDE 开发环境中都在使用，已经成为一种工程的编译方法。 Makefile 基本规则 一个 Makefile 的基本语法结构如下: Makefile1234target ... : prerequisites ... command ... ... 其中: target 可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。 prerequisites: 生成该 target 所依赖的文件 command: 该target要执行的命令（任意的shell命令） prerequisites 和 command 都是可选的, 但是二者至少存在一个. 没有 command 的规则也叫伪目标 简单地说，上面这个语句规定了一个 target 目标的生成方式. 首先需要满足 prerequisites, 也就是说需要先完成 prerequisites 的内容, 然后执行 command 指令实现 target 的生成. 另一方面, 这个语句也表明了一种依赖关系, 也就是说: 1prerequisites 中如果有一个以上的文件比 target 文件要新的话，command 所定义的命令就会被执行。 而整个的 Makefile 就是这样的一条条规则语句组成的文件. 下面是一个简单的例子. Makefile12345678910111213141516# 使用 `#` 进行注释# 使用 `\\` 进行行末换行# 将 b.txt 和 c.txt 复制到 a.txt 中a.txt: b.txt c.txt cat b.txt c.txt &gt; a.txtb.txt: echo &quot;this is the text B&quot; &gt; b.txtc.txt: echo &quot;this is the text C&quot; &gt; c.txt# 伪目标, 用于删除之前生成的 a.txtclean: rm *.txt 之后, 在命令行执行: 1make # 等同于 make a.txt 如果 make 命令运行时没有指定目标，默认会执行 Makefile 文件的第一个目标. 也就是 a.txt, 之后由于 a.txt 需要 b.txt 和 c.txt, make 命令会继续查找相应的命令生成这两个文件, 最后将其一共复制到 a.txt 中. 再执行: 1make clean 便会执行清理操作, 删除所有的 txt 文件 target 一个目标（target）就构成一条规则。目标通常是文件名，指明 Make 命令所要构建的对象，也可以是多个文件名，之间用空格分隔。除了文件名，目标还可以是某个操作的名字，这称为&quot;伪目标&quot;（phony target）。 比如上面示例中的 clean. 对于伪目标, 存在一种情况是, 如果当前目录下刚好存在一个名为 clean 的文件, 那么会导致 clean 这个规则不会被执行. 因为Make发现clean文件已经存在, 就认为没有必要重新构建了, 就不会执行指定的rm命令. 为了避免这种情况，可以明确声明 clean 是&quot;伪目标&quot;，写法如下。 Makefile123.PHONY: cleanclean: rm *.txt 类似于 .PHONY 这样的内置目标名可以查看make 手册。 如果 Make 命令运行时没有指定目标，默认会执行 Makefile 文件的第一个目标。 prerequisites 前置条件通常也是一组文件名，之间用空格分隔。它指定了&quot;目标&quot;是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的时间戳比较新），&quot;目标&quot;就需要重新构建。 上面代码中，构建 a.txt 的前置条件是 b.txt 和 c.txt 。如果当前目录中，b.txt 和 c.txt 已经存在，那么make a.txt可以正常运行，否则必须再写一条规则，来生成 b.txt 和 c.txt 。 如果一个目标后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件不存在，每次调用make b.txt，它都会生成。 12make a.txtmake a.txt 上面命令连续执行两次make a.txt。第一次执行会先新建 b.txt 和 c.txt，然后再新建 a.txt。第二次执行，Make发现 b.txt 和 c.txt 没有变动（时间戳晚于 a.txt），就不会执行任何操作，a.txt 也不会重新生成。 如果需要生成多个文件，往往采用下面的写法。 Makefile1source: file1 file2 file3 上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。 1make source 执行make source命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。 123make file1make file2make file3 commands 命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建&quot;目标&quot;的具体指令，它的运行结果通常就是生成目标文件。需要注意的是，每行命令在一个单独的shell中执行。这些 Shell 之间没有继承关系。比如: Makefile123var-lost: export foo=bar echo &quot;foo=[$$foo]&quot; 上面代码执行后（make var-lost），取不到foo的值。因为两行命令在两个不同的进程执行。解决办法有: 将两行命令写在一行，中间用分号分隔 在换行符前加反斜杠转义 加上.ONESHELL:命令 Makefile1234567891011var-kept: export foo=bar; echo &quot;foo=[$$foo]&quot;var-kept: export foo=bar; \\ echo &quot;foo=[$$foo]&quot;.ONESHELL:var-kept: export foo=bar; echo &quot;foo=[$$foo]&quot; 每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量.RECIPEPREFIX声明。比如使用大于号（&gt;）替代tab键: Makefile123.RECIPEPREFIX = &gt;all:&gt; echo Hello, world Makefile 语法 回声（echoing） 正常情况下，make会打印出每条将要执行的命令，然后再执行，这就叫做回声（echoing）。在命令的前面加上@，就可以关闭回声。 123test: # 这是测试 1 @# 这是测试 2 执行上面的规则，会得到下面的结果, 只打印了没有关闭回声的指令。 12$ make test# 这是测试 1 由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 通配符（wildcard） 通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号（*）、问号（?）和 [...] 。比如， *.o 表示所有后缀名为 o 的文件。 * : 匹配0个或者是任意个字符 ? : 匹配任意一个字符 [...] : 我们可以指定匹配的字符放在 [] 中 通配符不仅可以使用在规则的命令中，还可以使用在规则中, 但是如果通配符使用在依赖的规则中的话一定要注意这个问题：不能通过引用变量的方式来使用, 如果想要引用变量, 需要使用一个函数 wildcard, 看下面这个例子. Makefile12345678910111213# 正常test: *.c gcc -o $@ $^# 错误, 会提示没有 &quot;*.c&quot; 文件OBJ = *.ctest: $(OBJ) gcc -o $@ $^# 正常, 使用一个函数 &quot;wildcard&quot;，这个函数在引用变量的时候，会自动展开OBJ = $(wildcard *.c)test: $(OBJ) gcc -o $@ $^ 模式匹配 Makefile 中有一个和通配符 “*” 相类似的字符，这个字符是 “%”，也是匹配任意个字符，使用在我们的的规则当中。使用匹配符 %，可以将大量同类型的文件，只用一条规则就完成构建。 Makefile12%.o: %.c ... 等同于下面的写法。 Makefile12f1.o: f1.cf2.o: f2.c “%.o” 把我们需要的所有的 “.o” 文件组合成为一个列表，从列表中挨个取出的每一个文件，“%” 表示取出来单个文件的文件名（不包含后缀），然后找到文件中和 &quot;%&quot;名称相同的 “.c” 文件，然后执行下面的命令，直到列表中的文件全部被取出来为止。 变量和赋值符 Makefile 允许使用等号自定义变量。调用时，变量需要放在 $( ) 之中。 123txt = Hello Worldtest: @echo $(txt) # 变量 txt 等于 Hello World 调用 Shell 变量，需要在美元符号前，再加一个美元符号，这是因为 Make 命令会对美元符号转义。 12test: @echo $$HOME 有时，变量的值可能指向另一个变量。 1v1 = $(v2) 上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。 为了解决类似问题，Makefile一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看StackOverflow。 Makefile1234567891011VARIABLE = value# 在执行时扩展，允许递归扩展。VARIABLE := value# 在定义时扩展。VARIABLE ?= value# 只有在该变量为空时才设置值。VARIABLE += value# 将值追加到变量的尾端。 内置变量（Implicit Variables） Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见Make 手册。 Makefie12output: $(CC) -o output input.c 自动变量（Automatic Variables） Make命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。 $@ $@ 指代当前目标，就是Make命令当前构建的那个目标。比如，make foo的 $@ 就指代foo。 $(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。 比如，$@ 是 src/input.c，那么 $(@D) 的值为 src ，$(@F) 的值为 input.c。 Makefie12345678a.txt b.txt: touch $@# 等同于下面的写法。a.txt: touch a.txtb.txt: touch b.txt $&lt; $&lt; 指代第一个前置条件。比如，规则为 t: p1 p2，那么 $&lt; 就指代 p1 。 $(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。 Makefie123456a.txt: b.txt c.txt cp $&lt; $@ # 等同于下面的写法。a.txt: b.txt c.txt cp b.txt a.txt $? $? 指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$? 就指代 p2。 $^ $^ 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。 $* $* 指代匹配符 % 匹配的部分， 比如 % 匹配 f1.txt 中的 f1 ，$* 就表示 f1。 所有的自动变量清单，请看Make 手册。下面是自动变量的一个例子。 Makefie123dest/%.txt: src/%.txt @[ -d dest ] || mkdir dest cp $&lt; $@ 上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，$&lt; 指代前置文件（src/%.txt）， $@ 指代目标文件（dest/%.txt）。 判断和循环 Makefile 使用 Bash 语法，完成判断和循环。 Makefie12345ifeq ($(CC),gcc) libs=$(libs_for_gcc)else libs=$(normal_libs)endif 上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。 Makefie123456789101112LIST = one two threeall: for i in $(LIST); do \\ echo $$i; \\ done# 等同于all: for i in one two three; do \\ echo $i; \\ done 上面代码的运行结果。 123onetwothree 函数 Makefile 还可以使用函数，格式如下。 Makefie123$(function arguments)# 或者${function arguments} Makefile提供了许多内置函数，可供调用。下面是几个常用的内置函数。 shell 函数 shell 函数用来执行 shell 命令 Makefie1srcfiles := $(shell echo src/{00..99}.txt) wildcard 函数 wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。 Makefie1srcfiles := $(wildcard src/*.txt) subst 函数 subst 函数用来文本替换，格式如下。 Makefie1$(subst from,to,text) 下面的例子将字符串&quot;feet on the street&quot;替换成&quot;fEEt on the strEEt&quot;。 Makefie1$(subst ee,EE,feet on the street) 下面是一个稍微复杂的例子。 Makefie1234567comma:= ,empty:=# space变量用两个空变量作为标识符，当中是一个空格space:= $(empty) $(empty)foo:= a b cbar:= $(subst $(space),$(comma),$(foo))# bar is now `a,b,c'. patsubst函数 patsubst 函数用于模式匹配的替换，格式如下。 Makefie1$(patsubst pattern,replacement,text) 下面的例子将文件名&quot;x.c.c bar.c&quot;，替换成&quot;x.c.o bar.o&quot;。 Makefie1$(patsubst %.c,%.o,x.c.c bar.c) 替换后缀名 替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上patsubst函数的一种简写形式。 Makefie1min: $(OUTPUT:.js=.min.js) 上面代码的意思是，将变量OUTPUT中的后缀名 .js 全部替换成 .min.js 。 Makefile 的实例 执行多个目标 Makefie12345678910.PHONY: cleanall cleanobj cleandiffcleanall : cleanobj cleandiff rm programcleanobj : rm *.ocleandiff : rm *.diff 上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（cleanall），删除所有指定类型的文件。 编译C语言项目 Makefie12345678910111213141516edit : main.o kbd.o command.o display.o cc -o edit main.o kbd.o command.o display.omain.o : main.c defs.h cc -c main.ckbd.o : kbd.c defs.h command.h cc -c kbd.ccommand.o : command.c defs.h command.h cc -c command.cdisplay.o : display.c defs.h cc -c display.cclean : rm edit main.o kbd.o command.o display.o.PHONY: edit clean","link":"/p/9d37c3fa/"},{"title":"pytorch-tutorials","text":"数据操作 基本操作 创建: 1234567891011121314# 从数组创建x = torch.tensor([5.5, 3])# 返回的 tensor 默认具有相同的 dtype 和 devicex = x.new_ones(5, 3, dtype=torch.float64)# 指定新的数据类型, 继承了 x 的维度x = torch.randn_like(x, dtype=torch.float)# 从函数创建, 可以指定维度, dtype, devicex = torch.empty(5, 3) # 未初始化x = torch.rand(5, 3) # [0, 1)x = torch.randn(5, 3) # 正态分布x = torch.zeros(5, 3, dtype=torch.long)x.size() == x.shape 函数 功能 Tensor(*sizes) 基础构造函数 tensor(data,) 类似np.array的构造函数 ones(*sizes) 全1Tensor zeros(*sizes) 全0Tensor eye(*sizes) 对角线为1，其他为0 arange(s,e,step) 从s到e，步长为step linspace(s,e,steps) 从s到e，均匀切分成steps份 rand/randn(*sizes) 均匀/标准分布 normal(mean,std)/uniform(from,to) 正态分布/均匀分布 randperm(m) 随机排列 加法: 1234x + ytorch.add(x, y)torch.add(x, y, out=result) # 指定输出y.add_(x) # inplace 注：PyTorch操作inplace版本都有后缀_, 例如 x.copy_(y), x.t_() 索引 使用类似NumPy的索引操作来访问Tensor的一部分 索引出来的结果与原数据共享内存，也即修改一个，另一个会跟着修改。 1234y = x[0, :]y += 1print(y)print(x[0, :]) # 源tensor也被改了 函数 功能 index_select(input, dim, index) 在指定维度dim上选取，比如选取某些行、某些列 masked_select(input, mask) 例子如上，a[a&gt;0]，使用ByteTensor进行选取 nonzero(input) 非0元素的下标 gather(input, dim, index) 根据index，在dim维度上选取数据，输出的size与index一样 view() 用于改变Tensor的形状 1234y = x.view(15)z = x.view(-1, 5) # -1所指的维度可以根据其他维度的值推出来print(x.size(), y.size(), z.size())# torch.Size([5, 3]) torch.Size([15]) torch.Size([3, 5]) 注意view()返回的新 tensor 与源 tensor 共享内存，也即更改其中的一个，另外一个也会跟着改变。 Pytorch 还提供了一个reshape()可以改变形状，但是此函数并不能保证返回的是其拷贝，所以不推荐使用。 如果不想共享内存，推荐先用**clone()**创造一个副本然后再使用view。 123456789101112x_cp = x.clone().view(15)x -= 1print(x)print(x_cp)tensor([[ 1.6035, 1.8110, 0.9549], [ 0.8797, 1.0482, -0.0445], [-0.7229, 2.8663, -0.5655], [ 0.1604, -0.0254, 1.0739], [ 2.2628, -0.9175, -0.2251]])tensor([2.6035, 2.8110, 1.9549, 1.8797, 2.0482, 0.9555, 0.2771, 3.8663, 0.4345, 1.1604, 0.9746, 2.0739, 3.2628, 0.0825, 0.7749]) 使用clone还有一个好处是会被记录在计算图中，即梯度回传到副本时也会传到源Tensor。 item() 将一个标量Tensor转换成一个Python number： 123x = torch.randn(1)print(x) # tensor([2.3466])print(x.item()) # 2.3466382026672363 线性代数 函数 功能 trace 对角线元素之和(矩阵的迹) diag 对角线元素 triu/tril 矩阵的上三角/下三角，可指定偏移量 mm/bmm 矩阵乘法，batch的矩阵乘法 addmm/addbmm/addmv/addr/baddbmm… 矩阵运算 t 转置 dot/cross 内积/外积 inverse 求逆矩阵 svd 奇异值分解 广播 当对两个形状不同的Tensor按元素运算时，可能会触发广播（broadcasting）机制：先适当复制元素使这两个Tensor形状相同后再按元素运算。 12345678910111213x = torch.arange(1, 3).view(1, 2)print(x)y = torch.arange(1, 4).view(3, 1)print(y)print(x + y)tensor([[1, 2]])tensor([[1], [2], [3]])tensor([[2, 3], [3, 4], [4, 5]]) 运算的内存开销 1234567y = x + y # 新内存地址# 原内存地址y[:] = y + xtorch.add(x, y, out=y)y += xy.add_(x) 注：虽然view返回的Tensor与源Tensor是共享data的，但是依然是一个新的Tensor（因为Tensor除了包含data外还有一些其他属性），二者id（内存地址）并不一致。 Tensor 和 NumPy 转换 1234567# tensor &lt;-&gt; numpy 共享内存a = torch.ones(5) # tensorb = a.numpy() # numpyc = torch.from_numpy(b) # tensor# numpy -&gt; tensor 不共享内存d = torch.tensor(b) # tensor GPU Tensor 用方法to()可以将Tensor在CPU和GPU（需要硬件支持）之间相互移动。 12345678# 以下代码只有在PyTorch GPU版本上才会执行if torch.cuda.is_available(): device = torch.device(&quot;cuda&quot;) # GPU y = torch.ones_like(x, device=device) # 直接创建一个在GPU上的Tensor x = x.to(device) # 等价于 .to(&quot;cuda&quot;) z = x + y print(z) print(z.to(&quot;cpu&quot;, torch.double)) # to()还可以同时更改数据类型 自动求梯度 之前介绍的Tensor是PyTorch的核心类，如果将其属性torch.requires_grad设置为True，它将开始追踪(track)在其上的所有操作（这样就可以利用链式法则进行梯度传播了）。完成计算后，可以调用.backward()来完成所有梯度计算。此Tensor的梯度将累积到.grad属性中。 注意在y.backward()时，如果y是标量，则不需要为backward()传入任何参数；否则，需要传入一个与y同形的Tensor。解释见 2.3.2 节。 如果不想要被继续追踪，可以调用.detach()将其从追踪记录中分离出来，这样就可以防止将来的计算被追踪，这样梯度就传不过去了。此外，还可以用with torch.no_grad()将不想被追踪的操作代码块包裹起来，这种方法在评估模型的时候很常用，因为在评估模型时，我们并不需要计算可训练参数（requires_grad=True）的梯度。 Function是另外一个很重要的类。Tensor和Function互相结合就可以构建一个记录有整个计算过程的有向无环图（DAG）。每个Tensor都有一个.grad_fn属性，该属性即创建该Tensor的Function, 就是说该Tensor是不是通过某些运算得到的，若是，则grad_fn返回一个与这些运算相关的对象，否则是None。 下面通过一些例子来理解这些概念。 Tensor 创建一个Tensor并设置requires_grad=True: 123x = torch.ones(2, 2, requires_grad=True)print(x)print(x.grad_fn) 输出： 123tensor([[1., 1.], [1., 1.]], requires_grad=True)None 再做一下运算操作： 123y = x + 2print(y)print(y.grad_fn) 输出： 123tensor([[3., 3.], [3., 3.]], grad_fn=&lt;AddBackward&gt;)&lt;AddBackward object at 0x1100477b8&gt; 注意x是直接创建的，所以它没有grad_fn, 而y是通过一个加法操作创建的， 所以它有一个为&lt;AddBackward&gt;的grad_fn。 像x这种直接创建的称为叶子节点，叶子节点对应的grad_fn是None。 1print(x.is_leaf, y.is_leaf) # True False 再来点复杂度运算操作： 123z = y * y * 3out = z.mean()print(z, out) 输出： 12tensor([[27., 27.], [27., 27.]], grad_fn=&lt;MulBackward&gt;) tensor(27., grad_fn=&lt;MeanBackward1&gt;) 通过.requires_grad_()来用in-place的方式改变requires_grad属性： 1234567a = torch.randn(2, 2) # 缺失情况下默认 requires_grad = Falsea = ((a * 3) / (a - 1))print(a.requires_grad) # Falsea.requires_grad_(True)print(a.requires_grad) # Trueb = (a * a).sum()print(b.grad_fn) 输出： 123FalseTrue&lt;SumBackward0 object at 0x118f50cc0&gt; 2.3.2 梯度 因为out是一个标量，所以调用backward()时不需要指定求导变量： 1out.backward() # 等价于 out.backward(torch.tensor(1.)) 我们来看看out关于x的梯度 d(out)dx\\frac{d(out)}{dx}dxd(out)​: 1print(x.grad) 输出： 12tensor([[4.5000, 4.5000], [4.5000, 4.5000]]) 我们令out为 ooo , 因为 $$ o=\\frac14\\sum_{i=1}4z_i=\\frac14\\sum_{i=1}43(x_i+2)^2 $$ 所以 $$ \\frac{\\partial{o}}{\\partial{x_i}}\\bigr\\rvert_{x_i=1}=\\frac{9}{2}=4.5 $$ 所以上面的输出是正确的。 数学上，如果有一个函数值和自变量都为向量的函数 y⃗=f(x⃗)\\vec{y}=f(\\vec{x})y​=f(x), 那么 y⃗\\vec{y}y​ 关于 x⃗\\vec{x}x 的梯度就是一个雅可比矩阵（Jacobian matrix）: $$ J=\\left(\\begin{array}{ccc} \\frac{\\partial y_{1}}{\\partial x_{1}} &amp; \\cdots &amp; \\frac{\\partial y_{1}}{\\partial x_{n}}\\ \\vdots &amp; \\ddots &amp; \\vdots\\ \\frac{\\partial y_{m}}{\\partial x_{1}} &amp; \\cdots &amp; \\frac{\\partial y_{m}}{\\partial x_{n}} \\end{array}\\right) $$ 而torch.autograd这个包就是用来计算一些雅克比矩阵的乘积的。例如，如果 vvv 是一个标量函数的 l=g(y⃗)l=g\\left(\\vec{y}\\right)l=g(y​) 的梯度： $$ v=\\left(\\begin{array}{ccc}\\frac{\\partial l}{\\partial y_{1}} &amp; \\cdots &amp; \\frac{\\partial l}{\\partial y_{m}}\\end{array}\\right) $$ 那么根据链式法则我们有 lll 关于 x⃗\\vec{x}x 的雅克比矩阵就为: $$ v J=\\left(\\begin{array}{ccc}\\frac{\\partial l}{\\partial y_{1}} &amp; \\cdots &amp; \\frac{\\partial l}{\\partial y_{m}}\\end{array}\\right) \\left(\\begin{array}{ccc} \\frac{\\partial y_{1}}{\\partial x_{1}} &amp; \\cdots &amp; \\frac{\\partial y_{1}}{\\partial x_{n}}\\ \\vdots &amp; \\ddots &amp; \\vdots\\ \\frac{\\partial y_{m}}{\\partial x_{1}} &amp; \\cdots &amp; \\frac{\\partial y_{m}}{\\partial x_{n}} \\end{array}\\right)=\\left(\\begin{array}{ccc}\\frac{\\partial l}{\\partial x_{1}} &amp; \\cdots &amp; \\frac{\\partial l}{\\partial x_{n}}\\end{array}\\right) $$ 注意：grad在反向传播过程中是累加的(accumulated)，这意味着每一次运行反向传播，梯度都会累加之前的梯度，所以一般在反向传播之前需把梯度清零。 123456789# 再来反向传播一次，注意grad是累加的out2 = x.sum()out2.backward()print(x.grad)out3 = x.sum()x.grad.data.zero_()out3.backward()print(x.grad) 输出： 1234tensor([[5.5000, 5.5000], [5.5000, 5.5000]])tensor([[1., 1.], [1., 1.]]) 现在我们解释2.3.1节留下的问题，为什么在y.backward()时，如果y是标量，则不需要为backward()传入任何参数；否则，需要传入一个与y同形的Tensor? 简单来说就是为了避免向量（甚至更高维张量）对张量求导，而转换成标量对张量求导。举个例子，假设形状为 m x n 的矩阵 X 经过运算得到了 p x q 的矩阵 Y，Y 又经过运算得到了 s x t 的矩阵 Z。那么按照前面讲的规则，dZ/dY 应该是一个 s x t x p x q 四维张量，dY/dX 是一个 p x q x m x n的四维张量。问题来了，怎样反向传播？怎样将两个四维张量相乘？？？这要怎么乘？？？就算能解决两个四维张量怎么乘的问题，四维和三维的张量又怎么乘？导数的导数又怎么求，这一连串的问题，感觉要疯掉…… 为了避免这个问题，我们不允许张量对张量求导，只允许标量对张量求导，求导结果是和自变量同形的张量。所以必要时我们要把张量通过将所有张量的元素加权求和的方式转换为标量，举个例子，假设y由自变量x计算而来，w是和y同形的张量，则y.backward(w)的含义是：先计算l = torch.sum(y * w)，则l是个标量，然后求l对自变量x的导数。 参考 来看一些实际例子。 1234x = torch.tensor([1.0, 2.0, 3.0, 4.0], requires_grad=True)y = 2 * xz = y.view(2, 2)print(z) 输出： 12tensor([[2., 4.], [6., 8.]], grad_fn=&lt;ViewBackward&gt;) 现在 y 不是一个标量，所以在调用backward时需要传入一个和y同形的权重向量进行加权求和得到一个标量。 123v = torch.tensor([[1.0, 0.1], [0.01, 0.001]], dtype=torch.float)z.backward(v)print(x.grad) 输出： 1tensor([2.0000, 0.2000, 0.0200, 0.0020]) 注意，x.grad是和x同形的张量。 再来看看中断梯度追踪的例子： 12345678910x = torch.tensor(1.0, requires_grad=True)y1 = x ** 2 with torch.no_grad(): y2 = x ** 3y3 = y1 + y2 print(x.requires_grad)print(y1, y1.requires_grad) # Trueprint(y2, y2.requires_grad) # Falseprint(y3, y3.requires_grad) # True 输出： 1234Truetensor(1., grad_fn=&lt;PowBackward0&gt;) Truetensor(1.) Falsetensor(2., grad_fn=&lt;ThAddBackward&gt;) True 可以看到，上面的y2是没有grad_fn而且y2.requires_grad=False的，而y3是有grad_fn的。如果我们将y3对x求梯度的话会是多少呢？ 12y3.backward()print(x.grad) 输出： 1tensor(2.) 为什么是2呢？$ y_3 = y_1 + y_2 = x^2 + x^3$，当 x=1x=1x=1 时 dy3dx\\frac {dy_3} {dx}dxdy3​​ 不应该是5吗？事实上，由于 y2y_2y2​ 的定义是被torch.no_grad():包裹的，所以与 y2y_2y2​ 有关的梯度是不会回传的，只有与 y1y_1y1​ 有关的梯度才会回传，即 x2x^2x2 对 xxx 的梯度。 上面提到，y2.requires_grad=False，所以不能调用 y2.backward()，会报错： 1RuntimeError: element 0 of tensors does not require grad and does not have a grad_fn 此外，如果我们想要修改tensor的数值，但是又不希望被autograd记录（即不会影响反向传播），那么我么可以对tensor.data进行操作。 1234567891011x = torch.ones(1,requires_grad=True)print(x.data) # 还是一个tensorprint(x.data.requires_grad) # 但是已经是独立于计算图之外y = 2 * xx.data *= 100 # 只改变了值，不会记录在计算图，所以不会影响梯度传播y.backward()print(x) # 更改data的值也会影响tensor的值print(x.grad) 输出： 1234tensor([1.])Falsetensor([100.], requires_grad=True)tensor([2.])","link":"/p/8e864b5/"},{"title":"Python 基本模块的使用","text":"Python 基本模块的使用 常用函数 输入输出 输入 Python3.x 中 input([prompt]) 函数接受一个标准输入数据(默认接收到的是 str 类型)，返回为 string 类型。 1val = input('some text') print() Python两种输出值的方式: 表达式语句和 print() 函数。第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。 如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。 如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。 str()： 函数返回一个用户易读的表达形式。 repr()： 产生一个解释器易读的表达形式。 123f = float(input('请输入华氏温度: '))c = (f - 32) / 1.8print('%.1f华氏度 = %.1f摄氏度' % (f, c)) str.format() 函数 安装模块 使用pip: 1pip install ipython jupyter 使用python: 1python -m pip install ipython jupyter 使用conda: 1conda install ipython jupyter 常用函数 print 12345print('hello, world!')# print(&quot;你好,世界！&quot;)print('你好', '世界')print('hello', 'world', sep=', ', end='!')print('goodbye, world', end='!\\n') os 模块 sys 模块 查看系统版本 1234import sysprint(sys.version_info)print(sys.version)","link":"/p/644af2bf/"},{"title":"Python 中的魔术方法","text":"Python 中有一种比较特别的类方法, 通常使用双下划线包裹着方法的名称, 被称为魔术方法. 英文也称为 magic method 或者 dunder method 为了比较方便地解释这些方法的作用, 我会通过构造一个类: Vector, 表示 n 维矢量, 并通过这些魔术方法逐渐地向其中添加功能. 创建对象 __init__ 123class Vector: def __init__(self, dim=1): self.dim = dim __new__ 1","link":"/p/7c8c7b3f/"},{"title":"在 Ubuntu 上安装 Pyenv","text":"Pyenv 是一个 Python 的版本控制系统, 使用它可以在多个 Python 版本, 以及多个不同的发行版(如 Anaconda)中自由切换. Github 项目地址 安装 依赖 在 Ubuntu/Debian 系统下: 123sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \\libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \\xz-utils tk-dev libffi-dev liblzma-dev python-openssl git 使用脚本自动安装 使用 pyenv-install 安装命令: 1curl https://pyenv.run | bash 事实上, pyenv.run 将会重定向为以下的地址, 这两条命令的效果是一样的: 1curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash 安装好之后, 需要重启 Shell 以使得更改生效. 升级命令: 1pyenv update 手动安装 也可以使用 Git 工具直接克隆: 1git clone https://github.com/pyenv/pyenv.git ~/.pyenv 配置文件 如果使用 zsh, 需要将以下的内容写入 ~/.zshrc 中: ~/.zshrc1234export PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;export PYENV_ROOT=$HOME/.pyenveval &quot;$(pyenv init -)&quot;eval &quot;$(pyenv virtualenv-init -)&quot; 卸载 如果只是不想在 Shell 中使用 Pyenv, 那么可以将配置文件 (~/.zshrc 或 ~/.bashrc) 中有关 pyenv init 的一行注释掉. 如果想要完全卸载 Pyenv, 可以执行 (其中 $(pyenv root) 即为 ~/.pyenv): 1rm -rf $(pyenv root) 之后删除配置文件中与 Pyenv 有关的行. 配置 pip 镜像源 ~/.pip/pip.conf12345[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[list]format=columns 基本命令 12345678pyenv install --list # 列出可安装版本pyenv install &lt;version&gt; # 安装对应版本pyenv install -v &lt;version&gt; # 安装对应版本，若发生错误，可以显示详细的错误信息pyenv versions # 显示当前使用的 python 版本pyenv which python # 显示当前 python 安装路径pyenv global &lt;version&gt; # 设置默认 Python 版本pyenv local &lt;version&gt; # 当前路径创建一个 .python-version, 以后进入这个目录自动切换为该版本pyenv shell &lt;version&gt; # 当前 shell 的 session 中启用某版本，优先级高于 global 及 local 使用 virtualenv: 12345678910111213pyenv virtualenv env # 从默认版本创建虚拟环境pyenv virtualenv 3.6.4 env-3.6.4 # 创建3.6.4版本的虚拟环境pyenv activate env-3.6.4 # 激活 env-3.6.4 这个虚拟环境pyenv deactivate # 停用当前的虚拟环境# 自动激活# 使用pyenv local 虚拟环境名# 会把`虚拟环境名`写入当前目录的.python-version文件中# 关闭自动激活 -&gt; pyenv deactivate# 启动自动激活 -&gt; pyenv activate env-3.6.4pyenv local env-3.6.4pyenv uninstall env-3.6.4 # 删除 env-3.6.4 这个虚拟环境","link":"/p/ff8dd6c4/"},{"title":"Python 环境搭建","text":"安装 Python 环境, 安装 Anaconda, 配置 pip 镜像 安装 Python Windows Windows 下没有自带的 Python 环境, 因此需要手动下载 Python 的安装包, 可以选择最新版本的 Python 安装包, 或者在下面的列表中选择特定版本. 之后进行安装, 推荐进行自定义安装, 可以选择安装位置, 并且建议勾选上 “Add Python to environment variables” 设置好安装位置后, 便可以进行安装. 安装完成后, 打开 cmd 或者 powershell, 在命令行中输入: 1python -VV 如果执行结果类似于: 1Python 3.7.3 (default, Mar 27 2019, 17:13:21) [MSC v.1915 64 bit (AMD64)] 出现相应的版本信息, 以及系统信息, 便说明完成了安装过程. linux 在 linux 系统下, 已经自带了对 Python 的支持, 因此不必重新安装 Python 环境. 如果想要使用不同的 Python 版本, 推荐使用 Pyenv 进行 Python 环境管理, 从而使得系统的 Python 环境不会受到影响. 参考另一篇文章: 在 Ubuntu 上安装 Pyenv 在 linux 系统下, 测试 python -VV: 12Python 3.7.3 (default, Jun 7 2019, 22:10:36)[GCC 7.4.0] 安装 Anaconda 在 Anaconda 官方网站的下载页面上, 可以下载 Python 2 或 3 的安装程序, 二者没有太多区别, 推荐使用 Python 3 Windows 参考教程(英): Installing on Windows 参考教程(中): Anaconda介绍、安装及使用教程 Linux 参考教程(英): Installing on linux 参考教程(中): Linux环境下的Anaconda安装 管理 conda 验证 1conda --version 终端上将会以 conda 版本号 的形式显示当前安装conda的版本号。如： conda 3.11.0 更新 conda 1conda update conda 查看帮助信息 1conda -h 管理环境 创建新环境 1conda create --name &lt;env_name&gt; &lt;package_names&gt; 如果要安装指定的版本号，则只需要在包名后面以 = 和版本号的形式执行。 如： conda create --name python2 python=2.7 ，即创建一个名为“python2”的环境，环境中安装版本为2.7的python。 如果要在新创建的环境中创建多个包，则直接在 &lt;package_names&gt; 后以空格隔开，添加多个包名即可。 如： conda create -n python3 python=3.5 numpy pandas ，即创建一个名为“python3”的环境，环境中安装版本为3.5的python，同时也安装了numpy和pandas。 切换环境 Linux 或 macOS 1source activate &lt;env_name&gt; Windows 1activate &lt;env_name&gt; 退出环境至root Linux 或 macOS 1source deactivate Windows 1deactivate 显示已创建环境 以下三条命令等价: 123conda info --envsconda info -econda env list 复制环境 1conda create --name &lt;new_env_name&gt; --clone &lt;copied_env_name&gt; 删除环境 1conda remove --name &lt;env_name&gt; --all 管理包 查找可供安装的包版本 精确查找 1conda search --full-name &lt;package_full_name&gt; 模糊查找 1conda search &lt;text&gt; 获取当前环境中已安装的包信息 1conda list 执行上述命令后将在终端显示当前环境已安装包的包名及其版本号。 安装包 在指定环境中安装包 1conda install --name &lt;env_name&gt; &lt;package_name&gt; 例如： conda install --name python2 pandas 即在名为“python2”的环境中安装pandas包。 在当前环境中安装包 1conda install &lt;package_name&gt; 使用pip安装包 → 使用场景 当使用 conda install 无法进行安装时，可以使用pip进行安装。例如：see包。 → 命令 1pip install &lt;package_name&gt; → 注意 pip只是包管理器，无法对环境进行管理。因此如果想在指定环境中使用pip进行安装包，则需要先切换到指定环境中，再使用pip命令安装包。 pip无法更新python，因为pip并不将python视为包。 pip可以安装一些conda无法安装的包；conda也可以安装一些pip无法安装的包。因此当使用一种命令无法安装包时，可以尝试用另一种命令。 卸载包 卸载指定环境中的包 1conda remove --name &lt;env_name&gt; &lt;package_name&gt; 例如： conda remove --name python2 pandas 即卸载名为“python2”中的pandas包。 卸载当前环境中的包 1conda remove &lt;package_name&gt; 更新包 更新所有包 1conda update --all 或 1conda upgrade --all 建议：在安装Anaconda之后执行上述命令更新Anaconda中的所有包至最新版本，便于使用。 更新指定包 1conda update &lt;package_name&gt; 或 1conda upgrade &lt;package_name&gt; 注意：更新多个指定包，则包名以空格隔开，向后排列。如： conda update pandas numpy matplotlib 即更新pandas、numpy、matplotlib包。 配置镜像 pip 镜像 阿里云 中国科技大学 豆瓣(douban) 清华大学 中国科学技术大学 本文使用清华的镜像源 临时使用 1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package 注意，simple 不能少, 是 https 而不是 http 使用配置文件 在 linux 系统下, 新建 ~/.pip/pip.conf 文件, Windows 系统下在个人文件夹中创建一个 pip 目录，如：C:\\Users\\xx\\pip，新建文件 pip.ini，内容如下 ~/.pip/pip.conf12345[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[list]format=columns 使用 config 命令 升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置： 12pip install pip -Upip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 如果 pip 默认源的网络连接较差，临时使用镜像站来升级 pip： 1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U conda 镜像 目前国内的 conda 镜像站基本都已经关闭.","link":"/p/a8f23fb8/"},{"title":"Array - 数组问题","text":"1. Two Sum 已知数组 nums，求其中两数之和等于 target 的下标。 123456789class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: all = dict() for x, y in enumerate(nums): if all.get(target - y, None) != None: # if target - y in all: # 使用 in 简化逻辑 return [all[target-y], x] else: all[y] = x 67. Add Binary 123456789101112131415class Solution: def addBinary(self, a: str, b: str) -&gt; str: length = max(len(a), len(b)) + 1 a = '0' * (length - len(a)) + a b = '0' * (length - len(b)) + b ret = '' c = 0 for i in range(length): s = int(a[-i-1]) + int(b[-i-1]) + c ret = str(s % 2) + ret c = s // 2 if ret[0] == '0': return ret[1:] else: return ret","link":"/p/d87f7e0c/"},{"title":"LeetCode-Linked","text":"2. Add Two Numbers 123456789101112131415161718192021# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: ret = ListNode(0) p = ret r = 0 while(r or l1 or l2): a1 = 0 if not l1 else l1.val l1 = None if not l1 else l1.next a2 = 0 if not l2 else l2.val l2 = None if not l2 else l2.next s = a1 + a2 + r r = s // 10 p.next = ListNode(s % 10) p = p.next return ret.next","link":"/p/1d0da4bd/"},{"title":"LeetCode 中的数学算法","text":"50. Pow(x, n) 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例: 输入: 2.00000, 10 输出: 1024.00000 输入: 2.10000, 3 输出: 9.26100 输入: 2.00000, -2 输出: 0.25000 解释: 2−2=(1/2)2=1/4=0.252^{-2} = (1/2)^2 = 1/4 = 0.252−2=(1/2)2=1/4=0.25 说明: -100.0 &lt; x &lt; 100.0. n 是 32 位有符号整数，其数值范围是 [−231-2^{31}−231, 231−12^{31} - 1231−1] 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/powx-n","link":"/p/ffac41da/"},{"title":"LeetCode - Tree","text":"Tree 123456Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 1315. Sum of Nodes with Even-Valued Grandparent 123456789101112131415161718192021222324class Solution: def sumOfGrandson(self, root: TreeNode) -&gt; int: ret = 0 if root.left: if root.left.left: ret += root.left.left.val if root.left.right: ret += root.left.right.val if root.right: if root.right.left: ret += root.right.left.val if root.right.right: ret += root.right.right.val return ret def sumEvenGrandparent(self, root: TreeNode) -&gt; int: ret = 0 if not root: return 0 if root.val % 2 == 0: ret += self.sumOfGrandson(root) ret += self.sumEvenGrandparent(root.left) + self.sumEvenGrandparent(root.right) return ret One-line 算法 Intuition Let children know who their grandparent is. Explanation Assume root has parent.val = 1 and grandparent.val = 1. Recursive iterate the whole tree and pass on the value of parent and grandparent. Count the root.val when grandparant if odd-valued. Complexity Time O(N) Space O(height) 1234def sumEvenGrandparent(self, root, p=1, gp=1): return self.sumEvenGrandparent(root.left, root.val, p) \\ + self.sumEvenGrandparent(root.right, root.val, p) \\ + root.val * (1 - gp % 2) if root else 0","link":"/p/809ed4d3/"},{"title":"SQL 必知必会 - 单表查询&#x2F;过滤&#x2F;汇总","text":"SQL 必知必会 - 全书目录 第 01 - 10 章：SQL 必知必会 - 单表查询/过滤/汇总 第 11 - 24 章：SQL 必知必会 - 多表查询/联结/组合 第 15 - 24 章：SQL 必知必会 - 数据更新/存储/事务 基础 SQL（发音为字母 S-Q-L 或 sequel）是 Structured Query Language（结构化查询语言）的缩写 SQL 是一种专门用来与数据库沟通的语言 标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL 数据库（database）: 保存有组织的数据的容器（通常是一个文件或一组文件） 数据库软件应称为数据库管理系统（DBMS） 表（table）: 某种特定类型数据的结构化清单 模式（schema）: 关于数据库和表的布局及特性的信息 列（column）: 表中的一个字段, 所有表都是由一个或多个列组成的 行（row）: 表中的一个记录, 有时也称其为数据库记录（record） 数据类型: 所允许的数据的类型. 每个表列都有相应的数据类型, 它限制（或允许）该列中存储的数据 主键（primary key）: 一列（或一组列）, 其值能够唯一标识表中每一行 表中的任何列都可以作为主键，只要它满足以下条件： 任意两行都不具有相同的主键值 每一行都必须具有一个主键值（主键列不允许 NULL 值） 主键列中的值不允许修改或更新 主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行） 检索数据 - SELECT 每句 SQL 语句都建议使用 ; 结尾; 所有空格会被忽略 行内注释使用 -- 或 # (一般不使用), 多行注释使用 /* ... */ 在不指定排序的情况下, 输出没有特定的顺序 SQL 语句不区分大小写, 但习惯上对 SQL 的关键词使用大写, 对列名和表名使用小写 使用 DISTINCT 去重输出不同的值, 作用于所有的列 限制输出的结果数目: SQL Server, Access: 使用 TOP 关键字 DB2: FETCH FIRST 5 ROWS ONLY; Oracle: WHERE ROWNUM &lt;=5; MySQL, MariaDB, PostgreSQL, SQLite: LIMIT 子句和 OFFSET 子句 123456789101112131415161718192021222324-- 检索单个列SELECT prod_name FROM Products;-- 检索多个列SELECT prod_id, prod_name, prod_price FROM Products;-- 检索所有列, 由于检索不需要的列, 会影响性能SELECT * FROM Products;-- 去重输出, 在指定多个列时, 除非指定的两列完全相同，否则所有的行都会被检索出来SELECT DISTINCT vend_id FROM Products;-- 限制输出结果, 不同的数据库实现方式不同-- SQL Server, AccessSELECT TOP 5 prod_name FROM Products;-- DB2SELECT prod_name FROM Products FETCH FIRST 5 ROWS ONLY;-- OracleSELECT prod_name FROM Products WHERE ROWNUM &lt;=5;-- MySQL, MariaDB, PostgreSQL, SQLiteSELECT prod_name FROM Products LIMIT 5;SELECT prod_name FROM Products LIMIT 5 OFFSET 5;-- MySQL, MariaDB: LIMIT 3 OFFSET 4 可简写为 LIMIT 4, 3SELECT prod_name FROM Products LIMIT 5, 5; 排序检索数据 - ORDER BY 在指定一条 ORDER BY 子句时，应该保证它是 SELECT 语句中最后一条子句 可以使用未检索的列进行排序 支持按相对列位置, 此时不能使用未检索的列进行排序 默认为 ASC 或 ASCENDING 升序排序, 降序排序使用 DESC 或 DESCENDING DESC 关键字只应用到直接位于其前面的列名, 指定多个列时, 每个列都需要 DESC 关键字 123456789101112131415161718SELECT prod_nameFROM ProductsORDER BY prod_name;-- 先按 prod_price, 再按 prod_name 进行排序SELECT prod_id, prod_price, prod_nameFROM ProductsORDER BY prod_price, prod_name;-- 等同于上个例子SELECT prod_id, prod_price, prod_nameFROM ProductsORDER BY 2, 3;-- 先按 prod_price 降序排序, 再按 prod_name 升序排序SELECT prod_id, prod_price, prod_nameFROM ProductsORDER BY prod_price DESC, prod_name; 过滤数据 - WHERE 使用 SELECT 语句的 WHERE 子句指定搜索条件 WHERE 语句支持的操作符如下图, 注意某些操作符是冗余的, 具体支持参阅对应的数据库软件实现 BETWEEN 操作符需要两个值，即范围的开始值和结束值 BETWEEN 匹配范围中所有的值，包括指定的开始值和结束值 空值检查: 特殊的 WHERE 子句: IS NULL 子句 NULL 和非匹配: 在进行匹配过滤或非匹配过滤时, 不会返回值为 NULL 的行。 12345678910-- 一些常用的例子SELECT vend_id, prod_name, prod_priceFROM ProductsWHERE prod_price = 3.49;WHERE prod_price &lt; 10;WHERE prod_price &lt;= 10;WHERE vend_id &lt;&gt; 'DLL01';WHERE vend_id != 'DLL01';WHERE prod_price BETWEEN 5 AND 10;WHERE prod_price IS NULL; 高级数据过滤 - AND/OR/IN/NOT SQL 允许给出多个 WHERE 子句, 以 AND 子句或 OR 子句的方式使用 AND 操作符用来指示检索匹配所有给定条件的行 OR 操作符用来指示检索匹配任一条件的行 支持短路求值, AND 的优先级比 OR 高, 可使用圆括号 () 手动指定优先级 IN 操作符用来指定条件范围，范围中的每个条件都可以进行匹配 等同于 OR 操作符, 但 IN 操作符的语法更清楚，更直观。 在与其他 AND 和 OR 操作符组合使用 IN 时，求值顺序更容易管理 IN 操作符一般比一组 OR 操作符执行得更快 IN 的最大优点是可以包含其他 SELECT 语句，能够更动态地建立 WHERE 子句。 NOT 操作符否定其后所跟的任何条件, 总是与其他操作符一起使用 部分场景下也可用 &lt;&gt; 操作符来替代 在更复杂的子句中, NOT 是非常有用的 123456SELECT prod_id, prod_price, prod_nameFROM ProductsWHERE vend_id = 'DLL01' AND prod_price &lt;= 4;WHERE vend_id = 'DLL01' OR vend_id = 'BRS01';WHERE vend_id IN ( 'DLL01', 'BRS01' )WHERE NOT vend_id = 'DLL01' 用通配符进行过滤 - LIKE/%_[^] 利用通配符，可以创建比较特定数据的搜索模式, 用来匹配值的一部分 通配符搜索只能用于文本字段(字符串), 非文本数据类型字段不能使用通配符搜索 百分号 % 通配符: 表示任何字符出现任意次数 Microsoft Access 中需要使用 * 是否区分大小写与数据库有关 能匹配 0 个字符, 代表搜索模式中给定位置的 0 个、1 个或多个字符 许多 DBMS 都用空格来填补字段的内容, 使用 % 时需要考虑末尾填充的空格 % 不会匹配产品名称为 NULL 的行 下划线 _ 通配符: 只匹配单个字符 DB2 不支持通配符 _, Microsoft Access中需要使用 ? 方括号 [] 通配符: 匹配方括号中任意单个字符 不是所有 DBMS 都支持用来创建集合的 [] 可以用 前缀字符 ^（脱字号）来否定 Microsoft Access 中需要用 ! 来否定 通配符搜索一般比前面讨论的其他搜索要耗费更长的处理时间 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。 12345678910111213-- %SELECT prod_id, prod_nameFROM ProductsWHERE prod_name LIKE 'Fish%'; -- 所有以词 Fish 起头的产品WHERE prod_name LIKE '%bean bag%'; -- 所有包含 bean bag 的产品WHERE prod_name LIKE 'F%y'; -- 所有以 F 起头, 以 y 结尾的产品-- _WHERE prod_name LIKE '__ inch teddy bear';-- []SELECT cust_contactFROM CustomersWHERE cust_contact LIKE '[JM]%' -- 所有名字以 J 或 M 起头的联系人WHERE cust_contact LIKE '[^JM]%' -- 所有名字不以 J 或 M 起头的联系人 创建计算字段 - AS/+|| 拼接字段: 将值联结到一起（将一个值附加到另一个值）构成单个值。 Access 和 SQL Server 使用 + 号 DB2, Oracle, PostgreSQL, SQLite 和 Open Office Base 使用 || MySQL 和 MariaDB 中使用特殊的函数 Concat 使用别名: 用 AS 关键字 有时也称为导出列 (derived column) 执行算术计算: 支持 +-*/ 圆括号可用来区分优先顺序 省略了 FROM 子句后就是简单地访问和处理表达式 123456789101112131415161718192021-- 拼接字段, 使用别名-- RTRIM() 函数去掉值右边的所有空格, 还有 LTRIM(), TRIM()SELECT RTRIM(vend_name) + ' (' + RTRIM(vend_country) + ')'SELECT RTRIM(vend_name) || ' (' || RTRIM(vend_country) || ')'SELECT Concat(RTRIM(vend_name), ' (', RTRIM(vend_country), ')') AS vend_titleFROM VendorsORDER BY vend_name;-- 执行算术计算SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_priceFROM OrderItemsWHERE order_num = 20008;-- 直接计算SELECT 3 * 2; -- 6SELECT Trim(' abc '); -- 'abc'SELECT Now(); -- 当前日期和时间 使用函数处理数据 - 函数 只有少数几个函数被所有主要的 DBMS 等同地支持 与 SQL 语句不一样, SQL 函数不是可移植的 大多数 SQL 实现支持以下类型的函数 用于处理文本字符串（如删除或填充值，转换值为大写或小写）的文本函数 SOUNDEX() 是一个将任何文本串转换为描述其语音表示的字母数字模式的算法 用于在数值数据上进行算术操作（如返回绝对值，进行代数运算）的数值函数 用于处理日期和时间值并从这些值中提取特定成分（如返回两个日期之差，检查日期有效性）的日期和时间函数 返回 DBMS 正使用的特殊信息（如返回用户登录信息）的系统函数 12345678910111213141516-- 使用 SOUNDEX() 函数进行搜索, 匹配所有发音类似于 Michael Green 的联系名：SELECT cust_name, cust_contactFROM CustomersWHERE SOUNDEX(cust_contact) = SOUNDEX('Michael Green');-- 检索 2012 年的所有订单SELECT order_numFROM OrdersWHERE DATEPART(yy, order_date) = 2012; -- SQL ServerWHERE DATEPART('yyyy', order_date) = 2012; -- AccessWHERE DATE_PART('year', order_date) = 2012; -- PostgreSQLWHERE to_number(to_char(order_date, 'YYYY')) = 2012; -- OracleWHERE order_date BETWEEN to_date('01-01-2012') AND to_date('12-31-2012'); -- OracleWHERE YEAR(order_date) = 2012; -- MySQL, MariaDBWHERE strftime('%Y', order_date) = '2012'; -- SQLite 汇总数据 - 聚集函数 聚集函数: 汇总数据而不用把它们实际检索出来 AVG() 只能用来确定特定数值列的平均值, 而且列名必须作为函数参数给出 只用于单个列 忽略列值为 NULL 的行 COUNT() 确定表中行的数目或符合特定条件的行的数目 COUNT(*) 对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值 COUNT(column) 对特定列中具有值的行进行计数，忽略 NULL 值。 MAX() / MIN() 返回指定列中的最大/小值, 要求指定列名, 忽略列值为 NULL 的行 允许将它用来返回任意列中的最大/小值 SUM() 用来返回指定列值的和（总计）, 忽略列值为 NULL 的行。 聚集不同值: 对所有行执行计算，指定 ALL 参数或不指定参数（因为 ALL 是默认行为）。 只包含不同的值，指定 DISTINCT 参数。 DISTINCT 必须使用列名, 只能用于 COUNT(), DISTINCT 不能用于 COUNT(*) 组合聚集函数 12345678910111213141516171819202122232425262728293031-- 计算平均值SELECT AVG(prod_price) AS avg_priceFROM ProductsWHERE vend_id = 'DLL01';-- 检索客人数目SELECT COUNT(*) AS num_custSELECT COUNT(cust_email) AS num_custFROM Customers;-- 检索最高/低单价SELECT MAX(prod_price) AS max_priceSELECT MIN(prod_price) AS min_priceFROM Products;-- 计算总的订单金额SELECT SUM(item_price*quantity) AS total_priceFROM OrderItemsWHERE order_num = 20005;-- 特定供应商提供的产品的平均价格, 只考虑各个不同的价格SELECT AVG(DISTINCT prod_price) AS avg_priceFROM ProductsWHERE vend_id = 'DLL01';-- 同时使用多个聚集函数SELECT COUNT(*) AS num_items, MIN(prod_price) AS price_min, MAX(prod_price) AS price_max, AVG(prod_price) AS price_avgFROM Products; 分组数据 - GROUP BY/HAVING 使用分组可以将数据分为多个逻辑组, 对每个组进行聚集计算 创建分组: 使用 SELECT 语句的 GROUP BY 子句 可以包含任意数目的列，因而可以对分组进行嵌套 如果在 GROUP BY 子句中嵌套了分组，数据将在最后指定的分组上进行汇总 列出的每一列都必须是检索列或有效的表达式, 不能使用别名 大多数 SQL 实现不允许 GROUP BY 列带有长度可变的数据类型 除聚集计算语句外，SELECT 语句中的每一列都必须在 GROUP BY 子句中给出 如果分组列中包含具有 NULL 值的行，则 NULL 将作为一个分组返回. 如果列中有多行 NULL 值，它们将分为一组 GROUP BY 子句必须出现在 WHERE 子句之后，ORDER BY 子句之前 过滤分组: HAVING 子句 WHERE 过滤指定的是行, HAVING 过滤指定的是分组 HAVING 支持所有 WHERE 操作符 WHERE 在数据分组前进行过滤, HAVING 在数据分组后进行过滤 WHERE 排除的行不包括在分组中, 这可能会改变计算值, 从而影响 HAVING 子句中基于这些值过滤掉的分组 如果不指定 GROUP BY, 则大多数 DBMS 会同等对待它们 分组和排序 一般在使用 GROUP BY 子句时, 应该也给出 ORDER BY 子句 这是保证数据正确排序的唯一方法, 千万不要仅依赖 GROUP BY 排序数据 1234567891011121314151617181920-- GROUP BY 子句指示 DBMS 按 vend_id 排序并分组数据SELECT vend_id, COUNT(*) AS num_prodsFROM ProductsGROUP BY vend_id;-- 过滤出 COUNT(*) &gt;= 2（两个以上订单）的那些分组-- 在这里无法使用 WHERE 语句, 因为过滤是基于分组聚集值, 而不是特定行的值SELECT cust_id, COUNT(*) AS ordersFROM OrdersGROUP BY cust_idHAVING COUNT(*) &gt;= 2;-- 列出具有两个以上产品且其价格都大于等于 4 的供应商-- WHERE 子句过滤所有 prod_price 至少为4 的行-- 然后按 vend_id 分组数据, HAVING 子句过滤计数为 2 或 2 以上的分组。SELECT vend_id, COUNT(*) AS num_prodsFROM ProductsWHERE prod_price &gt;= 4GROUP BY vend_idHAVING COUNT(*) &gt;= 2; SQL 必知必会 - 全书目录 第 01 - 10 章：SQL 必知必会 - 单表查询/过滤/汇总 第 11 - 24 章：SQL 必知必会 - 多表查询/联结/组合 第 15 - 24 章：SQL 必知必会 - 数据更新/存储/事务","link":"/p/57d19b2c/"},{"title":"SQL 必知必会 - 多表查询&#x2F;联结&#x2F;组合","text":"SQL 必知必会 - 全书目录 第 01 - 10 章：SQL 必知必会 - 单表查询/过滤/汇总 第 11 - 24 章：SQL 必知必会 - 多表查询/联结/组合 第 15 - 24 章：SQL 必知必会 - 数据更新/存储/事务 使用子查询 - subquery SQL 还允许创建子查询（subquery）, 即嵌套在其他查询中的查询 把子查询分解为多行并进行适当的缩进, 能极大地简化子查询的使用 作为子查询的 SELECT 语句只能查询单个列, 企图检索多个列将返回错误 1234567891011121314151617181920212223-- 利用子查询进行过滤-- (1) 检索包含物品 RGAN01 的所有订单的编号。-- (2) 检索具有前一步骤列出的订单编号的所有顾客的 ID。-- (3) 检索前一步骤返回的所有顾客 ID 的顾客信息。SELECT cust_name, cust_contactFROM CustomersWHERE cust_id IN (SELECT cust_id FROM Orders WHERE order_num IN (SELECT order_num FROM OrderItems WHERE prod_id = 'RGAN01'));-- 作为计算字段使用子查询-- (1) 从 Customers 表中检索顾客列表；-- (2) 对于检索出的每个顾客，统计其在 Orders 表中的订单数目。-- 子查询在构造这种 SELECT 语句时极有用, 但必须注意限制有歧义的列。SELECT cust_name, cust_state, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS ordersFROM CustomersORDER BY cust_name; 联结表 - join SQL 最强大的功能之一就是能在数据查询的执行中联结（ join）表 关系表 关系表的设计就是要把信息分解成多个表，一类数据一个表 各表通过某些共同的值互相关联（所以才叫关系数据库） 可伸缩（scale）：能够适应不断增加的工作量而不失败。 设计良好的数据库或应用程序称为可伸缩性好（scale well） 联结是一种机制，用来在一条 SELECT 语句中关联表，因此称为联结 使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行 创建联结：指定要联结的所有表以及关联它们的方式 WHERE 子句作为过滤条件，只包含那些匹配给定条件（这里是联结条件）的行 笛卡儿积（cartesian product）：由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。也叫叉联结（cross join）。 等值联结（equijoin），也称为内联结（inner join） ANSI SQL 规范首选 INNER JOIN 语法， 1234567891011121314151617181920212223242526272829-- prod_name, prod_price 在一个表中，而 vend_name 在另一个表中SELECT vend_name, prod_name, prod_priceFROM Vendors, ProductsWHERE Vendors.vend_id = Products.vend_id;-- 笛卡儿积SELECT vend_name, prod_name, prod_priceFROM Vendors, Products;-- 稍微不同的语法，结果相同-- 两个表之间的关系是以 INNER JOIN 指定的部分 FROM 子句-- 联结条件用特定的 ON 子句而不是 WHERE 子句给出SELECT vend_name, prod_name, prod_priceFROM Vendors INNER JOIN ProductsON Vendors.vend_id = Products.vend_id;-- 联结多个表SELECT prod_name, vend_name, prod_price, quantityFROM OrderItems, Products, VendorsWHERE Products.vend_id = Vendors.vend_idAND OrderItems.prod_id = Products.prod_idAND order_num = 20007;-- 第 11 章的例子可以简化为：SELECT cust_name, cust_contactFROM Customers, Orders, OrderItemsWHERE Customers.cust_id = Orders.cust_idAND OrderItems.order_num = Orders.order_numAND prod_id = 'RGAN01'; 创建高级联结 在创建计算字段中，可以使用 AS 关键字给列起别名 SQL 除了可以对列名和计算字段使用别名，还允许给表名起别名 缩短SQL 语句 允许在一条 SELECT 语句中多次使用相同的表 Oracle 不支持 AS 表别名只在查询执行中使用 自联结：通常作为外部语句，用来替代从相同表中检索数据的使用子查询语句 自然联结：排除多次出现的列，使每一列只返回一次 要求你只能选择那些唯一的列 一般通过对一个表使用通配符（ SELECT *），而对其他表的列使用明确的子集来完成 外联结：有时候需要包含没有关联行的那些行 对每个顾客下的订单进行计数，包括那些至今尚未下订单的顾客 列出所有产品以及订购数量，包括没有人订购的产品 计算平均销售规模，包括那些至今尚未下订单的顾客。 使用关键字 OUTER JOIN 来指定联结类型 在使用 OUTER JOIN 语法时，必须使用 RIGHT 或 LEFT 关键字指定包括其所有行的表 RIGHT 指出的是 OUTER JOIN 右边的表，而 LEFT 指出的是 OUTER JOIN 左边的表 SQLite 只支持 LEFT OUTER JOIN 全外联结：检索两个表中 的所有行并关联那些可以关联的行 FULL OUTER JOIN Access、MariaDB、MySQL、Open Office Base 和 SQLite 不支持 FULL OUTER JOIN 语法。 使用带聚集函数的联结 使用联结和联结条件 注意所使用的联结类型。一般我们使用内联结，但使用外联结也有效。 关于确切的联结语法，应该查看具体的文档，看相应的DBMS 支持何种语法（大多数DBMS 使用这两课中描述的某种语法）。 保证使用正确的联结条件（不管采用哪种语法），否则会返回不正确的数据。 应该总是提供联结条件，否则会得出笛卡儿积。 在一个联结中可以包含多个表，甚至可以对每个联结采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前分别测试每个联结。这会使故障排除更为简单。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556-- FROM 子句中的三个表全都有别名SELECT cust_name, cust_contactFROM Customers AS C, Orders AS O, OrderItems AS OIWHERE C.cust_id = O.cust_id AND OI.order_num = O.order_num AND prod_id = 'RGAN01';-- 使用子查询SELECT cust_id, cust_name, cust_contactFROM CustomersWHERE cust_name = (SELECT cust_name FROM Customers WHERE cust_contact = 'Jim Jones');-- 等同于上面，但使用自联结-- 查询中需要的两个表实际上是相同的表，因此 Customers 表在 FROM 子句中出现了两次-- 需要使用表别名SELECT c1.cust_id, c1.cust_name, c1.cust_contactFROM Customers AS c1, Customers AS c2WHERE c1.cust_name = c2.cust_name AND c2.cust_contact = 'Jim Jones';-- 自然联结SELECT C.*, O.order_num, O.order_date, OI.prod_id, OI.quantity, OI.item_priceFROM Customers AS C, Orders AS O, OrderItems AS OIWHERE C.cust_id = O.cust_id AND OI.order_num = O.order_num AND prod_id = 'RGAN01';-- 内联结，检索所有顾客及其订单SELECT Customers.cust_id, Orders.order_numFROM Customers INNER JOIN Orders ON Customers.cust_id = Orders.cust_id;-- 外联结-- 从左边的表中选择所有行SELECT Customers.cust_id, Orders.order_numFROM Customers LEFT OUTER JOIN Orders ON Customers.cust_id = Orders.cust_id;-- 从右边的表中选择所有行SELECT Customers.cust_id, Orders.order_numFROM Customers RIGHT OUTER JOIN Orders ON Orders.cust_id = Customers.cust_id;-- 全外联结SELECT Customers.cust_id, Orders.order_numFROM Orders FULL OUTER JOIN Customers ON Orders.cust_id = Customers.cust_id;-- 使用带聚集函数的联结-- 检索所有顾客及每个顾客所下的订单数SELECT Customers.cust_id,COUNT(Orders.order_num) AS num_ordFROM Customers INNER JOIN OrdersON Customers.cust_id = Orders.cust_idGROUP BY Customers.cust_id; 组合查询 多数 SQL 查询只包含从一个或多个表中返回数据的单条 SELECT 语句 SQL 也允许执行多个查询（多条 SELECT 语句），并将结果作为一个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query） 主要有两种情况需要使用组合查询： 在一个查询中从不同的表返回结构数据 对一个表执行多个查询，按一个查询返回数据（等同于具有多个 WHERE 子句的查询） 创建组合查询 可用 UNION 操作符来组合数条SQL 查询 给出每条 SELECT 语句，在各条语句之间放上关键字 UNION UNION 必须由两条或两条以上的 SELECT 语句组成，语句之间用关键字 UNION 分隔（因此，如果组合四条``SELECT语句，将要使用三个UNION` 关键字）。 UNION 中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）。 列数据类型必须兼容：类型不必完全相同，但必须是 DBMS 可以隐含转换的类型（例如，不同的数值类型或不同的日期类型）。 UNION 从查询结果集中自动去除了重复的行 如果想返回所有的匹配行，可使用 UNION ALL 而不是 UNION 对组合查询结果排序: 在用 UNION 组合查询时，只能使用一条 ORDER BY 子句，它必须位于最后一条 SELECT 语句之后 12345678910111213141516171819202122-- 几个州的所有顾客SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN ('IL','IN','MI');-- 所有的Fun4AllSELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_name = 'Fun4All';-- 组合查询SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN ('IL','IN','MI')UNIONSELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_name = 'Fun4All';-- 等同于SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN ('IL','IN','MI') OR cust_name = 'Fun4All'; SQL 必知必会 - 全书目录 第 01 - 10 章：SQL 必知必会 - 单表查询/过滤/汇总 第 11 - 24 章：SQL 必知必会 - 多表查询/联结/组合 第 15 - 24 章：SQL 必知必会 - 数据更新/存储/事务","link":"/p/4c50c6b4/"},{"title":"SQL 必知必会 - 数据更新&#x2F;存储&#x2F;事务","text":"SQL 必知必会 - 全书目录 第 01 - 10 章：SQL 必知必会 - 单表查询/过滤/汇总 第 11 - 24 章：SQL 必知必会 - 多表查询/联结/组合 第 15 - 24 章：SQL 必知必会 - 数据更新/存储/事务 插入数据 - INSERT INSERT 用来将行插入（或添加）到数据库表 在某些 SQL 实现中，跟在 INSERT 之后的 INTO 关键字是可选的 插入完整的行 不要使用没有明确给出列的 INSERT 语句 VALUES 的数目都必须正确 插入行的一部分 可以在 INSERT 操作中省略某些列 该列定义为允许 NULL 值（无值或空值） 在表定义中给出默认值。这表示如果不给出值，将使用默认值 插入某些查询的结果：INSERT SELECT INSERT SELECT 中 SELECT 语句可以包含 WHERE 子句，以过滤插入的数据 INSERT 通常只插入一行。要插入多行，必须执行多个 INSERT 语句。INSERT SELECT 是个例外，它可以用一条 INSERT 插入多行，不管 SELECT 语句返回多少行，都将被 INSERT 插入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071-- 插入完整的行, 必须给每一列提供一个值-- 高度依赖于表中列的定义次序，还依赖于其容易获得的次序信息-- 这种语法很简单，但并不安全，应该尽量避免使用INSERT INTO CustomersVALUES( '1000000006', 'Toy Land', '123 Any Street', 'New York', 'NY', '11111', 'USA', NULL, NULL);-- 更安全（不过更烦琐）的方法INSERT INTO Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES('1000000006', 'Toy Land', '123 Any Street', 'New York', 'NY', '11111', 'USA', NULL, NULL);-- 插入部分行INSERT INTO Customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)VALUES('1000000006', 'Toy Land', '123 Any Street', 'New York', 'NY', '11111', 'USA');-- 插入检索出的数据-- INSERT SELECTINSERT INTO Customers(cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)SELECT cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_countryFROM CustNew; 从一个表复制到另一个表：使用 SELECT INTO 语句 任何 SELECT 选项和子句都可以使用，包括 WHERE 和 GROUP BY 可利用联结从多个表插入数据 不管从多少个表中检索数据，数据都只能插入到一个表中 12345678-- 创建一个名为 CustCopy 的新表, 并把 Customers 表的整个内容复制到新表中SELECT *INTO CustCopyFROM Customers;-- MariaDB、MySQL、Oracle、PostgreSQL 和 SQLite 使用的语法CREATE TABLE CustCopy ASSELECT * FROM Customers; 更新和删除数据 - UPDATE/DELETE 更新数据 更新数据：UPDATE 语句，不要省略 WHERE 子句，否则将会更新所有行 基本的 UPDATE 语句 要更新的表 列名和它们的新值 确定要更新哪些行的过滤条件 UPDATE 语句中可以使用子查询，使得能用 SELECT 语句检索出的数据更新列数据 要删除某个列的值，可设置它为 NULL（假如表定义允许 NULL 值） 12345678UPDATE CustomersSET cust_contact = 'Sam Roberts', cust_email = 'kim@thetoystore.com'WHERE cust_id = '1000000005';UPDATE CustomersSET cust_email = NULLWHERE cust_id = '1000000005'; 删除数据 删除数据：DELETE 语句，不要省略 WHERE 子句，否则将会删除所有行 DELETE 不需要列名或通配符 DELETE 删除整行而不是删除列 DELETE 不删除表本身 123-- 从 Customers 表中删除一行DELETE FROM CustomersWHERE cust_id = '1000000006'; 更新和删除的指导原则 除非确实打算更新和删除每一行，否则绝对不要使用不带 WHERE 子句的 UPDATE 或 DELETE 语句 保证每个表都有主键（如果忘记这个内容，请参阅第 12 课），尽可能像 WHERE 子句那样使用它（可以指定各主键、多个值或值的范围） 在 UPDATE 或 DELETE 语句使用 WHERE 子句前，应该先用 SELECT 进行测试，保证它过滤的是正确的记录，以防编写的WHERE 子句不正确。 使用强制实施引用完整性的数据库（关于这个内容，请参阅第 12 课），这样 DBMS 将不允许删除其数据与其他表相关联的行。 有的 DBMS 允许数据库管理员施加约束，防止执行不带 WHERE 子句的 UPDATE 或 DELETE 语句。如果所采用的 DBMS 支持这个特性，应该使用它。 创建和操纵表 - CREATE/ALTER 创建表 SQL 不仅用于表数据操纵，还用来执行数据库和表的所有操作，包括表本身的创建和处理。 用程序创建表，可以使用 SQL 的 CREATE TABLE 语句 在不同的 SQL 实现中，CREATE TABLE 语句的语法可能有所不同 在创建新的表时，指定的表名必须不存在，否则会出错。 利用CREATE TABLE 创建表，必须给出下列信息： 新表的名字，在关键字CREATE TABLE 之后给出； 表列的名字和定义，用逗号分隔； 有的DBMS 还要求指定表的位置。 每个表列要么是 NULL 列，要么是 NOT NULL 列，这种状态在创建时由表的定义规定。NULL 为默认设置 SQL 允许指定默认值，在插入行时如果不给出值，DBMS 将自动采用默认值。 默认值在 CREATE TABLE 语句的列定义中用关键字 DEFAULT 指定。 默认值经常用于日期或时间戳列。 通过指定引用系统日期的函数或变量， 将系统日期用作默认日期 12345678CREATE TABLE Products( prod_id CHAR(10) NOT NULL, vend_id CHAR(10) NOT NULL, prod_name CHAR(254) NOT NULL, prod_price DECIMAL(8,2) NOT NULL DEFAULT 1, prod_desc VARCHAR(1000) NULL); 更新、删除表 更新表定义，可以使用 ALTER TABLE 语句。 理想情况下，不要在表中包含数据时对其进行更新。应该在表的设计过程中充分考虑未来可能的需求，避免今后对表的结构做大改动。 所有的DBMS 都允许给现有的表增加列，不过对所增加列的数据类型（以及 NULL 和 DEFAULT 的使用）有所限制。 许多DBMS 不允许删除或更改表中的列。 多数DBMS 允许重新命名表中的列。 许多DBMS 限制对已经填有数据的列进行更改，对未填有数据的列几乎没有限制。 使用 ALTER TABLE 更改表结构，必须给出下面的信息： 在 ALTER TABLE 之后给出要更改的表名（该表必须存在，否则将 出错）； 列出要做哪些更改。 复杂的表结构更改一般需要手动删除过程，它涉及以下步骤： 1. 用新的列布局创建一个新表； 2. 使用 INSERT SELECT 语句（关于这条语句的详细介绍，请参阅第 15 课）从旧表复制数据到新表。有必要的话，可以使用转换函数和计算字段； 3. 检验包含所需数据的新表； 4. 重命名旧表（如果确定，可以删除它）； 5. 用旧表原来的名字重命名新表； 6. 根据需要，重新创建触发器、存储过程、索引和外键。 删除表：使用 DROP TABLE 语句 重命名表： DB2、MariaDB、MySQL、Oracle 和 PostgreSQL 用户使用 RENAME 语句 SQL Server 用户使用 sp_rename 存储过程 SQLite 用户使用 ALTER TABLE 语句 12345678910-- 给 Vendors 表增加一个名为 vend_phone 的列ALTER TABLE VendorsADD vend_phone CHAR(20);-- 删除列ALTER TABLE VendorsDROP COLUMN vend_phone;-- 删除表DROP TABLE CustCopy; 使用视图 - CREATE VIEW 视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。 视图的一些常见应用： 重用 SQL 语句，简化复杂的 SQL 操作 使用表的一部分而不是整个表 保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据 视图创建和使用的一些最常见的规则和限制 与表一样，视图必须唯一命名 创建视图，必须具有足够的访问权限 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。所允许的嵌套层数在不同的 DBMS 中有所不同 许多 DBMS 禁止在视图查询中使用 ORDER BY 子句 有些 DBMS 要求对返回的所有列进行命名，如果列是计算字段，则需要使用别名 视图不能索引，也不能有关联的触发器或默认值 有些 DBMS 把视图作为只读的查询，这表示可以从视图检索数据，但不能将数据写回底层表 有些 DBMS 允许创建这样的视图，它不能进行导致行不再属于视图的插入或更新 创建视图：CREATE VIEW 语句 删除视图：可以使用 DROP 语句，其语法为 DROP VIEW viewname 12345678910111213141516171819202122232425262728293031323334353637383940-- 检索订购了某种产品的顾客SELECT cust_name, cust_contactFROM Customers, Orders, OrderItemsWHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num AND prod_id = 'RGAN01'; -- 创建视图CREATE VIEW ProductCustomers ASSELECT cust_name, cust_contact, prod_idFROM Customers, Orders, OrderItemsWHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num;-- 包装成一个名为 ProductCustomers 的虚拟表-- ProductCustomers 是一个视图SELECT cust_name, cust_contactFROM ProductCustomersWHERE prod_id = 'RGAN01';-- 重新格式化检索出的数据CREATE VIEW VendorLocations ASSELECT RTRIM(vend_name) + ' (' + RTRIM(vend_country) + ')'AS vend_titleFROM Vendors;-- 用视图过滤不想要的数据CREATE VIEW CustomerEMailList ASSELECT cust_id, cust_name, cust_emailFROM CustomersWHERE cust_email IS NOT NULL;-- 使用视图与计算字段CREATE VIEW OrderItemsExpanded ASSELECT order_num, prod_id, quantity, item_price, quantity*item_price AS expanded_priceFROM OrderItems; 使用存储过程 - EXECUTE 存储过程就是为以后使用而保存的一条或多条 SQL 语句。可将其视为批文件，虽然它们的作用不仅限于批处理 为什么要使用存储过程：简单、安全、高性能 通过把处理封装在一个易用的单元中，可以简化复杂的操作 由于不要求反复建立一系列处理步骤，因而保证了数据的一致性 简化对变动的管理 因为存储过程通常以编译过的形式存储，所以 DBMS 处理命令所需的工作量少，提高了性能 存在一些只能用在单个请求中的 SQL 元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码 执行存储过程：EXECUTE 创建存储过程：CREATE 1234567891011121314151617181920212223EXECUTE AddNewProduct( 'JTS01', 'Stuffed Eiffel Tower', 6.49, 'Plush stuffed toy' );-- 对邮件发送清单中具有邮件地址的顾客进行计数-- Oracle 版本CREATE PROCEDURE MailingListCount ( ListCount OUT INTEGER)ISv_rows INTEGER;BEGIN SELECT COUNT(*) INTO v_rows FROM Customers WHERE NOT cust_email IS NULL; ListCount := v_rows;END;-- 调用 Oracle 例子var ReturnValue NUMBEREXEC MailingListCount(:ReturnValue);SELECT ReturnValue; 管理事务处理 - COMMIT/ROLLBACK 使用事务处理（transaction processing），通过确保成批的SQL 操作要么完全执行，要么完全不执行，来维护数据库的完整性 可以保证一组操作不会中途停止，它们要么完全执行，要么完全不执行（除非明确指示） 如果没有错误发生，整组语句提交给（写到）数据库表；如果发生错误，则进行回退（撤销），将数据库恢复到某个已知且安全的状态 关于事务处理需要知道的几个术语： 事务（transaction）指一组SQL 语句 回退（rollback）指撤销指定SQL 语句的过程 提交（commit）指将未存储的SQL 语句结果写入数据库表 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），可以对它发布回退（与回退整个事务处理不同）。 事务处理用来管理 INSERT、UPDATE 和 DELETE 语句 管理事务的关键在于将SQL 语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退。 有的DBMS 要求明确标识事务处理块的开始和结束： SQL Server：BEGIN TRANSACTION COMMIT TRANSACTION 多数实现没有明确标识事 务处理在何处结束。事务一直存在，直到被中断 MariaDB 和 MySQL：START TRANSACTION Oracle：SET TRANSACTION PostgreSQL：BEGIN 通常，COMMIT 用于 保存更改，ROLLBACK 用于撤销 要支持回退部分事务，必须在事务处理块中的合适位置放置占位符。在 SQL 中，这些占位符称为保留点 MariaDB、MySQL 和 Oracle：SAVEPOINT 123456789101112131415161718192021222324252627-- 执行 DELETE 操作，然后用 ROLLBACK 语句撤销DELETE FROM Orders;ROLLBACK;-- 使用 COMMIT 语句进行明确的提交-- SQL ServerBEGIN TRANSACTIONDELETE OrderItems WHERE order_num = 12345DELETE Orders WHERE order_num = 12345COMMIT TRANSACTION-- OracleSET TRANSACTIONDELETE OrderItems WHERE order_num = 12345;DELETE Orders WHERE order_num = 12345;COMMIT;-- 创建保留点-- MariaDB、MySQL 和 OracleSAVEPOINT delete1;-- SQL ServerSAVE TRANSACTION delete1;-- 回退到本例给出的保留点-- MariaDB、MySQL 和 OracleROLLBACK TO delete1;-- SQL ServerROLLBACK TRANSACTION delete1; 使用游标 - CURSOR 结果集（result set）：SQL 查询所检索出的结果 游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条SELECT 语句，而是被该语句检索出来的结果集，应用程序可以根据需要滚动或浏览其中的数据 常见的一些选项和特性： 能够标记游标为只读，使数据能读取，但不能更新和删除 能控制可以执行的定向操作（向前、向后、第一、最后、绝对位置、相对位置等） 能标记某些列为可编辑的，某些列为不可编辑的 规定范围，使游标对创建它的特定请求（如存储过程）或对所有请求可访问 指示DBMS 对检索出的数据（而不是指出表中活动数据）进行复制，使数据在游标打开和访问期间不变化 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改 创建游标：使用 DECLARE 语句创建游标，并定义相应的 SELECT 语句，但不进行查询 使用游标：使用 OPEN CURSOR 语句打开游标，并执行查询 访问游标：使用 FETCH 语句访问游标数据，指出要检索哪些行，从何处检索它们以及将它们放于何处、 关闭游标：使用 CLOSE 语句关闭游标 1234567891011121314151617181920212223242526272829303132-- 创建游标, 找出空缺的电子邮件地址-- DB2、MariaDB、MySQL 和 SQL ServerDECLARE CustCursor CURSORFORSELECT * FROM CustomersWHERE cust_email IS NULL-- Oracle 和PostgreSQLDECLARE CURSOR CustCursorISSELECT * FROM CustomersWHERE cust_email IS NULL-- 打开游标, 此时开始执行查询OPEN CURSOR CustCursor-- 访问游标，检索第一行-- OracleDECLARE TYPE CustCursor IS REF CURSOR RETURN Customers%ROWTYPE;DECLARE CustRecord Customers%ROWTYPEBEGIN OPEN CustCursor; FETCH CustCursor INTO CustRecord; CLOSE CustCursor;END;-- 关闭游标-- DB2、Oracle 和 PostgreSQLCLOSE CustCursor-- Microsoft SQL ServerCLOSE CustCursorDEALLOCATE CURSOR CustCursor 高级SQL 特性 约束 管理如何插入或处理数据库数据的规则 主键：一种特殊的约束，用来保证一列（或一组列）中的值是唯一的，而且永不改动 主键值唯一且不为 NULL，从不修改和更新，不能重用 定义主键的方法：PRIMARY KEY 外键：是表中的一列，其值必须列在另一表的主键中 定义外键的方法：REFERENCES 在定义外键后，DBMS 不允许删除在另一个表中具有关联行的行 级联删除：从一个表中删除行时删除所有相关的数据 唯一约束：用来保证一列（或一组列）中的数据是唯一的 类似于主键，但存在以下重要区别： 表可包含多个唯一约束，但每个表只允许一个主键 唯一约束列可包含 NULL 值 唯一约束列可修改或更新 唯一约束列的值可重复使用 与主键不一样，唯一约束不能用来定义外键 使用 UNIQUE 关键字定义，也可以用单独的 CONSTRAINT 定义 检查约束：保证一列（或一组列）中的数据满足一组指定的条件 检查最小或最大值、指定范围、只允许特定的值 使用 CHECK 关键词定义 12345678910111213141516171819202122232425262728293031323334353637-- 给表的 vend_id 列定义添加关键字 PRIMARY KEY，使其成为主键CREATE TABLE Vendors( vend_id CHAR(10) NOT NULL PRIMARY KEY, vend_name CHAR(50) NOT NULL, vend_address CHAR(50) NULL, vend_country CHAR(50) NULL);-- 使用的是 CONSTRAINT 语法ALTER TABLE VendorsADD CONSTRAINT PRIMARY KEY (vend_id);-- cust_id 中的任何值都必须是 Customers 表的 cust_id 中的值CREATE TABLE Orders( order_num INTEGER NOT NULL PRIMARY KEY, order_date DATETIME NOT NULL, cust_id CHAR(10) NOT NULL REFERENCES ➥Customers(cust_id));-- 在 ALTER TABLE 语句中用 CONSTRAINT 语法来完成ALTER TABLE OrdersADD CONSTRAINTFOREIGN KEY (cust_id) REFERENCES Customers (cust_id)-- 检查约束CREATE TABLE OrderItems( order_num INTEGER NOT NULL, order_item INTEGER NOT NULL, prod_id CHAR(10) NOT NULL, quantity INTEGER NOT NULL CHECK (quantity &gt; 0), item_price MONEY NOT NULL);-- 使用 CONSTRAINT 语法ALTER TABLE CustomersADD CONSTRAINT CHECK (gender LIKE '[MF]') 索引 索引用来排序数据以加快搜索和排序操作的速度 主键数据总是排序的，按主键检索特定行总是一种快速有效的操作 搜索其他列中的值通常效率不高，解决方法是使用索引 可以在一个或多个列上定义索引，使 DBMS 保存其内容的一个排过序的列表 索引改善检索操作的性能，但降低了数据插入、修改和删除的性能 索引用 CREATE INDEX 语句创建，必须唯一命名 可能要占用大量的存储空间，并非所有数据都适合做索引 12CREATE INDEX prod_name_indON Products (prod_name); 触发器 触发器（TRIGGER）是特殊的存储过程，它在特定的数据库活动发生时自动执行 触发器可以与特定表上的 INSERT、UPDATE 和 DELETE 操作相关联 触发器内的代码具有以下数据的访问权： INSERT 操作中的所有新数据 UPDATE 操作中的所有新数据和旧数据 DELETE 操作中删除的数据 触发器的一些常见用途 保证数据一致 基于某个表的变动在其他表上执行活动 进行额外的验证并根据需要回退数据 计算计算列的值或更新时间戳 约束的处理比触发器快，因此在可能的时候，应该尽量使用约束 123456789-- 对所有 INSERT 和 UPDATE 操作-- 将 Customers 表中的 cust_state 列转换为大写。CREATE TRIGGER customer_stateON CustomersFOR INSERT, UPDATEASUPDATE CustomersSET cust_state = Upper(cust_state)WHERE Customers.cust_id = inserted.cust_id; 数据库安全 大多数 DBMS 都给管理员提供了管理机制，利用管理机制授予或限制对数据的访问 安全性使用 SQL 的 GRANT 和 REVOKE 语句来管理 SQL 必知必会 - 全书目录 第 01 - 10 章：SQL 必知必会 - 单表查询/过滤/汇总 第 11 - 24 章：SQL 必知必会 - 多表查询/联结/组合 第 15 - 24 章：SQL 必知必会 - 数据更新/存储/事务","link":"/p/3b57f622/"},{"title":"安装 Docker","text":"Docker 的安装与镜像加速 安装 Docker Ubuntu 安装 Docker CE 警告：切勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装 Docker. 准备工作 系统要求 Docker CE 支持以下版本的 Ubuntu 操作系统： Bionic 18.04 (LTS) Xenial 16.04 (LTS) 卸载旧版本 旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本： 123$ sudo apt-get remove docker \\ docker-engine \\ docker.io 使用 APT 安装 由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。 12$ sudo apt-get update$ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common 鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。 1234$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# 官方源# $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 然后，我们需要向 source.list 中添加 Docker 软件源 12345678910$ sudo add-apt-repository \\ &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot;# 官方源# $ sudo add-apt-repository \\# &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\# $(lsb_release -cs) \\# stable&quot; 安装 Docker CE 更新 apt 软件包缓存，并安装 docker-ce： 123$ sudo apt-get update$ sudo apt-get install docker-ce 使用脚本自动安装 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装： 12$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh --mirror Aliyun 执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。 启动 Docker CE 12$ sudo systemctl enable docker$ sudo systemctl start docker 建立 docker 用户组 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 建立 docker 组： 1$ sudo groupadd docker 将当前用户加入 docker 组： 1$ sudo usermod -aG docker $USER 退出当前终端并重新登录，进行如下测试。 测试 Docker 是否安装正确 1234567891011$ docker run hello-worldUnable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-worldd1725b59e92d: Pull completeDigest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly....... 若能正常输出以上信息，则说明安装成功。 Windows 10 PC 安装 Docker CE 系统要求 Docker for Windows 支持 64 位版本的 Windows 10 Pro，且必须开启 Hyper-V。 安装 点击以下链接下载 Stable 或 Edge 版本的 Docker for Windows。 下载好之后双击 Docker for Windows Installer.exe 开始安装。 运行 在 Windows 搜索栏输入 Docker 点击 Docker for Windows 开始运行。 Docker CE 启动之后会在 Windows 任务栏出现鲸鱼图标。 镜像加速器 国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。国内很多云服务商都提供了国内加速器服务，例如： Azure 中国镜像 https://dockerhub.azk8s.cn 阿里云加速器(需登录账号获取) 七牛云加速器 https://reg-mirror.qiniu.com 由于镜像服务可能出现宕机，建议同时配置多个镜像。 国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务，具体请参考官方文档。 我们以 Azure 中国镜像 https://dockerhub.azk8s.cn 为例进行介绍。 Ubuntu 16.04+、Debian 8+、CentOS 7 对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件） 123456{ &quot;registry-mirrors&quot;: [ &quot;https://dockerhub.azk8s.cn&quot;, &quot;https://reg-mirror.qiniu.com&quot; ]} 注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。 之后重新启动服务。 12$ sudo systemctl daemon-reload$ sudo systemctl restart docker Windows 10 对于使用 Windows 10 的系统，在系统右下角托盘 Docker 图标内右键菜单选择 Settings，打开配置窗口后左侧导航菜单选择 Daemon。在 Registry mirrors一栏中填写加速器地址 https://dockerhub.azk8s.cn，之后点击 Apply 保存后 Docker 就会重启并应用配置的镜像地址了。 macOS 对于使用 macOS 的用户，在任务栏点击 Docker Desktop 应用图标 -&gt; Perferences… -&gt; Daemon -&gt; Registry mirrors。在列表中填写加速器地址 https://dockerhub.azk8s.cn。修改完成之后，点击 Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。 检查加速器是否生效 执行 $ docker info，如果从结果中看到了如下内容，说明配置成功。 12Registry Mirrors: https://dockerhub.azk8s.cn/ gcr.io 镜像 国内无法直接获取 gcr.io/* 镜像，我们可以将 gcr.io/&lt;repo-name&gt;/&lt;image-name&gt;:&lt;version&gt; 替换为 gcr.azk8s.cn/&lt;repo-name&gt;/&lt;image-name&gt;:&lt;version&gt; ,例如 123# docker pull gcr.io/google_containers/hyperkube-amd64:v1.9.2docker pull gcr.azk8s.cn/google_containers/hyperkube-amd64:v1.9.2 参考文档 Docker — 从入门到实践 Docker 官方 Ubuntu 安装文档","link":"/p/48e87c72/"},{"title":"Rust 中的错误处理","text":"原文地址：https://blog.burntsushi.net/rust-error-handling/ 原文标题：Error Handling in Rust 原文作者：Andrew Gallant’s Blog 翻译日期：2020/08/03 Rust 中的错误处理 与大多数编程语言一样，Rust 鼓励程序员以特定方式处理错误。一般而言，错误处理分为两大类：异常和返回值。Rust选择使用返回值进行错误处理。 在本文中，我尝试对 Rust 中如何进行错误处理提供全面的说明。并且，我将尝试一次引入一个错误处理的方法，并帮助你获得扎实的实践知识，即如何整合所有内容。 如果没有良好的实现方式，Rust 中的错误处理可能会很冗长并繁琐。本文将探讨这些问题，并展示如何使用标准库使错误处理变得简明，并符合工程习惯。 目标受众：尚不明确 Rust 错误处理用法的新手。熟悉 Rust 语法会更好。（本文使用了许多标准库 trait，但很少使用闭包和宏。） 更新（2018/04/14）：示例已转换为使用 ? 进行处理，并添加了一些文本以提供更改的背景。 更新（2020/01/03）：删除了 failure 的使用建议， 并替换为建议使用 Box&lt;Error + Send + Sync&gt; 或 anyhow。 简要说明 文中的代码示例均通过 Rust 1.0.0-beta.5 进行编译。随着 Rust 1.0 稳定版的发布，他们应该同样可以运行。 所有的代码都可以在作者的博客仓库中找到并编译。 Rust Book 中有一节 section on error handling。它提供了非常简短的概述，但是（还）没有介绍得足够详细，尤其是在使用标准库的一些最新内容时。 译者注：最新版的 Rust Book 已经更新了许多内容，建议阅读新版的错误处理章节。 简体中文版地址, 错误处理章节。 运行代码 读者如果想要运行本文中的代码示例，可以使用下面的方法： 123$ git clone git://github.com/BurntSushi/blog$ cd blog/code/rust-error-handling$ cargo run --bin NAME-OF-CODE-SAMPLE [ args ... ] 每个代码示例有其名称。（没有命名的代码不能按照这种方式运行。） 说明 本文很长，主要是因为我从一开始就使用多种错误类型及其组合，并尝试使用 Rust 逐步进行错误处理。因此，在其他显式类型系统中有经验的程序员可能想快速跳转本文。这是一些简短指南： 如果你不熟悉 Rust，系统编程和显式类型系统，那么请从头开始并逐步进行。（如果你是全新用户，则可能应该先通读 Rust Book。） 如果你以前从未看过 Rust，但是有过使用函数式语言的经验（对“代数数据类型”和“组合器”感到熟悉），那么你可以跳过基础知识，而先略读多种错误类型，然后仔细阅读 标准库错误特征。（如果你以前从未真正看过Rust，略读基础知识可能是一个不错的主意。）你可能需要查询 Rust Book，以获取有关 Rust 闭包和宏的帮助。 如果你已经对 Rust 有所了解，并且只想学习如何对错误进行处理，那么你可以直接跳到最后。略读模式匹配可能会比较有用。 基础知识 我喜欢将错误处理变为使用模式匹配来判断一个计算任务是否成功。正如我们将要看到的，工程上错误处理的关键是保持代码可组合性的同时，减少显式模式匹配的数目。 保持代码的可组合性很重要，因为如果没有此要求，我们可以在遇到意外情况时直接进行 panic 操作。（panic 导致当前任务结束，并且在大多数情况下，整个程序都将中止。）这是一个示例： panic-simple123456789101112// Guess a number between 1 and 10.// If it matches the number I had in mind, return true. Else, return false.fn guess(n: i32) -&gt; bool { if n &lt; 1 || n &gt; 10 { panic!(&quot;Invalid number: {}&quot;, n); } n == 5}fn main() { guess(11);} 如果你想要运行此代码，查看 运行代码 一章。 如果你尝试运行此代码，程序将会中止，并报告错误信息： 1thread '&lt;main&gt;' panicked at 'Invalid number: 11', src/bin/panic-simple.rs:5 这是另外一个例子。程序接收一个整数作为参数，将其乘 2 并打印出来。 unwrap-double1234567891011use std::env;fn main() { let mut argv = env::args(); let arg: String = argv.nth(1).unwrap(); // error 1 let n: i32 = arg.parse().unwrap(); // error 2 println!(&quot;{}&quot;, 2 * n);}// $ cargo run --bin unwrap-double 5// 10 如果你没有给程序传递参数 (error 1) 或者第一个参数不是整数 (error 2)，程序会像第一个例子一样中止。 我认为这种错误处理方式就像是在中国商店中奔跑的公牛。公牛会到达它想去的地方，但是会践踏过程中的一切。 Unwrapping 说明 在上面的例子里 (unwrap-double)，我声称：如果程序满足两个错误条件之一，该程序将中止。但是，程序中并未像第一个示例（panic-simple）那样包含显式调用 panic 。这是因为 panic 嵌入在对 unwrap 的调用中。 要 “unwrap” Rust 中的某些内容，也就意味着：“给我计算的结果，并且如果有错误，请立即调用 panic 并中止程序。” 如果我直接展示用于 unwrapping 的代码可能会帮助你理解这一点，因为它十分简单。但是要做到这一点，我们首先需要探讨 Option 和 Result 类型。这两种类型在其上都有一个称为 unwrap 的方法。 Option 类型 Option 类型定义在 标准库 中： option-def1234enum Option&lt;T&gt; { None, Some(T),} Option 类型在 Rust 中主要适用于表示不存在的可能性。将不存在的可能性编码到类型系统中是一个很重要的概念，因为它可以通过编译器去强制程序员处理这样的不存在的情况。让我们看一个例子，它在字符串中尝试查找一个字符： option-ex-string-find12345678910// Searches `haystack` for the Unicode character `needle`. If one is found, the// byte offset of the character is returned. Otherwise, `None` is returned.fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; { for (offset, c) in haystack.char_indices() { if c == needle { return Some(offset); } } None} （Pro-tip：请勿使用此代码。请使用标准库中的 find 方法。） 注意到当函数找到一个匹配的字符时，它并不直接返回 offset，而是返回 Some(offset)。Some 是 Option 中的一个变体，或者说是一个值构造（value constructor）函数。你可以将其认为是一个函数：fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;。相应的， None 也是一个值构造（value constructor）函数,只不过它没有参数。你可以将 None 认为是一个函数： fn&lt;T&gt;() -&gt; Option&lt;T&gt;。 这看起来很简单，但这只是程序的一半，另一半是使用我们编写的函数 find。让我们尝试使用它在文件名中查找扩展名： option-ex-string-find1234567fn main_find() { let file_name = &quot;foobar.rs&quot;; match find(file_name, '.') { None =&gt; println!(&quot;No file extension found.&quot;), Some(i) =&gt; println!(&quot;File extension: {}&quot;, &amp;file_name[i+1..]), }} 此代码对 find 返回的 Option&lt;usize&gt; 进行模式匹配，实际上，模式匹配是获取存储在Option&lt;T&gt;中的值的唯一方法。这意味着作为程序员的你，必须处理当 Option&lt;T&gt; 是 None 的情况，而不仅仅是 Some(t)。 但是等等，那么在 unwrap-double 中使用的 unwrap 是什么情况呢？那里没有模式匹配！这是因为它将模式匹配嵌入到 unwrap 方法中。你可以根据需要自己定义 unwrap 方法： option-def-unwrap1234567891011121314enum Option&lt;T&gt; { None, Some(T),}impl&lt;T&gt; Option&lt;T&gt; { fn unwrap(self) -&gt; T { match self { Option::Some(val) =&gt; val, Option::None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;), } }} 在 unwrap 方法中抽象出模式匹配，正是工程中使用 unwrap 的方式。然而，unwrap 中的 panic! 仍然意味着这个 unwrap 是不可组合的：这是中国商店里的公牛。 组合 Option&lt;T&gt; 在 option-ex-string-find 其中，我们看到如何使用find来查找文件名中的扩展名。但是，并非所有文件名都带有 .，因此文件名可能没有扩展名。我们将这种不存在的可能性编码为类型 Option&lt;T&gt;。换句话说，编译器将迫使我们处理扩展不存在的可能性。就我们而言，我们只是打印出一条错误消息。 获取文件扩展名是很常见的操作，因此可以将其放入函数中： option-ex-string-find123456789// Returns the extension of the given file name, where the extension is defined// as all characters succeeding the first `.`.// If `file_name` has no `.`, then `None` is returned.fn extension_explicit(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { match find(file_name, '.') { None =&gt; None, Some(i) =&gt; Some(&amp;file_name[i+1..]), }} （Pro-tip：请勿使用此代码。请使用标准库中的 extension 方法。） 上面的代码仍然很简单，但需要注意的一点是，find 强制我们考虑不存在的可能性。这种情况的好处在于：编译器不会让我们意外忘记文件名没有扩展名的情况。另一方面，像 extension_explicit 函数所实现的那样，进行显式的模式匹配可能会有点繁琐。 实际上，extension_explicit 中的模式匹配遵循一种非常常见的模式：将函数映射到 Option&lt;T&gt; 内部的值，如果该 Option 为 None，只需返回 None 即可。 Rust 具有参数多态性，因此定义抽象该模式的组合器非常容易： option-map123456fn map&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt; where F: FnOnce(T) -&gt; A { match option { None =&gt; None, Some(value) =&gt; Some(f(value)), }} 事实上，map 在标准库中被定义为 Option&lt;T&gt; 上的一种方法。 有了新的组合器，我们可以重写 extension_explicit 方法以去除模式匹配： option-ex-string-find123456// Returns the extension of the given file name, where the extension is defined// as all characters succeeding the first `.`.// If `file_name` has no `.`, then `None` is returned.fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { find(file_name, '.').map(|i| &amp;file_name[i+1..])} 另一种很常见的模式是，当 Option 值为 None 时，为其分配一个默认值。例如，你的程序假定：即使文件扩展名不存在，文件的扩展名也是 rs。同样的，对此情况的模式匹配并不特定于文件扩展名。使用 Option&lt;T&gt; 也可以实现它： option-unwrap-or123456fn unwrap_or&lt;T&gt;(option: Option&lt;T&gt;, default: T) -&gt; T { match option { None =&gt; default, Some(value) =&gt; value, }} 这里的要求是，默认值必须与 Option&lt;T&gt; 内的值具有相同的类型。在我们的例子里，使用它非常简单： option-ex-string-find1234fn main() { assert_eq!(extension(&quot;foobar.csv&quot;).unwrap_or(&quot;rs&quot;), &quot;csv&quot;); assert_eq!(extension(&quot;foobar&quot;).unwrap_or(&quot;rs&quot;), &quot;rs&quot;);} （请注意，unwrap_or 在标准库中是定义在 Option&lt;T&gt; 上的一种方法，所以我们在这里用的并不是我们在上面自己定义的函数。记得查找更通用的 unwrap_or_else 方法。） 我认为还有一种组合器值得特别注意：and_then。它使组合不同的计算变得更容易，这些计算都会处理不存在的可能性。例如，本节中的许多代码都是关于查找给定文件名的扩展名。为此，你首先需要从文件路径中提取出文件名。尽管大多数文件路径都具有文件名，但并非所有都具有，例如.，..或 /。 因此，我们面临的挑战是查找给定文件路径下所有文件的扩展名 。让我们从显式模式匹配开始： option-ex-string-find1234567891011121314fn file_path_ext_explicit(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; { match file_name(file_path) { None =&gt; None, Some(name) =&gt; match extension(name) { None =&gt; None, Some(ext) =&gt; Some(ext), } }}fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; { // implementation elided unimplemented!()} 你可能会认为我们可以只使用 map 组合器来减少模式匹配，但是它的类型不太合适。即，map 采用仅对内部值执行某些操作的函数。然后，总是用 Some 来包装该函数的结果。但是，我们需要类似于 map，但允许调用者返回其他的 Option。它的通用实现甚至比 map 更简单： option-and-then1234567fn and_then&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt; where F: FnOnce(T) -&gt; Option&lt;A&gt; { match option { None =&gt; None, Some(value) =&gt; f(value), }} 现在我们可以重写 file_path_ext 函数，而无需进行显式的模式匹配： option-ex-string-find123fn file_path_ext(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; { file_name(file_path).and_then(extension)} Option 类型在标准库中定义了许多其他组合器。建议浏览此文档并熟悉其可用的内容，它们通常可以为你减少模式匹配。熟悉这些组合器会很有帮助，并且它们中大多也为 Result 定义了相似的语义，我们将在下面讨论。 组合使用 Option 类型是个比较符合工程学的实现，因为它们减少了显式的模式匹配。它们仍然是可组合的，因为它们允许调用者以自己的方式处理不存在的可能性。类似于 unwrap 的方法移除了这种可能性，因为他们在 Option&lt;T&gt; 是 None 会中止程序运行。 Result 类型 Result 类型也定义在标准库中： result-def1234enum Result&lt;T, E&gt; { Ok(T), Err(E),} Result 类型是更丰富版的 Option。也就是说，不同于像 Option 那样表示不存在的可能性，Result表示的是出现错误的可能性。通常，错误用于解释为什么某些计算结果会失败。这是更严格的 Option 的通用形式。请考虑以下类型别名，该别名在各个方面的语义上均等同于实际的 Option&lt;T&gt; ： option-as-result1type Option&lt;T&gt; = Result&lt;T, ()&gt;; 这将 Result 的第二个参数类型始终固定为 ()（发音为 “unit” 或 “empty tuple”）。并且也只定义在 () 类型中。（() 类型和值这两个级别的术语具有相同的符号！） Result 类型是表示计算中两个可能结果之一的方式。按照惯例，一个结果是预期正确的结果即“Ok”，而另一个结果是不预期的错误即“Err”。 就像 Option 一样，Result 类型也具有在标准库中定义的 unwrap 方法。让我们自己定义一下： result-def123456789impl&lt;T, E: ::std::fmt::Debug&gt; Result&lt;T, E&gt; { fn unwrap(self) -&gt; T { match self { Result::Ok(val) =&gt; val, Result::Err(err) =&gt; panic!(&quot;called `Result::unwrap()` on an `Err` value: {:?}&quot;, err), } }} 这实际上与我们对 Option::unwrap 的定义相类似，只不过它在 panic! 消息中返回错误值。这使调试程序更加容易，但还需要我们在 E 类型参数（代表我们的错误类型）上添加 Debug 约束。由于绝大多数类型都应满足 Debug 约束条件，因此这在实践中很容易解决。（类型上的 Debug 只是意味着有一种合理的方式来以人类可读的形式打印该类型的值。） 好的，让我们继续下一个例子。 解析整数 Rust 标准库使将字符串转换为整数十分容易。实际上也是如此，编写如下内容非常简单： result-num-unwrap12345678fn double_number(number_str: &amp;str) -&gt; i32 { 2 * number_str.parse::&lt;i32&gt;().unwrap()}fn main() { let n: i32 = double_number(&quot;10&quot;); assert_eq!(n, 20);} 在此时，你应该对调用 unwrap 表示警惕。例如，如果字符串未解析为数字，则会出现 panic： 1thread '&lt;main&gt;' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729 这是相当不直观的，如果这种情况发生在你正在使用的库函数中，你可能会感到很烦恼。因此，我们应该尝试处理函数中的错误，并让调用者决定如何处理。这意味着更改 double_number 的返回类型。但是要怎么做呢？让我们查看标准库中 parse 方法的定义 ： 123impl str { fn parse&lt;F: FromStr&gt;(&amp;self) -&gt; Result&lt;F, F::Err&gt;;} 嗯… 所以我们至少知道需要使用 Result。当然，返回 Option 也是可取的。毕竟，字符串要么解析为数字，要么不是数字。虽然这是一种合理的方法，但是使用 Result 可以从内部区分为什么字符串没有解析为整数。（无论它是一个空字符串，一个无效数字，数字太大还是太小。）因此，使用 Result 更有意义，因为我们希望提供的信息不仅仅是简单的“不存在”，我们想说明为什么解析会失败。当遇到 Option 和 Result 之间的选择时，你应该尝试效仿这样的推理。如果你可以提供详细的错误信息，那么你就应该这样做。（我们将在稍后看到更多信息。） 好的，但是我们如何编写返回类型？上面定义的 parse 方法在标准库中所有不同的数字类型上都是通用的。我们可以（并且应该）使函数也如此通用，不过现在让我们首先仅支持显式定义类型。我们只关心 i32，因此我们需要找到它的 FromStr 实现并查看其关联类型 Err。这么做是为了找到具体的错误类型，在此情况下为 std::num::ParseIntError。然后，我们可以重写函数： result-num-no-unwrap123456789101112131415use std::num::ParseIntError;fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; { match number_str.parse::&lt;i32&gt;() { Ok(n) =&gt; Ok(2 * n), Err(err) =&gt; Err(err), }}fn main() { match double_number(&quot;10&quot;) { Ok(n) =&gt; assert_eq!(n, 20), Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err), }} 这看起来好了一些，但是现在代码行数更多了！模式匹配再次使我们感到繁琐。 因此可以使用组合器来帮助我们！就像 Option 一样，Result 有很多定义为方法的组合器。Result 和 Option 在公共的组合器上有很大的交集。特别的，map 便是该交集的一部分： result-num-no-unwrap-map123456789101112use std::num::ParseIntError;fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; { number_str.parse::&lt;i32&gt;().map(|n| 2 * n)}fn main() { match double_number(&quot;10&quot;) { Ok(n) =&gt; assert_eq!(n, 20), Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err), }} 通常使用的组合器在 Result 中都有，包括 unwrap_or 和 and_then。此外，由于 Result 具有第二种类型的参数，因此有一些组合器仅使用错误类型，例如 map_err（类似于 map）和 or_else （类似于 and_then）。 Result 类型别名 在标准库中，你可能经常看到类似 Result&lt;i32&gt; 的类型。但是，在 Result 中定义了两个类型参数，我们如何只指定一个就可以使用呢？答案是定义一个 Result 类型别名，在其中固定类型参数中的一个特定类型。通常，固定类型是错误类型。例如，我们前面的解析整数的示例可以这样重写： result-num-no-unwrap-map-alias12345678use std::num::ParseIntError;use std::result;type Result&lt;T&gt; = result::Result&lt;T, ParseIntError&gt;;fn double_number(number_str: &amp;str) -&gt; Result&lt;i32&gt; { unimplemented!();} 为什么要这样做？因为如果我们有很多需要返回 ParseIntError 的函数，那么定义一个始终使用 ParseIntError 的别名要方便得多，这样我们就不必一直重复它。 这个习惯用法在标准库中最常见的地方是 io::Result。通常情况下，这样编写io::Result&lt;T&gt; 就可以清楚地表明你使用的是 io 模块的类型别名，而不是使用的普通定义 std::result。（此习惯用法也用于 fmt::Result。） 小插曲：unwrapping 并非不能使用的 如果你一直在阅读本文，你可能已经注意到，我采取了相当严格的措施来禁止调用 unwrap 导致程序中止 panic 的方法。一般来说，这是一个很好的建议。 但是，unwrap 仍然是可以使用。确切地说，使用 unwrap 是一个灰色地带，部分人并不建议使用。我总结了我对此事的一些看法。 **在代码示例和简短的程序中。**有时你正在编写示例或简短的程序，而错误处理并不重要。在这种情况下使用 unwrap 非常方便。 **在程序中止时表示程序中有错误。**当程序应防止发生某种情况时（例如，从空堆栈中弹出），则可以允许中止。因为它暴露了程序中的错误，这既可能是明确的，例如 assert! 失败，也可能是因为你对数组的索引超出范围。 这可能并不是详尽的说明。此外，使用 Option 时，通常最好使用其 expect 方法。除了打印一条给你的消息外，它的用途与 unwrap 完全相同。但它使输出的程序中止问题描述变得友好一些，因为它将显示你的消息，而不是“调用 None 值的 unwrap”。 我的建议可以归结为：运用你良好的判断力。我的写作中从不出现 “从不做X” 或 “Y被视为有害” 这两个词。在所有方面都有权衡取舍，由程序员在你的用例使用可接受的部分。我的目标只是帮助你尽可能准确地评估权衡。 既然我们已经介绍了 Rust 中错误处理的基础知识，并且我已经讲过关于 unwrap 的内容，那么让我们开始探索标准库的更多内容。 使用多种错误类型 到目前为止，我们已经尝试的错误处理都是基于 Option&lt;T&gt; 或 Result&lt;T, SomeError&gt;。但是，当你同时使用 Option 和 Result 时会发生什么？又或者如果有一个 Result&lt;T, Error1&gt; 和一个 Result&lt;T, Error2&gt;？处理不同错误类型的组合是摆在我们面前的下一个挑战，它将成为本文其余部分的主题。 组合 Option 与 Result 到目前为止，我已经讨论了为 Option 定义的组合器和为 Result 定义的组合器。我们可以使用这些组合器来组合不同计算的结果，而无需进行明确的模式匹配。 但是在实际代码中，事情并不总是那么简单。有时你需要混合使用 Option 和 Result 类型。我们是否必须诉诸明确的模式匹配，还是可以继续使用组合器？ 现在，让我们重新回顾本文中的第一个示例： 1234567891011use std::env;fn main() { let mut argv = env::args(); let arg: String = argv.nth(1).unwrap(); // error 1 let n: i32 = arg.parse().unwrap(); // error 2 println!(&quot;{}&quot;, 2 * n);}// $ cargo run --bin unwrap-double 5// 10 鉴于我们刚学会的 Option，Result 以及它们的各种组合器，我们应该尝试改写这个程序，以让错误得到妥善处理：当没有错误时，程序不应该崩溃。 这里的棘手问题是 argv.nth(1) 返回一个 Option，而 arg.parse() 返回一个 Result，这些不是可以直接组合的。当同时面对 Option 和 Result 时，解决方案通常是将 Option 转换为 Result。在我们的示例中，命令行参数如果为空（来自 env::args()）表示用户未正确调用程序。我们可以使用 String 来描述这个错误。我们试试吧： error-double-string1234567891011121314use std::env;fn double_arg(mut argv: env::Args) -&gt; Result&lt;i32, String&gt; { argv.nth(1) .ok_or(&quot;Please give at least one argument&quot;.to_owned()) .and_then(|arg| arg.parse::&lt;i32&gt;().map_err(|err| err.to_string()))}fn main() { match double_arg(env::args()) { Ok(n) =&gt; println!(&quot;{}&quot;, n), Err(err) =&gt; println!(&quot;Error: {}&quot;, err), }} 在此示例中，有一些新东西。首先是 Option::ok_or 组合器的使用。这是将 Option 转换为 Result 的一种方法。转换需要你指定如果 Option 是 None，会使用什么错误。就像我们看到的其他组合器一样，其定义非常简单： option-ok-or-def123456fn ok_or&lt;T, E&gt;(option: Option&lt;T&gt;, err: E) -&gt; Result&lt;T, E&gt; { match option { Some(val) =&gt; Ok(val), None =&gt; Err(err), }} 这里使用的另一个新的组合器是 Result::map_err。类似于Result::map，但它将函数映射到Result的错误部分上。如果Result是一个Ok(...)值，则将其返回原样。 我们之所以在这里使用 map_err，是因为错误类型必须保持相同（因为我们使用 and_then）。由于我们选择将 Option&lt;String&gt;（来自于 argv.nth(1)）转换为 Result&lt;String, String&gt;，因此我们还必须将 ParseIntError（来自于 arg.parse()）转换为 String。 组合器的限制 进行 IO 和解析输入是一项非常常见的任务，这也是我个人在 Rust 中做的比较多的工作。因此，我们将使用 IO 和各种解析例程来举例说明错误处理。 让我们从一个简单的例子开始。我们的任务是打开文件，读取文件的所有内容并将其内容转换为数字。然后，将其乘以 2 并打印输出。 尽管我尝试说服你不要使用 unwrap，但是开始编写代码时 unwrap 是很有用的。它使你可以专注于问题而不是错误处理，并且可以揭示需要进行正确错误处理的地方。让我们开始编写第一版程序，然后对其进行重构，以使用更好的错误处理。 io-basic-unwrap12345678910111213141516use std::fs::File;use std::io::Read;use std::path::Path;fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; i32 { let mut file = File::open(file_path).unwrap(); // error 1 let mut contents = String::new(); file.read_to_string(&amp;mut contents).unwrap(); // error 2 let n: i32 = contents.trim().parse().unwrap(); // error 3 2 * n}fn main() { let doubled = file_double(&quot;foobar&quot;); println!(&quot;{}&quot;, doubled);} （N.B. 使用 AsRef&lt;Path&gt; 因为它们是使用在 std::fs::File::open 上的相同参数类型。这使得使用任何类型的字符串作为文件路径都符合工程学。） 这里可能会发生三种不同的错误： 打开文件时出现问题。 从文件读取数据时出现问题。 将数据解析为数字时出现问题。 前两个问题属于 std::io::Error 类型 ，这一点可以从 std::fs::File::open 和 std::io::Read::read_to_string 的返回类型中得知 。（请注意，它们都使用前面描述的 Result 类型别名。如果单击 Result 类型，你将看到类型别名，并因此看到基础的 io::Error 类型。）第三个问题属于 std::num::ParseIntError 类型。io::Error 这种类型在整个标准库中的使用非常广泛，你将经常看到它。 让我们开始重构 file_double 函数。为了使此功能可与程序的其他组件组合，如果满足上述任何错误条件，则不要 panic。实际上，这意味着该函数在任何操作失败时都应返回错误。我们的问题是 file_double 的返回类型为 i32，这无法为我们提供任何有用的报告错误的方式。因此，我们必须首先将返回类型从 i32 更改为其他类型。 我们需要决定的第一件事：我们应该使用 Option 还是 Result？使用 Option 非常简单，如果发生三个错误中的任何一个，我们可以简单地返回 None。这有一定效果，并且比 panic 更好，但是我们可以做得更好，我们应该传递一些有关发生的错误的详细信息。由于我们要表达错误的可能性，因此应使用 Result&lt;i32, E&gt;。但是 E 应该是什么呢？由于可能发生两种不同类型的错误，因此我们需要将它们转换为常见类型。一种这样的类型是 String。让我们看看这如何影响我们的代码： io-basic-error-string1234567891011121314151617181920212223242526use std::fs::File;use std::io::Read;use std::path::Path;fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; { File::open(file_path) .map_err(|err| err.to_string()) .and_then(|mut file| { let mut contents = String::new(); file.read_to_string(&amp;mut contents) .map_err(|err| err.to_string()) .map(|_| contents) }) .and_then(|contents| { contents.trim().parse::&lt;i32&gt;() .map_err(|err| err.to_string()) }) .map(|n| 2 * n)}fn main() { match file_double(&quot;foobar&quot;) { Ok(n) =&gt; println!(&quot;{}&quot;, n), Err(err) =&gt; println!(&quot;Error: {}&quot;, err), }} 这段代码看起来有些复杂。像这样的代码可能需要大量的练习才能变得容易编写，我写的方式是遵循返回类型。一旦将 file_double 返回类型更改为 Result&lt;i32, String&gt;，我就必须开始寻找合适的组合器。在这种情况下，我们只用了三种不同的组合程序：and_then，map 和 map_err。 and_then 用于链接多个计算，其中每个计算都可能返回错误。打开文件后，还有另外两个可能失败的计算：从文件读取并将内容解析为数字，相应地，有两个 and_then 调用。 map 用于将函数应用于 Result 的 Ok(...) 值。例如，最后一次调用 map 将 Ok(...) 值（i32）乘以 2。如果在此之前发生了错误，则由于 map 定义的方式，该操作将被跳过。 map_err 是使所有这些工作都有效的技巧。map_err 就像 map 一样，只是它对 Result 的 Err(...) 值应用了一个函数。在这种情况下，我们希望将所有错误都转换为一种类型：String。由于 io::Error 和 num::ParseIntError 实现 ToString，我们可以调用 to_string() 方法将其转换。 综上所述，代码仍然很繁琐。掌握组合器的用法很重要，但是它们有其局限性。让我们尝试另一种方法：提前返回。 提取返回 我想使用提前返回重写上一节的代码。提前返回可以让你尽早退出该功能。我们在 file_double 中无法从一个闭包内部提前返回，因此我们需要恢复为显式的模式匹配。 io-basic-error-string-early-return1234567891011121314151617181920212223242526use std::fs::File;use std::io::Read;use std::path::Path;fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; { let mut file = match File::open(file_path) { Ok(file) =&gt; file, Err(err) =&gt; return Err(err.to_string()), }; let mut contents = String::new(); if let Err(err) = file.read_to_string(&amp;mut contents) { return Err(err.to_string()); } let n: i32 = match contents.trim().parse() { Ok(n) =&gt; n, Err(err) =&gt; return Err(err.to_string()), }; Ok(2 * n)}fn main() { match file_double(&quot;foobar&quot;) { Ok(n) =&gt; println!(&quot;{}&quot;, n), Err(err) =&gt; println!(&quot;Error: {}&quot;, err), }} 部分人可能不认为此代码是比使用组合器的代码更好，但是，如果你不熟悉组合器方法，那么这段代码看起来将会更简单。它使用带有 match 和 if let 的显式模式匹配。如果发生错误，它只是停止执行该函数并返回错误（通过将其转换为字符串）。 这不是倒退一步吗？之前，我曾说过，工程学错误处理的关键是减少显式模式匹配，但是我们在这里已恢复为显式模式匹配。事实证明，有多种方法可以减少显式模式匹配，组合器不是唯一的方法。 try! 宏/? 操作符 在较旧的 Rust 版本（Rust 1.12 或更早版本）中，Rust 中错误处理的基石是 try! 宏。try! 宏将模式匹配抽象成组合器，但不同于组合器，它也抽象控制流。即，它可以抽象出上面看到的提前返回模式。 这是try!宏的简化定义： try-def-simple123456macro_rules! try { ($e:expr) =&gt; (match $e { Ok(val) =&gt; val, Err(err) =&gt; return Err(err), });} （ 真实的定义 要复杂得多。我们将在以后再看。） 使用 try! 宏可以很容易地简化我们的示例。由于它可以进行模式匹配并为我们实现提前返回，因此我们获得了更易于阅读的紧凑代码： io-basic-error-try123456789101112131415161718use std::fs::File;use std::io::Read;use std::path::Path;fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; { let mut file = try!(File::open(file_path).map_err(|e| e.to_string())); let mut contents = String::new(); try!(file.read_to_string(&amp;mut contents).map_err(|e| e.to_string())); let n = try!(contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string())); Ok(2 * n)}fn main() { match file_double(&quot;foobar&quot;) { Ok(n) =&gt; println!(&quot;{}&quot;, n), Err(err) =&gt; println!(&quot;Error: {}&quot;, err), }} map_err 调用仍然需要传递给我们的 try! 定义。这是因为错误类型仍需要转换为 String。好消息是，我们将很快学习如何删除这些 map_err 调用！坏消息是，在删除 map_err 调用之前，我们将需要更多地了解标准库中的几个重要特征。 在较新版本的 Rust（Rust 1.13 或更高版本）中，该 try! 宏已替换为 ? 操作符。虽然它打算增加我们在这里不会介绍的新功能，但是使用 ? 代替try! 是很简单的： io-basic-error-question123456789101112131415161718use std::fs::File;use std::io::Read;use std::path::Path;fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; { let mut file = File::open(file_path).map_err(|e| e.to_string())?; let mut contents = String::new(); file.read_to_string(&amp;mut contents).map_err(|e| e.to_string())?; let n = contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string())?; Ok(2 * n)}fn main() { match file_double(&quot;foobar&quot;) { Ok(n) =&gt; println!(&quot;{}&quot;, n), Err(err) =&gt; println!(&quot;Error: {}&quot;, err), }} 定义自己的错误类型 在深入探讨一些标准库错误 traits 之前，我想通过在前面的示例中删除对我们的错误类型 String 的使用来结束本节。 String 像在前面的示例中一样，使用起来很方便，因为很容易将错误转换为字符串，甚至可以当场将自己的错误作为字符串来实现。但是，使用 String 错误会带来一些不利影响。 第一个缺点是错误消息往往会使你的代码变得混乱。可以在其他地方定义错误消息，但是除非你受过特别的训练，否则很难将错误消息嵌入代码中。确实，我们在前面的示例中完全做到了这一点。 第二个更重要的缺点是 String 是有损的。也就是说，如果所有错误都转换为字符串，那么我们传递给调用方的错误将变得完全不透明。调用者可以对 String 错误进行的唯一合理的处理就是将其显示给用户。当然，检查字符串以确定错误的类型并不可靠。（诚然，与应用程序相比，此缺点在库内部要重要得多。） 例如，io::Error 类型嵌入 io::ErrorKind，这是表示 IO 操作期间出了什么问题的结构化数据。这很重要，因为你可能希望根据错误做出不同的反应。（例如，BrokenPipe 错误可能意味着优雅地退出程序，而 NotFound 错误可能意味着退出并显示错误代码以向用户显示错误。）使用 io::ErrorKind，调用者可以使用模式匹配检查错误的类型，这绝对优于试图弄清楚一个 String 错误的细节。 与其在前面的从文件中读取整数的示例中将 String 用作错误类型，不如定义自己的错误类型，该错误类型表示结构化数据中的错误。如果调用者想检查详细信息，我们将努力不从潜在错误中删除信息。 表示多种可能性之一的理想方法是定义自己的枚举类型 enum。在我们的例子中，错误是 io::Error 或 num::ParseIntError，因此很自然地定义为： io-basic-error-custom12345678910use std::io;use std::num;// We derive `Debug` because all types should probably derive `Debug`.// This gives us a reasonable human readable description of `CliError` values.#[derive(Debug)]enum CliError { Io(io::Error), Parse(num::ParseIntError),} 调整我们的代码非常容易。无需将错误转换为字符串，我们只需使用相应的值构造函数将它们转换为我们的类型 CliError 即可： io-basic-error-custom123456789101112131415161718use std::fs::File;use std::io::Read;use std::path::Path;fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; { let mut file = File::open(file_path).map_err(CliError::Io)?; let mut contents = String::new(); file.read_to_string(&amp;mut contents).map_err(CliError::Io)?; let n: i32 = contents.trim().parse().map_err(CliError::Parse)?; Ok(2 * n)}fn main() { match file_double(&quot;foobar&quot;) { Ok(n) =&gt; println!(&quot;{}&quot;, n), Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err), }} 唯一的更改是将 map_err(|e| e.to_string())（将错误转换为字符串）切换到 map_err(CliError::Io) 或 map_err(CliError::Parse)，调用者可以通过问题的错误等级决定是否向用户报告。实际上，将 String 用作错误类型会从调用方中删除这种选择，而使用自定义 enum 错误类型，例如 CliError，除了描述错误的结构化数据外，还可以像以前一样为调用方提供很多便利。 经验法则是尽量定义自己的错误类型，但是 String 错误类型会在一定程度上发生，特别是在编写应用程序时。如果要编写库，则强烈建议定义自己的错误类型，以免不必要地从调用方中删除选择。 用于错误处理的标准库 traits 标准库为错误处理定义了两个不可或缺的 trait： std::error::Error 和 std::convert::From。尽管 Error 专为一般性地描述错误而设计，但是 From trait 在两个不同类型之间转换值时起更一般的作用。 Error trait Error trait 在标准库中的定义如下： error-def123456789use std::fmt::{Debug, Display};trait Error: Debug + Display { /// A short description of the error. fn description(&amp;self) -&gt; &amp;str; /// The lower level cause of this error, if any. fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; { None }} 此 trait 是非常通用的，因为它打算表示错误的所有类型。我们将在后面看到这对编写可组合代码很有帮助。简单地说，该 trait 允许你执行以下操作： 获取 Debug 错误的表示形式。 获取 Display 错误的面向用户的表示形式。 获得错误的简短描述（通过 description 方法）。 检查错误的因果链（如果存在）（通过 cause 方法）。 前两个来自于 Error 要求实现 Debug 和 Display。后两者来自 Error 上定义的两种方法。Error 的力量来自所有错误类型均隐含 Error 的事实，这意味着可以将存在的错误量化为 trait 对象，这表现为 Box&lt;Error&gt; 或 &amp;Error。实际上，cause 方法返回一个 &amp;Error，它本身就是一个 trait 对象。稍后，我们将重新使用 Error trait 作为 trait 对象。 就目前而言，已经能够通过实现 Errortrait 编写示例。让我们使用上一节中定义的错误类型 ： error-impl12345678910use std::io;use std::num;// We derive `Debug` because all types should probably derive `Debug`.// This gives us a reasonable human readable description of `CliError` values.#[derive(Debug)]enum CliError { Io(io::Error), Parse(num::ParseIntError),} 这种特殊的错误类型表示可能发生两种类型的错误：处理 I/O 的错误或将字符串转换为数字的错误。通过向 enum 定义添加新的变体，该错误可以表示所需的错误类型。 为其实现 Error 非常简单，主要是要进行很多显式的模式匹配。 error-impl123456789101112131415161718192021222324252627282930313233343536373839use std::error;use std::fmt;impl fmt::Display for CliError { fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result { match *self { // Both underlying errors already impl `Display`, so we defer to // their implementations. CliError::Io(ref err) =&gt; write!(f, &quot;IO error: {}&quot;, err), CliError::Parse(ref err) =&gt; write!(f, &quot;Parse error: {}&quot;, err), } }}impl error::Error for CliError { fn description(&amp;self) -&gt; &amp;str { // Both underlying errors already impl `Error`, so we defer to their // implementations. match *self { CliError::Io(ref err) =&gt; err.description(), // Normally we can just write `err.description()`, but the error // type has a concrete method called `description`, which conflicts // with the trait method. For now, we must explicitly call // `description` through the `Error` trait. CliError::Parse(ref err) =&gt; error::Error::description(err), } } fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; { match *self { // N.B. Both of these implicitly cast `err` from their concrete // types (either `&amp;io::Error` or `&amp;num::ParseIntError`) // to a trait object `&amp;Error`. This works because both error types // implement `Error`. CliError::Io(ref err) =&gt; Some(err), CliError::Parse(ref err) =&gt; Some(err), } }} 注意这是一个非常典型的 Error 实现：匹配不同的错误类型，并实现 description 和 cause 的定义。 From trait std::convert::From trait 也是定义在标准库中: from-def123trait From&lt;T&gt; { fn from(T) -&gt; Self;} 是不是非常简单？From 之所以非常有用，是因为它为我们提供了一种通用的方式来实现从特定类型 T 到其他类型的转换（在这种情况下，“其他类型”是 impl 的主体，也即是 Self）。From 有标准库提供的一组实现。 以下是一些简单的示例，说明其 From 工作方式： from-examples123let string: String = From::from(&quot;foo&quot;);let bytes: Vec&lt;u8&gt; = From::from(&quot;foo&quot;);let cow: ::std::borrow::Cow&lt;str&gt; = From::from(&quot;foo&quot;); OK，因此 From 对于在字符串之间进行转换很有用。那么错误呢？同样有一个关键的实现： 1impl&lt;'a, E: Error + 'a&gt; From&lt;E&gt; for Box&lt;Error + 'a&gt; 这个实现表示对于任何实现了 Error 的类型，我们可以将它转换为 trait 对象 Box&lt;Error&gt;，这在一般情况下很有用。 还记得我们以前处理的两个错误吗？也就是，io::Error 和 num::ParseIntError。既然都实现了 Error，它们同样可以使用 From： from-examples-errors123456789101112use std::error::Error;use std::fs;use std::io;use std::num;// We have to jump through some hoops to actually get error values.let io_err: io::Error = io::Error::last_os_error();let parse_err: num::ParseIntError = &quot;not a number&quot;.parse::&lt;i32&gt;().unwrap_err();// OK, here are the conversions.let err1: Box&lt;Error&gt; = From::from(io_err);let err2: Box&lt;Error&gt; = From::from(parse_err); 注意这里有一个非常重要的模式。两个 err1 和 err2 具有相同的类型。这是因为它们是表示上完全相同的类型或 trait 对象。并且，编译器删除了它们的底层类型，因此在编译器看来，err1 和 err2 完全相同。此外，我们构造 err1 和 err2 使用了完全相同的函数调用：From::from。这是因为 From::from 在其参数和返回类型上都重载了。 此模式很重要，因为它解决了我们先前遇到的一个问题：提供了一种使用相同函数，将错误转换为相同类型的方法。 是时候重温一个老朋友了：try! 宏/ ? 操作符。 实际的 try! 宏/ ? 操作符 之前，我介绍了 try! 的定义： 123456macro_rules! try { ($e:expr) =&gt; (match $e { Ok(val) =&gt; val, Err(err) =&gt; return Err(err), });} 这不是真实的定义。它在标准库中的真正定义： try-def123456macro_rules! try { ($e:expr) =&gt; (match $e { Ok(val) =&gt; val, Err(err) =&gt; return Err(::std::convert::From::from(err)), });} 有一个微小而强大的更改：错误值 From::from 通过传递。这使 try! 宏的功能更加强大，因为它为你提供了自动类型转换。这也与 ? 操作符的工作方式非常相似，但后者的定义略有不同，即 x? 类似以下内容： questionmark-def1234match ::std::ops::Try::into_result(x) { Ok(v) =&gt; v, Err(e) =&gt; return ::std::ops::Try::from_error(From::from(e)),} Try trait 暂时还在修改，不在本文的讨论范围之内，但是其本质是它提供了一种对许多不同类型的成功/失败模式进行抽象的方法，而无需与 Result&lt;T, E&gt; 紧密联系。如你所见，x? 语法仍然调用 From::from，这是我们实现自动错误转换的方式。 由于目前编写的大多数代码都使用 ? 代替 try!，因此我们将在本文的其余部分中继续使用 ?。 让我们看一下我们之前编写的用于读取文件并将其内容转换为整数的代码： 1234567891011use std::fs::File;use std::io::Read;use std::path::Path;fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; { let mut file = File::open(file_path).map_err(|e| e.to_string())?; let mut contents = String::new(); file.read_to_string(&amp;mut contents).map_err(|e| e.to_string())?; let n = contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string())?; Ok(2 * n)} 之前，我说过我们可以不调用 map_err。确实，我们要做的就是选择一种适用 From 的类型。正如我们在上一节中所看到的，From 的实现可以让我们将任何错误类型转换为 Box&lt;Error&gt;： io-basic-error-try-from123456789101112use std::error::Error;use std::fs::File;use std::io::Read;use std::path::Path;fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, Box&lt;Error&gt;&gt; { let mut file = File::open(file_path)?; let mut contents = String::new(); file.read_to_string(&amp;mut contents)?; let n = contents.trim().parse::&lt;i32&gt;()?; Ok(2 * n)} 我们已经非常接近理想的错误处理。我们的代码在错误处理上的开销很小，因为 ? 操作符同时封装了三件事： 模式匹配。 控制流。 错误类型转换。 当三者结合在一起时，我们得到的代码不受组合器，调用 unwrap 或模式匹配的束缚。 剩下的只有一点点：Box&lt;Error&gt; 类型是不透明的。如果我们返回 Box&lt;Error&gt; 给调用方，则调用方将无法检查潜在的错误类型。虽然这种情况肯定比返回 String 要好，因为调用者可以调用诸如 description 和 cause的方法，但局限性仍然是：Box&lt;Error&gt; 不透明。（注意，这并非完全正确，因为 Rust 确实具有运行时反射，这在超出本文范围的某些情况下很有用。） 现在该重新审视我们的自定义 CliError 类型并将所有内容整合在一起。 组合自定义错误类型 在上一节中，我们研究了 ? 运算符以及它如何通过调用 From::from 错误值为我们完成自动类型转换。特别是，我们可以将错误转换为 Box&lt;Error&gt;，但是类型对于调用者是不透明的。 要解决此问题，我们使用我们已经熟悉的相同补救措施：自定义错误类型。下面仍然是读取文件内容并将其转换为整数的代码： io-basic-error-custom-from1234567891011121314151617181920use std::fs::File;use std::io::{self, Read};use std::num;use std::path::Path;// We derive `Debug` because all types should probably derive `Debug`.// This gives us a reasonable human readable description of `CliError` values.#[derive(Debug)]enum CliError { Io(io::Error), Parse(num::ParseIntError),}fn file_double_verbose&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; { let mut file = File::open(file_path).map_err(CliError::Io)?; let mut contents = String::new(); file.read_to_string(&amp;mut contents).map_err(CliError::Io)?; let n: i32 = contents.trim().parse().map_err(CliError::Parse)?; Ok(2 * n)} 请注意，我们仍然有 map_err 的调用。为什么？回想一下 ? 运算符和 From 的定义，问题在于，没有 From 实现使我们能够从错误类型（例如 io::Error 和 num::ParseIntError）转换为我们自己的自定义类型 CliError。当然，解决这个问题很容易！既然定义了 CliError，我们就可以为它实现 From： io-basic-error-custom-from1234567891011impl From&lt;io::Error&gt; for CliError { fn from(err: io::Error) -&gt; CliError { CliError::Io(err) }}impl From&lt;num::ParseIntError&gt; for CliError { fn from(err: num::ParseIntError) -&gt; CliError { CliError::Parse(err) }} 所有这些实现正在做的事情是教导 From 如何从其他错误类型创建 CliError。在我们的例子中，实现就像调用相应的值构造函数一样简单。确实，这通常很容易。 我们终于可以重写file_double： io-basic-error-custom-from1234567fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; { let mut file = File::open(file_path)?; let mut contents = String::new(); file.read_to_string(&amp;mut contents)?; let n: i32 = contents.trim().parse()?; Ok(2 * n)} 我们在这里所做的唯一一件事就是删除对 map_err 的调用。不再需要它们，因为 ? 运算符会在错误值上调用 From::from。之所以有效，是因为我们为所有可能出现的错误类型提供了 From 的实现。 如果我们修改 file_double 函数以执行其他操作，例如，将字符串转换为浮点数，则需要为错误类型添加新的变体： 12345enum CliError { Io(io::Error), ParseInt(num::ParseIntError), ParseFloat(num::ParseFloatError),} 为了反映此更改，我们需要更新之前的 impl From&lt;num::ParseIntError&gt; for CliError 并添加新的 impl From&lt;num::ParseFloatError&gt; for CliError： 1234567891011impl From&lt;num::ParseIntError&gt; for CliError { fn from(err: num::ParseIntError) -&gt; CliError { CliError::ParseInt(err) }}impl From&lt;num::ParseFloatError&gt; for CliError { fn from(err: num::ParseFloatError) -&gt; CliError { CliError::ParseFloat(err) }} 就是这样！ 对库作者的建议 Rust 库的范式仍在形成，但是如果你的库需要报告自定义错误，那么你可能需要定义自己的错误类型。是否公开其表示形式（如 ErrorKind）或使其隐藏（如 ParseIntError）取决于你。无论如何执行，通常最好的做法是至少提供有关错误的信息，而不仅仅是其 String 表示形式。但是可以肯定的是，这将取决于用例。 至少，你应该实现 Error trait。这将使你的库用户在组合错误类型时有一定的灵活性。实施此 Error 特征还意味着要确保用户具有获取错误的字符串表示形式的能力（因为它要求实现 fmt::Debug 和 fmt::Display）。 除此之外，提供 From 错误类型的实现也可能很有用。这使你（库作者）和你的用户可以编写更详细的错误。例如， csv::Error同时为 io::Error 和 byteorder::Error 提供了 From 实现 。 最后，根据你的喜好，你可能还想定义一个 Result 类型别名，尤其是在你的库定义了单个错误类型的情况下。这是在标准库使用的 io::Result 和 fmt::Result。 案例学习: 读取人口数据 这个案例很长，根据你的知识背景，可能会比较复杂。虽然有很多示例代码与说明一起使用，但大多数代码都是专门为教学目的而设计的。虽然我不够聪明，无法制作既不是玩具示例又能够实现教学的示例，但我可以撰写实际案例。 为此，我想构建一个命令行程序，让你查询世界人口数据。目标很简单：你给它一个位置，它将告诉你人口数据。尽管简单，但仍有很多地方可能出错！ 我们将使用的数据来自 Data Science Toolkit。我已经为此练习准备了一些数据。你可以获取 世界人口数据 （41MB gzip 压缩，145MB 未压缩），也可以仅获取 美国人口数据 （2.2MB gzip 压缩，7.2MB 未压缩）。 到目前为止，我一直将代码限制为 Rust 的标准库。但是对于像这样的真实任务，我们至少要使用某种东西来解析CSV数据，解析程序参数并将这些东西自动解码为 Rust 类型。为此，我们将使用 csv， docopt 和rustc-serialize crate。 在 Github 上获取 该案例研究的最终代码在Github上。如果你安装了Rust和Cargo，那么你要做的就是： 1234git clone git://github.com/BurntSushi/rust-error-handling-case-studycd rust-error-handling-case-studycargo build --release./target/release/city-pop --help 我们将逐步构建该项目。继续！ 初始化 我不会花很多时间在 Cargo 上建立项目，因为 Rust Book 和 Cargo的文档 已经很好地介绍了该项目 。 要从头开始，请运行 cargo new --bin city-pop 并确保你的 Cargo.toml 如下所示： 123456789101112[package]name = &quot;city-pop&quot;version = &quot;0.1.0&quot;authors = [&quot;Andrew Gallant &lt;jamslam@gmail.com&gt;&quot;][[bin]]name = &quot;city-pop&quot;[dependencies]csv = &quot;0.*&quot;docopt = &quot;0.*&quot;rustc-serialize = &quot;0.*&quot; 你应该能够直接运行： 123cargo build --release./target/release/city-pop#Outputs: Hello, world! 参数解析 让我们首先进行参数解析。我不会在 Docopt 上介绍太多细节，但是有一个 不错的网页 描述了它以及 Rust crate 的文档。简单地说，Docopt 从 Usage 字符串生成一个参数解析器。解析完成后，我们可以将程序参数解码为Rust 结构体。我们的程序如下，其中带有适当的 extern crate 语句，Usage 字符串，我们的 Args struct 和一个空的 main： 12345678910111213141516171819extern crate docopt;extern crate rustc_serialize;static USAGE: &amp;'static str = &quot;Usage: city-pop [options] &lt;data-path&gt; &lt;city&gt; city-pop --helpOptions: -h, --help Show this usage message.&quot;;struct Args { arg_data_path: String, arg_city: String,}fn main() {} 好的，是时候开始编写了。Docopt 的文档说，我们可以创建一个解析器 Docopt::new，然后使用 Docopt::decode 将其解码为一个结构体。这两个函数都会返回 docopt::Error。我们可以从显式模式匹配开始： 12345678910111213141516171819202122// These use statements were added below the `extern` statements.// I'll elide them in the future. Don't worry! It's all on Github:// https://github.com/BurntSushi/rust-error-handling-case-study//use std::io::{self, Write};//use std::process;//use docopt::Docopt;fn main() { let args: Args = match Docopt::new(USAGE) { Err(err) =&gt; { writeln!(&amp;mut io::stderr(), &quot;{}&quot;, err).unwrap(); process::exit(1); } Ok(dopt) =&gt; match dopt.decode() { Err(err) =&gt; { writeln!(&amp;mut io::stderr(), &quot;{}&quot;, err).unwrap(); process::exit(1); } Ok(args) =&gt; args, } };} 这并不是很好。为了使代码更清晰，我们可以做的一件事是编写一个宏以将消息打印到 stderr 然后退出： fatal-def1234567macro_rules! fatal { ($($tt:tt)*) =&gt; {{ use std::io::Write; writeln!(&amp;mut ::std::io::stderr(), $($tt)*).unwrap(); ::std::process::exit(1) }}} unwrap 在这里是没问题的，因为如果失败的话，就意味着你的程序无法写入 stderr。一个好的经验法则是可以中止，但是可以肯定的是，如果需要，你可以做其他事情。 这个代码看起来更好，但是显式的模式匹配仍然很麻烦： 1234567let args: Args = match Docopt::new(USAGE) { Err(err) =&gt; fatal!(&quot;{}&quot;, err), Ok(dopt) =&gt; match dopt.decode() { Err(err) =&gt; fatal!(&quot;{}&quot;, err), Ok(args) =&gt; args, }}; 值得庆幸的是，docopt::Error 类型定义了一种便捷的方法 exit，该方法可以有效地完成我们刚刚做的事情。将其与我们的组合器知识相结合，我们获得了简洁明了的代码： 123let args: Args = Docopt::new(USAGE) .and_then(|d| d.decode()) .unwrap_or_else(|err| err.exit()); 如果此代码成功完成，则将根据用户提供的值填充 args。 编写程序逻辑 编写代码的方式各不相同，但是当我不确定如何编码问题时，错误处理通常是我要考虑的最后一件事。对于好的设计来说，这不是一个很好的做法，但是对于快速原型制作可能是有用的。在我们的案例中，由于 Rust 迫使我们对错误进行处理，这也将使程序的哪些部分可能导致错误变得显而易见。为什么？因为 Rust 将使我们调用 unwrap，这可以使我们很好地了解如何进行错误处理。 在本案例中，程序逻辑非常简单。我们需要做的就是解析提供给我们的 CSV 数据，并在匹配的行中打印出一个字段。我们开始吧。（确保添加 extern crate csv; 到文件的顶部。） 123456789101112131415161718192021222324252627282930313233// This struct represents the data in each row of the CSV file.// Type based decoding absolves us of a lot of the nitty gritty error// handling, like parsing strings as integers or floats.struct Row { country: String, city: String, accent_city: String, region: String, // Not every row has data for the population, latitude or longitude! // So we express them as `Option` types, which admits the possibility of // absence. The CSV parser will fill in the correct value for us. population: Option&lt;u64&gt;, latitude: Option&lt;f64&gt;, longitude: Option&lt;f64&gt;,}fn main() { let args: Args = Docopt::new(USAGE) .and_then(|d| d.decode()) .unwrap_or_else(|err| err.exit()); let file = fs::File::open(args.arg_data_path).unwrap(); let mut rdr = csv::Reader::from_reader(file); for row in rdr.decode::&lt;Row&gt;() { let row = row.unwrap(); if row.city == args.arg_city { println!(&quot;{}, {}: {:?}&quot;, row.city, row.country, row.population.expect(&quot;population count&quot;)); } }} 让我们分析可能出现的错误。我们可以从显而易见的地方开始：这三个 unwrap 地方为： fs::File::open 可能返回 io::Error。 csv::Reader::decode 一次解码一个记录，但是解码一条记录 （查看 Iterator 上的关联类型 Item）可能产生一个 csv::Error。 如果 row.population 为 None，则调用 expect 会导致 panic。 还有其他吗？如果我们找不到匹配的城市怎么办？类似的工具 grep 将返回错误代码，因此我们也应该这样做。因此，我们得到了特定于我们问题的逻辑错误，IO 错误和 CSV 分析错误。我们将探索两种不同的方法来处理这些错误。 我想从使用 Box&lt;Error&gt; 开始。稍后，我们将看到定义自己的错误类型也是很有用的。 使用 Box&lt;Error&gt; 进行错误处理 Box&lt;Error&gt; 的特性很合适，因为你不需要定义自己的错误类型，也不需要任何 From 实现。缺点是，由于 Box&lt;Error&gt; 是 trait 对象，因此会删除隐含的类型，这意味着编译器无法再对其基础类型进行推理。 让我们开始改变函数的返回类型 T 到 Result&lt;T, OurErrorType&gt; 重构我们的代码。在这种情况下，OurErrorType is Box&lt;Error&gt;。那么 T 是什么？我们可以将返回类型添加到main吗？ 第二个问题的答案是否定的，我们不能。这意味着我们需要编写一个新函数。但是 T 是什么呢？最简单的方法是将匹配 Row 值的列表作为 Vec&lt;Row&gt; 返回。（更好的代码将返回一个迭代器，但这留给读者练习。） 让我们将代码重构为自己的函数，但保留对 unwrap 的调用。请注意，我们选择通过简单地忽略该行来处理人口总数缺失的可能性。 1234567891011121314151617181920212223242526272829303132333435363738394041struct Row { // unchanged}struct PopulationCount { city: String, country: String, // This is no longer an `Option` because values of this type are only // constructed if they have a population count. count: u64,}fn search&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P, city: &amp;str) -&gt; Vec&lt;PopulationCount&gt; { let mut found = vec![]; let file = fs::File::open(file_path).unwrap(); let mut rdr = csv::Reader::from_reader(file); for row in rdr.decode::&lt;Row&gt;() { let row = row.unwrap(); match row.population { None =&gt; { } // skip it Some(count) =&gt; if row.city == city { found.push(PopulationCount { city: row.city, country: row.country, count: count, }); }, } } found}fn main() { let args: Args = Docopt::new(USAGE) .and_then(|d| d.decode()) .unwrap_or_else(|err| err.exit()); for pop in search(&amp;args.arg_data_path, &amp;args.arg_city) { println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count); }} 尽管我们摆脱了对 expect 的调用（是 unwrap 的更好的变体），但我们仍然应该处理没有任何搜索结果的情况。 要将其转换为正确的错误处理，我们需要执行以下操作： 将 search 的返回类型更改为 Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt;。 使用 ? 运算符，以便将错误返回给调用者，而不用 panic 该程序。 处理 main 中的错误。 让我们尝试一下： 12345678910111213141516171819202122232425fn search&lt;P: AsRef&lt;Path&gt;&gt; (file_path: P, city: &amp;str) -&gt; Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error+Send+Sync&gt;&gt; { let mut found = vec![]; let file = fs::File::open(file_path)?; let mut rdr = csv::Reader::from_reader(file); for row in rdr.decode::&lt;Row&gt;() { let row = row?; match row.population { None =&gt; { } // skip it Some(count) =&gt; if row.city == city { found.push(PopulationCount { city: row.city, country: row.country, count: count, }); }, } } if found.is_empty() { Err(From::from(&quot;No matching cities with a population were found.&quot;)) } else { Ok(found) }} 不同于 x.unwrap()，我们现在使用 x?。由于我们的函数返回 Result&lt;T, E&gt;，因此如果发生错误，? 操作符会从函数中提前返回。 这段代码有一个大陷阱：我们应该使用 Box&lt;Error + Send + Sync&gt; 代替 Box&lt;Error&gt;。我们这样做是为了将纯字符串转换为错误类型。我们需要这些额外的限制，以便我们可以使用相应的 From impls： 1234567// We are making use of this impl in the code above, since we call `From::from`// on a `&amp;'static str`.impl&lt;'a, 'b&gt; From&lt;&amp;'b str&gt; for Box&lt;Error + Send + Sync + 'a&gt;// But this is also useful when you need to allocate a new string for an// error message, usually with `format!`.impl From&lt;String&gt; for Box&lt;Error + Send + Sync&gt; 现在，我们已经了解了如何使用 Box&lt;Error&gt; 进行正确的错误处理，让我们尝试使用自定义错误类型的另一种方法。但是首先，让我们从错误处理中休息一下，并增加对从 stdin 中读取数据的支持。 从 stdin 读取 在我们的程序中，我们接受单个文件作为输入，并对数据进行一次传递。这意味着我们可能应该能够在 stdin 上接受输入。但是我们也喜欢当前的格式，所以让我们两者兼而有之！ 添加对 stdin 的支持实际上非常容易。我们只需要做两件事： 调整程序参数，以便在从 stdin 读取人口数据时可以接受一个参数：城市。 修改 search 功能以采用可选的文件路径。当为 None 时，它知道应该从 stdin 读取。 首先，这是新的 Usage 和 Args 结构： 123456789101112static USAGE: &amp;'static str = &quot;Usage: city-pop [options] [&lt;data-path&gt;] &lt;city&gt; city-pop --helpOptions: -h, --help Show this usage message.&quot;;struct Args { arg_data_path: Option&lt;String&gt;, arg_city: String,} 我们所做的就是在 Docopt 用法字符串中将 data-path 参数设置为可选，并将相应的 struct 成员 arg_data_path 设置为可选。docopt crate将处理其余部分。 修改 search 有些棘手。csv crate 可以解析任何实现了io::Read的类型。但是，如何在两种类型上使用相同的代码？实际上，我们可以采取几种方法。一种方法是编写 search 代码，使其对某些实现了 io::Read 的类型参数 R 是通用的。另一种方法是只使用 trait 对象： 1234567891011fn search&lt;P: AsRef&lt;Path&gt;&gt; (file_path: &amp;Option&lt;P&gt;, city: &amp;str) -&gt; Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error+Send+Sync&gt;&gt; { let mut found = vec![]; let input: Box&lt;io::Read&gt; = match *file_path { None =&gt; Box::new(io::stdin()), Some(ref file_path) =&gt; Box::new(fs::File::open(file_path)?), }; let mut rdr = csv::Reader::from_reader(input); // The rest remains unchanged!} 使用自定义类型进行错误处理 之前，我们学习了如何使用自定义错误类型来编写错误类型。为此，我们将错误类型定义为 enum，然后实现 Error 和 From。 由于存在三个不同的错误（IO，CSV 解析和未找到），因此我们定义一个具有三个变体的 enum： 12345enum CliError { Io(io::Error), Csv(csv::Error), NotFound,} 并且实现 Display 和 Error： 1234567891011121314151617181920impl fmt::Display for CliError { fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result { match *self { CliError::Io(ref err) =&gt; err.fmt(f), CliError::Csv(ref err) =&gt; err.fmt(f), CliError::NotFound =&gt; write!(f, &quot;No matching cities with a \\ population were found.&quot;), } }}impl Error for CliError { fn description(&amp;self) -&gt; &amp;str { match *self { CliError::Io(ref err) =&gt; err.description(), CliError::Csv(ref err) =&gt; err.description(), CliError::NotFound =&gt; &quot;not found&quot;, } }} 在我们可以在 search 函数中使用 CliError 类型之前，我们需要提供一些 From 实现。我们如何知道要提供哪些实现？好吧，我们需要同时从io::Error 和 csv::Error 中转换为 CliError。这些是唯一的外部错误，所以我们 From 现在只需要两个实现： 1234567891011impl From&lt;io::Error&gt; for CliError { fn from(err: io::Error) -&gt; CliError { CliError::Io(err) }}impl From&lt;csv::Error&gt; for CliError { fn from(err: csv::Error) -&gt; CliError { CliError::Csv(err) }} 由于定义了 ? 运算符，因此 From 非常重要 。特别是，如果发生错误，则对错误进行调用 From::from，在这种情况下，会将其转换为我们自己的错误类型 CliError。 随着 From 实现的完成，我们只需要对我们的 search 函数进行两个小调整：返回类型和“未找到”错误。这是完整的程序： 12345678910111213141516171819202122232425262728fn search&lt;P: AsRef&lt;Path&gt;&gt; (file_path: &amp;Option&lt;P&gt;, city: &amp;str) -&gt; Result&lt;Vec&lt;PopulationCount&gt;, CliError&gt; { let mut found = vec![]; let input: Box&lt;io::Read&gt; = match *file_path { None =&gt; Box::new(io::stdin()), Some(ref file_path) =&gt; Box::new(fs::File::open(file_path)?), }; let mut rdr = csv::Reader::from_reader(input); for row in rdr.decode::&lt;Row&gt;() { let row = row?; match row.population { None =&gt; { } // skip it Some(count) =&gt; if row.city == city { found.push(PopulationCount { city: row.city, country: row.country, count: count, }); }, } } if found.is_empty() { Err(CliError::NotFound) } else { Ok(found) }} 无需其他更改。 额外功能 如果你像我一样，那么编写通用代码会感觉不错，因为通用化的东西很酷！但是有时候，这样做是不值得的。看一下我们在上一步中所做的事情： 定义了新的错误类型。 新增实现了 Error，Display 和两个 From。 这里最大的缺点是我们的程序并没有改善很多。我个人喜欢它，因为我喜欢使用 enum 表示错误，但是这样做有很多开销，尤其是在像这样的短程序中。 像我们在这里一样使用自定义错误类型的一个有用方面是，main 函数现在可以选择以不同方式处理错误。以前，使用 Box&lt;Error&gt; 时，它没有太多选择：仅打印消息。我们在这里仍然这样做，但是如果我们想添加一个 --quiet 标志怎么办？该 --quiet 标志应使任何详细的输出静音。 现在，如果程序找不到匹配项，它将输出一条消息，说明是这样。这可能有点笨拙，特别是如果你打算将该程序用于 shell 脚本中时。 因此，让我们从添加标志开始。像以前一样，我们需要调整用法字符串并在 Args 结构中添加一个标志。docopt crate 完成剩下的事情： 1234567891011121314static USAGE: &amp;'static str = &quot;Usage: city-pop [options] [&lt;data-path&gt;] &lt;city&gt; city-pop --helpOptions: -h, --help Show this usage message. -q, --quiet Don't show noisy messages.&quot;;struct Args { arg_data_path: Option&lt;String&gt;, arg_city: String, flag_quiet: bool,} 现在，我们只需要实现 “quiet” 功能即可。这需要我们在 main 中进行的调整： 1234567match search(&amp;args.arg_data_path, &amp;args.arg_city) { Err(CliError::NotFound) if args.flag_quiet =&gt; process::exit(1), Err(err) =&gt; fatal!(&quot;{}&quot;, err), Ok(pops) =&gt; for pop in pops { println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count); }} 当然，如果发生 IO 错误或数据解析失败，我们不想静默输出。因此，我们采用模式匹配，以检查错误类型是否为 NotFound 和是否已启用 --quiet。如果搜索失败，我们仍然会退出代码（遵循 grep 的约定）。 如果我们坚持使用 Box&lt;Error&gt;，那么实现 --quiet 功能将非常棘手。 这几乎总结了我们的案例研究。从这里开始，你应该能够编写带有适当错误处理的自己的程序和库。 概括 由于本文很长，因此快速总结一下Rust中的错误处理很有用。这些是我的“经验法则”。他们并不是教条。每一个规则都可能会有充足的理由去反驳！ 如果你正在编写示例代码，并不想实现过于繁琐的错误处理，unwrap 应该是很好用的（不管是 Result::unwrap， Option::unwrap 或更好的 Option::expect）。你的代码的使用者应该知道如何使用正确的错误处理。（如果没有，让他们来看这篇文章！） 如果你正在编写 quick ‘n’ dirty 程序，请不要羞于使用 unwrap。警告：如果交接到别人的手中，当他们被错误的消息所困扰时，不要感到惊讶！ 如果你正在编写一个 quick ‘n’ dirty 程序，并且无论如何都不想造成 panic，那么你应该使用如上例所示的 Box&lt;Error&gt; （或 Box&lt;Error + Send + Sync&gt;）。另一个比较好的替代方法是使用 anyhow crate 及其 anyhow::Error 类型。使用 anyhow 时，在 nightly Rust 中，你的错误将自动附加 backtraces 。 否则，在程序中使用适当的 From 和 Error 实现定义自己的错误类型，以使 ? 操作符更加符合工程学。 如果你正在编写库，并且代码可能会产生错误，请定义自己的错误类型并实现 std::error::Error trait。在适当的地方，实现 From 使你的库代码和调用者的代码更易于编写。（由于 Rust 的一致性规则，调用者将无法为你的错误类型实现 From，因此你的库应该这样做。） 使用 Option 和 Result 上定义的组合器 。有时单独使用它们可能会有些麻烦，但是我发现，? 操作符和组合器的组合非常有吸引力。and_then，map 和 unwrap_or是我的最爱。","link":"/p/d02431de/"},{"title":"Docker 基本使用","text":"Docker 基本使用 基本命令 获取镜像 从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为： 12docker pull [选项] 仓库名[:标签]docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 具体的选项可以通过 docker pull --help 命令看到，这里我们说一下镜像名称的格式。 Docker Registry 地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。 仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。 比如： 123456789$ docker pull ubuntu:18.0418.04: Pulling from library/ubuntubf5d46315322: Pull complete9f13e0ac480c: Pull completee8988b5b3097: Pull complete40af181810e7: Pull completee6f7c7e5c03e: Pull completeDigest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbeStatus: Downloaded newer image for ubuntu:18.04 上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 ubuntu:18.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 18.04 的镜像。 运行 有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 ubuntu:18.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。 123456789101112131415$ docker run -it --rm ubuntu:18.04 bashroot@e7009c6ce357:/# cat /etc/os-releaseNAME=&quot;Ubuntu&quot;VERSION=&quot;18.04.1 LTS (Bionic Beaver)&quot;ID=ubuntuID_LIKE=debianPRETTY_NAME=&quot;Ubuntu 18.04.1 LTS&quot;VERSION_ID=&quot;18.04&quot;HOME_URL=&quot;https://www.ubuntu.com/&quot;SUPPORT_URL=&quot;https://help.ubuntu.com/&quot;BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot;PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;VERSION_CODENAME=bionicUBUNTU_CODENAME=bionic docker run 就是运行容器的命令，具体格式我们会在 容器 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。 -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 --rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。 ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。 bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。 进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 18.04.1 LTS 系统。 最后我们通过 exit 退出了这个容器。 列出镜像 要想列出已经下载下来的镜像，可以使用 docker image ls 命令。 12345678$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEredis latest 5f515359c7f8 5 days ago 183 MBnginx latest 05a60462f8ba 5 days ago 181 MBmongo 3.2 fe9198c04d62 5 days ago 342 MB&lt;none&gt; &lt;none&gt; 00285df0df87 5 days ago 342 MBubuntu 18.04 f753707788c5 4 weeks ago 127 MBubuntu latest f753707788c5 4 weeks ago 127 MB 虚悬镜像 上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 &lt;none&gt;。： 1&lt;none&gt; &lt;none&gt; 00285df0df87 5 days ago 342 MB 这个镜像原本是有镜像名和标签的，原来为 mongo:3.2，随着官方镜像维护，发布了新版本后，重新 docker pull mongo:3.2 时，mongo:3.2 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 &lt;none&gt;。除了 docker pull 可能导致这种情况，docker build 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 &lt;none&gt; 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像： 123$ docker image ls -f dangling=trueREPOSITORY TAG IMAGE ID CREATED SIZE&lt;none&gt; &lt;none&gt; 00285df0df87 5 days ago 342 MB 一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。 1$ docker image prune 列出部分镜像 不加任何参数的情况下，docker image ls 会列出所有顶级镜像，但是有时候我们只希望列出部分镜像。docker image ls 有好几个参数可以帮助做到这个事情。 根据仓库名列出镜像 1234567891011$ docker image ls ubuntu$ docker image ls ubuntu:18.04# -f 代表 filter$ docker image ls -f since=mongo:3.2$ docker image ls -f before=mongo:3.2$ docker image ls -f label=com.example.version=0.1# -q 代表 显示ID$ docker image ls -q# --format 表示 以特定格式显示$ docker image ls --format &quot;{{.ID}}: {{.Repository}}&quot;$ docker image ls --format &quot;table {{.ID}}\\t{{.Repository}}\\t{{.Tag}}&quot; 删除本地镜像 如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为： 1$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] 用 ID、镜像名、摘要删除镜像 1234# 使用 ID$ docker image rm 501# 使用 镜像名 &lt;仓库名&gt;:&lt;标签&gt;$ docker image rm centos 用 docker image ls 命令来配合 像其它可以承接多个实体的命令一样，可以使用 docker image ls -q 来配合使用 docker image rm，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。 比如，我们需要删除所有仓库名为 redis 的镜像： 1$ docker image rm $(docker image ls -q redis) 或者删除所有在 mongo:3.2 之前的镜像： 1$ docker image rm $(docker image ls -q -f before=mongo:3.2) 充分利用你的想象力和 Linux 命令行的强大，你可以完成很多非常赞的功能。 定制镜像 docker commit 的语法格式为： 1docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]] 我们可以用下面的命令将容器保存为镜像： 123456$ docker commit \\ --author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \\ --message &quot;修改了默认网页&quot; \\ webserver \\ nginx:v2sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214 其中 --author 是指定修改的作者，而 --message 则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空。 使用 Dockerfile 定制镜像 Dockerfile 是一个文本文件，其内包含了一条条的 指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。 在一个空白目录中，建立一个文本文件，并命名为 Dockerfile： 123$ mkdir mynginx$ cd mynginx$ touch Dockerfile 其内容为： 12FROM nginxRUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html 这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。 FROM 指定基础镜像 所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 在 Docker Hub 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。 如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。 除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。 12FROM scratch... 如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。 不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 swarm、coreos/etcd。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。 RUN 执行命令 RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种： shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。 1RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html exec 格式：RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]，这更像是函数调用中的格式。 Dockerfile 正确的写法应该是这样： 1234567891011121314FROM debian:stretchRUN buildDeps='gcc libc6-dev make wget' \\ &amp;&amp; apt-get update \\ &amp;&amp; apt-get install -y $buildDeps \\ &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \\ &amp;&amp; mkdir -p /usr/src/redis \\ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\ &amp;&amp; make -C /usr/src/redis \\ &amp;&amp; make -C /usr/src/redis install \\ &amp;&amp; rm -rf /var/lib/apt/lists/* \\ &amp;&amp; rm redis.tar.gz \\ &amp;&amp; rm -r /usr/src/redis \\ &amp;&amp; apt-get purge -y --auto-remove $buildDeps 首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。 并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。 此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。 很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。 构建镜像 好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。 在 Dockerfile 文件所在目录执行： 123456789$ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048 kBStep 1 : FROM nginx ---&gt; e43d811ce2f4Step 2 : RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html ---&gt; Running in 9cdc27646c7b ---&gt; 44aa4490ce2cRemoving intermediate container 9cdc27646c7bSuccessfully built 44aa4490ce2c 从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，如同我们之前所说的那样，RUN 指令启动了一个容器 9cdc27646c7b，执行了所要求的命令，并最后提交了这一层 44aa4490ce2c，随后删除了所用到的这个容器 9cdc27646c7b。 这里我们使用了 docker build 命令进行镜像构建。其格式为： 1docker build [选项] &lt;上下文路径/URL/-&gt; 在这里我们指定了最终镜像的名称 -t nginx:v3，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。 参考文档 Docker — 从入门到实践 Docker 官方 Ubuntu 安装文档","link":"/p/16e4ca1b/"},{"title":"Manjaro 安装与配置","text":"Manjaro 是基于 Arch 系的一个 Linux 发行版，和 Arch 一样，采用滚动更新，但拥有自己独立的软件仓库。Manjaro 的目标是让强大的 Arch 更方便用户使用，使用著名的 Pacman 且可以直接利用 AUR 上的资源。 Manjaro 本身使用三个软件仓库：不稳定库，即含有那些不成熟的 Arch 包，这些包与 Arch 源有 1-2 天 的延后；测试库，每周同步一次，包含那些 Arch 不稳定源的包；以及稳定库，包含那些由开发团队确认稳定的软件。 官方地址，排名数据源于DistroWatch 下载与安装 镜像下载 官方网站：https://manjaro.org/get-manjaro/ 清华大学开源镜像：https://mirrors.tuna.tsinghua.edu.cn/manjaro-cd/ 推荐使用官方网站，如果下载速度不佳可以选择国内镜像。同时可以选择自己习惯的桌面环境，目前官方支持xfce、kde、gnome三种桌面环境（后来加入了 architect），在社区版本中提供更多桌面环境的支持，比如国产的deepin桌面环境*（正在使用）* 安装过程 安装过程参考 User Guide 系统配置 在安装好系统之后，需要进行一些简单的配置，以便在国内使用更加顺畅。 清华源：https://mirrors.tuna.tsinghua.edu.cn/help/archlinux/ 中科大：https://mirrors.ustc.edu.cn/ 阿里源：https://opsx.alibaba.com/ 更换国内源 使用 pacman 进行测试镜像源的速度，并对其进行排名，从中选择一个最快的。 1sudo pacman-mirrors -i -c China -m rank 之后进行更新系统： 1sudo pacman -Syyu 添加 archlinuxcn 编辑 /etc/pacman.conf 文件，在其中添加： /etc/pacman.conf1234567[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch[arch4edu]SigLevel = NeverServer = https://mirrors.tuna.tsinghua.edu.cn/arch4edu/$arch 之后更新缓存 1sudo pacman -Syy 安装 archlinuxcn-keyring 包导入 GPG key 1sudo pacman -S archlinuxcn-keyring 使用 AUR 清华 AUR 镜像使用帮助：https://mirror.tuna.tsinghua.edu.cn/help/AUR/ AUR（Arch User Repository）是为用户而建、由用户主导的 Arch 软件仓库。 Yaourt 是之前最常用的 AUR 助手，但它已经停止更新，现在常用的有 yay，aurman。 yay 本文中使用 yay，Github 地址：https://github.com/Jguer/yay 可以使用 pacman 安装 yay： 1sudo pacman -S yay 安装好之后，便可以使用 yay 代替 pacman 进行软件的安装。 相关命令： 12345yay 同步和更新 repos 和 AUR 中的所有包yay &lt;item&gt; 从 repos 和 AUR 交互式搜索和安装包yay -S &lt;item&gt; 从 repos 和 AUR 安装新包yay -Ps 打印系统状态yay -Yc 清理不需要的依赖 为输出信息添加颜色 参考 Github 上的 issue：https://github.com/Jguer/yay/issues/123 yay now follows pacman’s config /etc/pacman.conf for colors. You need to add Color to your options /etc/pacman.conf 即：在 pacman.conf 中添加 color 选项即可 /etc/pacman.conf1234567# Misc optionsUseSyslogColorTotalDownload# We cannot check disk space from within a chroot environmentCheckSpaceVerbosePkgLists 常用软件 zsh 1234sudo pacman -S zsh# 切换默认 shellchsh -s /bin/zsh oh-my-zsh 123456789# oh-my-zsh 四选一即可yay oh-my-zsh-gitsh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 配置 更改主题 编辑 ~/.zshrc 文件, 更改其中的主题设置: 1vim ~/.zshrc &amp;&amp; source ~/.zshrc 这里使用简单的 ys 主题: ~/.zshrc12ZSH_THEME=&quot;agnoster&quot;DEFAULT_USER=&quot;cheng&quot; # 隐藏用户名 更改之后, 需要使用 source 命令将其生效。 插件 在 ~/.zshrc 中找到 plugins 关键字, 就可以自定义启用的插件了, 系统默认加载 git. ~/.zshrc1plugins=(git z zsh-syntax-highlighting zsh-autosuggestions) zsh-syntax-highlighting 可以提供 Shell 命令高亮, 正确的路径自带下划线 需要用户自己手动安装: 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting zsh-autosuggestions 可以通过输入的命令提供最接近的建议, 也需要手动安装: 1git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions 字体 123sudo pacman -S noto-fonts-cjksudo pacman -S otf-fira-codesudo pacman -S powerline-fonts 网络 123sudo pacman -S google-chrome # 浏览器yay electron-ssr # 科学上网yay deepin-wine-thunderspeed # 下载工具 为了实现终端代理，可以使用 proxychains-ng 软件： 1sudo pacman -S proxychains-ng 之后在用户目录下新建 .proxychains/proxychains.conf 文件，并在其最后添加： .proxychains/proxychains.conf1socks5 127.0.0.1 1080 为了方便使用，还可使用别名缩短命令的输入，在 ~/.zshrc 中添加： ~/.zshrc1alias pc=&quot;proxychains4&quot; 之后可以通过在命令之前加入 pc 来使当前命令使用代理联网。 输入法 安装fcitx和搜狗拼音输入法： 123sudo pacman -S fcitx-sogoupinyinsudo pacman -S fcitx-imsudo pacman -S fcitx-configtool 设置环境变量，在~/.xprofile文件（如果文件不存在就新建一个）末尾加上： 123export GTK_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot; 如果提示“搜狗输入法异常！请删除.config/SogouPY 并重启”，可能的原因是文件缺失，考虑安装 sudo pacman -S fcitx-qt5 进行解决。 办公 安装 WPS 以及相关字体文件： 12sudo pacman -S wps-officesudo pacman -S ttf-wps-fonts 聊天 TIM： 12sudo pacman -S deepin.com.qq.officesudo pacman -S deepin-wine-tim Wechat: 12sudo pacman -S deepin-wine-wechatsudo pacman -S electronic-wechat 程序开发环境 123456789sudo pacman -S clang make cmake gdb # 编译调试环境sudo pacman -S visual-studio-code-bin # 牛逼的编辑器sudo pacman -S vim # 命令行下的编辑器sudo pacman -S git # 版本管理工具git config --global user.name &quot;John Doe&quot;git config --global user.email johndoe@example.comyay docker 娱乐 123456sudo pacman -S netease-cloud-musicyay steamyay deepin-image-vieweryay deepin-movieyay deepin-musicyay deepin-screenshot 插件 or 工具 12345yay thefuckecho &quot;eval $(thefuck --alias)&quot; &gt;&gt; ~/.zshrcyay screenfetchyay neofetch","link":"/p/a51c6c95/"},{"title":"Ubuntu 系统的简单配置","text":"更改软件源 使用清华的软件源 备份原有的 /etc/apt/sources.list 1sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 编辑 /etc/apt/sources.list /etc/apt/sources.list12345678910111213# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 之后进行更新软件源: 1sudo apt update 安装 git 1sudo apt install git 配置: 查看配置: 1git config --list 设置名称: 1git config --global user.name &quot;John Doe&quot; 设置邮箱: 1git config --global user.email johndoe@example.com 设置文本换行符格式: 1git config --global core.autocrlf input 更改文件夹配色 导出颜色文件: 1dircolors -p &gt; ~/.dircolors 使用 vim 编辑: 1vim ~/.dircolors 将以下两行改为: ~/.dircolors12STICKY_OTHER_WRITABLE=02;32OTHER_WRITABLE=01;34 然后在 ~/.zshrc 中, 加入: ~/.zshrc1eval $(dircolors -b $HOME/.dircolors) 安装 zsh zsh 是 shell 语言类型，兼容 bash，提供强大的命令行功能，比如 tab 补全，自动纠错功能等。 缺点就是配置太麻烦，好在有一个叫做 oh-my-zsh 的开源项目，很好的弥补了这一缺陷，只需要修修改改配置文件，就能很顺手。 查看当前环境shell 1echo $SHELL 查看系统自带哪些shell 1cat /etc/shells 使用 apt 安装 zsh: 1sudo apt install zsh 替换 bash 1chsh -s /bin/zsh 安装 oh-my-zsh 使用 curl: 1sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 使用 wget: 1sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 手动安装: 12git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 配置 zsh 更改主题 编辑 ~/.zshrc 文件, 更改其中的主题设置: 1vim ~/.zshrc 几个比较好用的主题: ys 简单高效 agnoster 好看 random 随机切换 这里使用简单的 ys 主题: ~/.zshrc1ZSH_THEME=&quot;ys&quot; 更改之后, 需要使用 source 命令将其生效: 1source ~/.zshrc 插件 在 ~/.zshrc 中找到 plugins 关键字, 就可以自定义启用的插件了, 系统默认加载 git. ~/.zshrc1plugins=(git z zsh-syntax-highlighting) autojump 快速跳转文件夹，使用 j 代替 cd 命令. 使用 apt 命令安装: 1sudo apt-get install autojump 手动安装: 123git clone git://github.com/joelthelion/autojump.gitcd autojump./install.py Z 类似于 autojump, 但是不需要安装 autojump. 使用 z 替代 cd 命令. zsh-syntax-highlighting 可以提供 Shell 命令高亮, 正确的路径自带下划线 需要用户自己手动安装: 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting zsh-autosuggestions 可以通过输入的命令提供最接近的建议, 也需要手动安装: 1git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions","link":"/p/7bf7524/"},{"title":"Windows 下使用 WSL 安装 Ubuntu","text":"Windows Subsystem for Linux（简称WSL）是一个为在Windows 10上能够原生运行Linux二进制可执行文件（ELF格式）的兼容层。 开启 Windows 功能 控制面板 -&gt; 程序和功能 -&gt; 启用或关闭window功能 -&gt; 勾选“适用于Linux的Windows子系统” 之后需要重启电脑 安装 Ubuntu 打开 Windows 应用商店, 搜索 ubuntu: 选择第一个应用进行安装, 这里默认安装最新的发行版, 如果想要安装指定的发行版, 如 16.04 等, 可以选择后面两个进行安装 大概需要下载 220MB 的内容, 下载完会要求你重启。 启动 Ubuntu 在开始菜单中点击 Ubuntu, 这会打开 Ubuntu界面, 然后执行安装及初始化过程, 大概需要 5 分钟的时间. 之后需要设置用户名和密码, 设置完成之后便完成了 ubuntu 的安装: 查看基本信息 查看linux内核版本 1uname -r 查看系统版本 1cat /etc/lsb-release 查看本地磁盘内存情况（可见C盘、D盘） 1df -h 使用 screenfetch 可以使用 screenfetch 进行查看详细的系统信息, 不过此命令未内置在操作系统中, 需要首先安装: 1sudo apt install screenfetch &amp;&amp; screenfetch","link":"/p/9b5105cd/"},{"title":"Git language &amp;&amp; Github","text":"Git 简单使用教程 Git 语法 几个专用名词的译名 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 新建代码库 12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置 Git的设置文件为 .gitconfig ，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件 123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交 123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支 123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签 1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@{0 day ago}&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步 1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销 12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 其他 12# 生成一个可供发布的压缩包$ git archive 转载自常用Git 命令清单- 阮一峰的网络日志 Github GitHub是用于版本控制和协作的代码托管平台。它可以让您和其他人在任何地方协同工作。 本教程教您GitHub基本知识，如存储库，分支，提交和Pull请求。您将创建自己的Hello World存储库并学习GitHub的Pull Request工作流，这是一种创建和检查代码的流行方法。 1. 创建存储库 一个库通常用于举办单个项目。存储库可以包含文件夹和文件，图像，视频，电子表格和数据集。 建议包括README.md或包含项目信息的文件，以及其他常见选项，例如许可证文件。 hello-world存储库可以是存储想法，资源，甚至与他人共享和讨论事物的地方。 创建新存储库 在右上角，在您的头像或identicon旁边，单击’+'号，然后选择 New repository。 命名您的存储库hello-world。 写一个简短的描述。 选择使用README文件初始化此存储库。 2. 创建一个分支 分支是一次在不同版本的存储库上工作的方式。 默认情况下，您的存储库有一个名为branch的分支master，它被认为是权威分支。我们使用分支进行实验并在提交之前进行编辑master。 当您在分支机构上创建分支时master，您正在创建该master时间点的副本或快照。如果其他人master在您的分支机构工作时对分支进行了更改，则可以引入这些更新。 该图显示： 该master分支 一个叫做的新分支feature（因为我们在这个分支上做’特色工作’） feature它融入之前的旅程master 创建一个新分支 转到新的存储库hello-world。 单击文件列表顶部的下拉列表**：master：master**。 readme-edits在新分支文本框中键入分支名称。 选择蓝色的创建分支框或按键盘上的“Enter”。 现在你有两个分支，master和readme-edits。它们看起来完全一样，但时间不长，接下来，我们将更改添加到新分支。 3. 制作并提交更改 好样的！现在，您在readme-edits分支的代码视图中，这是一个副本master。我们来做一些编辑。 在GitHub上，保存的更改称为提交。每个提交都有一个关联的提交消息，这是一个解释为什么进行特定更改的描述。提交消息可捕获更改的历史记录，因此其他贡献者可以了解您已完成的操作和原因。 制作并提交更改 单击该README.md文件。 点击要编辑的文件视图右上角的铅笔图标。 在编辑器中，写下一些关于你自己的内容。 编写描述更改的提交消息。 单击提交更改按钮。 这些更改将只对您readme-edits分支上的README文件进行，因此现在此分支包含的内容与之不同master。 4. 打开Pull请求 很好的编辑！现在您的分支中有更改master，您可以打开Pull Request。 Pull Requests是GitHub上合作的核心。当您打开Pull Request时，您提出了更改并请求某人审核并提取您的贡献并将其合并到他们的分支中。拉请求显示来自两个分支的内容的差异。更改，添加和减少以绿色和红色显示。 提交后，即使在代码完成之前，您也可以打开拉取请求并开始讨论。 通过在拉取请求消息中使用GitHub的@mention系统，您可以询问特定人员或团队的反馈，无论他们是在大厅还是10个时区之外。 您甚至可以在自己的存储库中打开pull请求并自行合并。在开展大型项目之前，这是学习GitHub流程的好方法。 打开Pull Request以更改README 步骤 截图 点击 “拉取请求”选项卡，然后从“拉取请求”页面中，单击绿色的新拉取请求按钮。 在“ **示例比较”**框中，选择您要创建的分支readme-edits，以与master（原始）进行比较。 在“比较”页面上查看差异中的差异，确保它们是您要提交的内容。 如果您对要提交的更改感到满意，请单击绿色的“**创建拉取请求”**按钮。 为您的拉取请求提供标题，并写下您的更改的简要说明。 完成邮件后，单击“ 创建拉取请求”！ 提示：您可以使用的表情符号和拖放图片和GIF到的意见和引入请求。 5. 合并您的Pull请求 在最后一步中，是时候将您的更改结合在一起 - 将您的readme-edits分支合并到master分支中。 单击绿色合并拉取请求按钮以将更改合并到master。 单击确认合并。 继续删除分支，因为它的更改已合并，紫色框中的删除分支按钮。","link":"/p/ed7950d7/"},{"title":"改装 PowerShell","text":"作为 Windows 下的终端, PowerShell 一直以来都显得不太好用, 简陋的背景, 不好看的字体, 难用的命令. 而 PowerShell 事实上还算一款较为强大的命令行工具, 今天就来将其改装成为真正的生产力工具. 主要涉及: 字体, 颜色, 终端, oh-my-posh, PSReadLine 首先从外表开始 更改终端字体 Windows 下的字体总是显得简陋, 当然这是由于历史包袱严重, 难以直接更改, 也因此出现了一系列修改字体的工具, 如 MacType, 但是使用工具修改字体具有一定的风险性. 更加安全一点的方案是使用特制的字体, 比如这款: Sarasa Gothic/更纱黑体/更紗黑體/更紗ゴシック/사라사 고딕 在 Release 中下载最新版, 可以选择只安装简体中文版, 即包含 SC 的字体. Windows 选择 ttf 文件即可, 本文撰写时最新版为 sarasa-gothic-ttf-0.12.5.7z Windows 控制台在中文系统下, 默认是新宋体, 显示效果很差, 将其更改为刚安装的更纱黑体, 这里选择的是 Sarasa Term SC, 字号为 20: 如果找不到对应的字体, 或是更改之后没有发生变化, 可能是因为默认代码页为 GBK, 可以尝试更改代码页到 UTF-8: chcp 65001 然后再进行尝试. 然后就能发现 PowerShell 已经有了明显的变化. 更改终端配色 PowerShell 的默认蓝底白字配色也有点丑陋. 微软官方提供了一个更换 PowerShell 配色的小工具：ColorTool.exe，我们可以利用它来更换 PowerShell 的主题颜色。ColorTool 支持 iTerm 主题（以 .itermcolors 结尾的主题文件）。 我们可以从 ColorTool 的 GitHub 页面 下载这个小工具。当然，如果你使用 Scoop，也可以这样安装： 1scoop install colortool 值得注意的是，如果你是直接从 GitHub 上面下载了 colortool.zip 并解压，colortool.exe 的路径就并没有自动加入环境变量，所以你没有办法全局调用这个工具。因此我更加推荐利用 Scoop 这个优质的包管理来安装 ColorTool。 推荐阅读：「一行代码」搞定软件安装卸载，用 Scoop 管理你的 Windows 软件 ColorTool 使用非常简单。工具自带了几种主题，我们可以利用下面这个命令进行查看： 12# 注：-s 代表 schemescolortool -s 其中前面列出的几个 .ini 和 .itermcolors 就是主题配置文件，我们可以直接通过下面这个命令设置主题： 1234# 临时查看colortool &lt;主题名称&gt;# 定义默认值colortool -d &lt;主题名称&gt; 比如我们希望将主题配色更换为 OneHalfDark.itermcolors，只需要输入下面这个命令就可以更换并预览更新： 1colortool OneHalfDark 由于 ColorTool 直接支持 iTerm 主题配置文件，因此我们可以在 iterm2colorschemes 这个网站找到我们想要的主题背景进行配置，方法和上面介绍的一样：在 PowerShell 中定位至你希望更换的主题文件，使用命令 colortool &lt;主题名称&gt;.itermcolors 进行配置即可。同时，如果你对上面的主题都不满意，你也可以直接在这个网站： terminal.sexy 自行配置自己想要的主题，并通过同样的方式进行应用。 不过从 iTerm2 Color Schemes 的配色方案实在是太多了，选起来本身也是个麻烦事，我最后在这几款中选出了下面这几款配色，感觉还不错，推荐给大家： ayu Molokai Cobalt2 Pandora ThayerBright Symfonic RedSands Mathias 添加效率工具 配置文件路径 PowerShell 的配置文件一般都在 $HOME\\Documents\\WindowsPowerShell 目录下, 并且可能会存在多个 .ps1 文件 Microsoft.PowerShell_profile.ps1: 这个是 PowerShell 终端的配置文件, 在这里更改的设置只会在系统自带的 PowerShell 终端中生效, 在其他位置, 比如 VS Code, Cmder 中不会生效. Microsoft.VSCode_profile.ps1: 和上面同理, 不过是在 VS Code 中生效. profile.ps1: 这个是 PowerShell 的全局配置文件, 在多个位置都会生效. 新增（或修改）你的 PowerShell 配置文件 Microsoft.PowerShell_profile.ps1: 12345# 如果之前没有配置文件，就新建一个 PowerShell 配置文件if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force }# 用记事本打开配置文件notepad $PROFILE PSReadLine PowerShell 无法开箱即用的另一个原因是命令补全和历史搜索功能很差劲. 官方维护的有一个 PSReadLine 项目, 用于实现类似于 Linux 下 Bash 的命令补全功能. 官方推荐使用 PowerShellGet 安装, 不过首先需要安装这个模块: 1Install-Module -Name PowerShellGet -Force 之后通过 PowerShellGet 安装 PSReadLine: 12345# 安装最新版Install-Module PSReadLine -AllowPrerelease -Force# 安装稳定版Install-Module PSReadLine 之后需要启动并配置 PSReadLine, 在配置文件中加入如下内容, 便可实现一个基本的 Shell 功能: 12345678910Import-Module PSReadLine# 历史命令搜索Set-PSReadLineOption -HistorySearchCursorMovesToEndSet-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackwardSet-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward# 补全功能Set-PSReadLineKeyHandler -Key Ctrl+q -Function TabCompleteNextSet-PSReadLineKeyHandler -Key Ctrl+Q -Function TabCompletePrevious 也可参考官方的样例 SamplePSReadLineProfile.ps1 实现自己想要的功能 Oh-my-posh 和 Linux 下大名鼎鼎的 oh-my-zsh 类似, 针对于 PowerShell 也有对应的 oh-my-posh. 我们通过在 PowerShell 中执行下面的命令安装配置 oh-my-posh。 12Install-Module posh-git -Scope CurrentUser Install-Module oh-my-posh -Scope CurrentUser 然后让 PowerShell 配置生效. 需要修改 PowerShell 配置文件, 在其中添加下面的内容: Microsoft.PowerShell_profile.ps11234Import-Module posh-git Import-Module oh-my-posh $DefaultUser = 'Your User Name'Set-Theme Agnoster 其中最后一句 Set-Theme &lt;主题名&gt; 就是配置主题的命令。而 $DefaultUser 则可以用来隐藏用户名, 使 PowerShell 看起来更简洁. 如果一切顺利，你应该看到你的 Prompt 部分变成了类似这个的样子： 注意：如果你发现后面的日期显示出现了凌乱的现象（比如本该在同一行显示的字符却跑到了下一行），多半是因为显示了中文。目前很多终端都不能正常的显示中文或 CJK 字符（即：Double-width character），所以你可以通过下面这个命令将 PowerShell 的环境设置为 en-US 的英文环境： 1Set-Culture en-US Bug Fix 部分符号字体无法显示 如果你使用 oh-my-posh，并且在 oh-my-posh 里面配置了 PowerLine 命令提示符的话，你会发现，在进入 Git 目录时会看到命令提示符中有个“□”： 这个是个表情符“✎”，但是因为 Sarasa 系列字体中不包含表情符，因此就只能显示乱码了。不过也有解决办法，打开注册表编辑器，找到路径： 1计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink 在其中新建多字符串值，名称为：Sarasa Term SC，内容为： 12345678910MICROSS.TTF,Microsoft Sans Serif,108,122MICROSS.TTF,Microsoft Sans SerifMINGLIU.TTC,PMingLiUMSMINCHO.TTC,MS PMinchoBATANG.TTC,BatangMSYH.TTC,Microsoft YaHei UIMSJH.TTC,Microsoft JhengHei UIYUGOTHM.TTC,Yu Gothic UIMALGUN.TTF,Malgun GothicSEGUISYM.TTF,Segoe UI Symbol 这段内容是复制的宋体 SimSun 的，如果你愿意的话，可以用同样的方法把 Sarasa 系列的都注册一下，也可以只修改要使用的这个，然后重启计算机就可以了。 参考链接 告别 Windows 终端的难看难用，从改造 PowerShell 的外观开始 5 个 PowerShell 主题，让你的 Windows 终端更好看 PowerShell 美化指南","link":"/p/90941d95/"},{"title":"C++基本类型","text":"String || vector string 定义及初始化 1234567891011// 默认; 空串string s1;// 拷贝初始化string s2 = s1;string s3 = &quot;Hello&quot;;// 直接初始化string s2(s1);string s3(&quot;Hello&quot;);string s4(10, 'c'); 对象操作 12345678910111213141516171819// 读写cin &gt;&gt; scout &lt;&lt; sgetline(cin, s) // 包括空格, 到换行结束// 空间s.empty()s.size() // 返回 size_type类型, 无符号类型// 索引s[n]for (auto c : s)// 运算符操作s1 + s2 // 拼接s1 = s2 // 赋值s1 == s2 // 判断相等s1 != s2 // 判断不相等&lt; &lt;= &gt; &gt;= // 大小比较 范围for语句 12345678for (declaration : expression) statementfor (auto c : str) cout &lt;&lt; c &lt;&lt; endl;// 使用引用用于改变数据for (auto &amp;c : str) c = toupper(c); vector vector是一个类模板,因此需要在使用时提供额外信息来指定模板到底实例化成什么样的类,提供信息的方式为: vector&lt;class&gt; 如: vector&lt;int&gt; vector&lt;vector&lt;string&gt;&gt; 在C++的早期版本中, 嵌套的vector需要表示成: vector&lt;vector&lt;string&gt; &gt;, 即在两个右尖括号间需要多加一个空格 定义及初始化 默认初始化: vector&lt;T&gt; v1 拷贝初始化: vector&lt;T&gt; v2(v1) , vector&lt;T&gt; v2 = v1 列表初始化: vector&lt;string&gt; v3 = {&quot;a&quot;, &quot;an&quot;, &quot;the&quot;} , vector&lt;string&gt; v3{&quot;a&quot;, &quot;an&quot;, &quot;the&quot;} 创建指定数量的元素: vector&lt;int&gt; ivec(10, -1) 值初始化: 使用类型的默认初始值 元素操作 加到尾端: v.push_back(i) 判断为空: v.empty() 元素个数: v.size() 元素引用: v[i] 拷贝操作: v1 = v2 , v1 = {a, b, c, ...} 判断相等: v1 == v2 , v1 != v2 比较操作: &lt; &lt;= &gt; &gt;= 在循环内部包含向vector添加元素操作时, 不宜使用范围for循环 迭代器 标准库容器类型都支持迭代器, 如: vector string非容器类型, 但支持迭代器 有迭代器的类型都拥有begin和end成员 auto b = v.begin(), e = v.end() begin()返回一种引用, 并指向第一个元素, end()指向尾元素的下一位置, 即不存在的一个位置, 称为&quot;尾后迭代器&quot; 如果容器为空, 则begin()与end()返回同一迭代器, 都是&quot;尾后迭代器&quot; cbegin() , cend() 返回常量迭代器 但凡使用了迭代器的循环体, 都不要向迭代器所属的容器添加元素 运算符 *iter 返回迭代器iter所指元素的引用 iter-&gt;a 解引用并返回其指向元素成员 (*it).a = it-&gt;a ++iter / --iter 返回下/上一个元素 iter1 == / != iter2 判断两个迭代器是否相等 iter + / - n 向下/上移动n个元素 += -= 复合赋值语句 iter1 - iter2 返回之间的距离 &gt; &gt;= &lt; &lt;= 关系运算符 1234567// 将第一个字母大写string s(&quot;some string&quot;);if (s.begin() != s.end()) // 判断非空{ auto it = s.begin(); *it = toupper(*it);} 123//for (auto it = s.begin(); it != s.end(); it++) *it = toupper(*it);","link":"/p/beaf03ad/"},{"title":"Distributed System","text":"分布式系统期末总结 分布式系统模型 什么是分布式系统 A distributed system is a collection of autonomous computing elements that appears to its users as a single coherent system. 分布式系统是一组自主计算的集合,在用户看来是一个单一的一致系统 分布式系统的目标 Making resources available: 使资源多处可用 Distribution transparency: 分布式透明性 Openness: 开放性 Scalability: 可扩展性 为什么要分布式？ Because people are distributed 方面 原因 经济 多个微处理器提供了比主机更好的性价比 速度 分布式系统可以拥有更多的算力 继承的分布式 一些应用本身便涉及到空间上分散的机器 可信性 如果单个机器损坏, 整个系统仍可以存活 可增加的成长 算力可以一点点地增加 分布式系统透明性和开放性的含义。 透明性 隐藏底层的资源获取方式、资源位置、资源移动、重定位、复制、并发性、资源错误与恢复 想要实现完全的透明可能比较困难: 用户可能被定位在不同的组件 完全隐藏网络和节点的错误是（理论与实践上）不可能的 难以分辨速度较慢与网络错误 难以确定服务器在崩溃之前是否已经进行了某些操作 完全的透明性将会影响性能，暴露系统的分布式环境 保存Web缓存与服务器同步 将写操作立即写入磁盘以免导致错误 开放性 能够与其他开放系统的服务进行交互，不管底层的环境如何 系统应该定义良好的接口 系统应该支持应用的迁移 系统应该容易进行操作（interoperate） 至少使分布式系统独立于底层的运行环境 分布式操作系统、网络操作系统和基于中间件的系统。 // TODO 分布式系统的类型。 分布式计算系统：Distributed computing systems 集群计算：Cluster computing a group of high-end systems connected through a LAN Homogeneous: same OS, near-identical hardware 网格计算：Grid Computing lots of nodes from everywhere Heterogeneous Dispersed across several organizations Can easily span a wide-area network 云计算 分布式信息系统：Distributed information systems 当今使用最广泛的分布式系统是各种各样的传统信息系统 Example: 交易处理系统. 交易是在一组对象上进行的一系列操作，满足ACID： Atomicity Consistency Isolation Durability 通常，交易涉及的数据会分布在不同的服务器上。TP控制器用于管理交易的执行。 Distributed pervasive systems Emerging next-generation of distributed systems in which nodes are small, mobile, and often embedded in a larger system, characterized by the fact that the system naturally blends into the user’s environment. Ubiquitous computing systems Mobile computing systems Sensor (and actuator) networks 分布式系统架构 分布式系统架构风格 Centralized Basic Client–Server Model Characteristics: There are processes offering services (servers) There are processes that use services (clients) Clients and servers can be on different machines Clients follow request/reply model wrt to using services Multiple Clients/Single Server Web proxy server Web Applets Server forms bottleneck Server forms single point of failure System scaling difficult Multiple Clients/Multiple Servers Web proxy server Web Applets Application Layering Traditional three-layered view User-interface layer contains units for an application’s user interface Processing layer contains the functions of an application, i.e. without specific data Data layer contains the data that a client wants to manipulate through the application components This layering is found in many distributed information systems, using traditional database technology and accompanying applications. Multitiered Architectures (1) Single-tiered: dumb terminal/mainframe configuration Two-tiered: client/single server configuration Three-tiered: each layer on separate machine Decentralized Structured P2P: 节点按照特定的分布式数据结构进行组织，可以直接按照节点ID进行查找 Unstructured P2P: 节点随机的选择邻居，使用（有限/概率）洪泛法进行查找 Hybrid P2P: 某些节点（Superpeer）具有特定的功能 Hybrid Client-server combined with P2P Edge-server architectures, which are often used for Content Delivery Networks. 分布式系统组织形式 Multitiered Architectures (1) Single-tiered: dumb terminal/mainframe configuration Two-tiered: client/single server configuration Three-tiered: each layer on separate machine 客户-服务器模式和对等模式 分布式系统组织为中间件 Middleware In many cases, distributed systems/applications are developed according to a specific architectural style. The chosen style may not be optimal in all cases need to (dynamically) adapt the behavior of the middleware. Interceptors Intercept the usual flow of control when invoking a remote object. 进程与线程 进程和线程 Process: An execution stream in the context of a process state Execution stream • Stream of executing instructions • Running piece of code • Sequential sequence of instructions • “thread of control” Process state Everything that the running code can affect or be affected by Processes vs. Threads A process is different than a thread Thread: “Lightweight process” (LWP) An execution stream that shares an address space Multiple threads within a single process Example: Two processes examining memory address 0xffe84264 see different values (I.e., different contents) Two threads examining memory address 0xffe84264 see same value (I.e., same contents) 代码迁移 Approaches to code migration Migration and local resources Resource types Fixed: the resource cannot be migrated, such as local hardware Fastened: the resource can, in principle, be migrated but only at high cost Unattached: the resource can easily be moved along with the object (e.g. a cache) Object-to-resource binding By identifier: the object requires a specific instance of a resource (e.g. a specific database) By value: the object requires the value of a resource (e.g. the set of cache entries) By type: the object requires that only a type of resource is available (e.g. a color monitor) Migration in heterogeneous systems Main problem The target machine may not be suitable to execute the migrated code The definition of process/thread/processor context is highly dependent on local hardware, operating system and runtime system Make use of an abstract machine that is implemented on different platforms Interpreted languages, effectively having their own VM Virtual VM (as discussed previously) 强迁移vs.弱迁移 Strong and weak mobility Code segment: contains the actual code Data segment: contains the state Execution state: contains context of thread executing the object’s code Move only code and data segment (and reboot execution): Relatively simple, especially if code is portable Distinguish code shipping (push) from code fetching (pull) Move component, including execution state Migration: move entire object from one machine to the other Cloning: start a clone, and set it in the same execution state 通信 通信的类型 Transient vs. persistent communication Transient communication: Comm. server discards message when it cannot be delivered at the next server, or at the receiver. Persistent communication: A message is stored at a communication server as long as it takes to deliver it. Asynchrounous vs. synchronous communication At request submission At request delivery After request processing Client/Server Client/Server computing is generally based on a model of transient synchronous communication: Client and server have to be active at time of communication Client issues request and blocks until it receives reply Server essentially waits only for incoming requests, and subsequently processes them Drawbacks of synchronous communication Client cannot do any other work while waiting for reply Failures have to be handled immediately: the client is waiting The model may simply not be appropriate (mail, news) Messaging Aims at high-level persistent asynchronous communication: Processes send each other messages, which are queued Sender need not wait for immediate reply, but can do other things Middleware often ensures fault tolerance 远程过程调用RPC RPC的工作过程 Observations Application developers are familiar with simple procedure model Well-engineered procedures operate in isolation (black box) There is no fundamental reason not to execute procedures on separate machine Communication between caller &amp; callee can be hidden by using procedurecall mechanism. 参数传递 There’s more than just wrapping parameters into a message: Client and server machines may have different data representations (think of byte ordering) Wrapping a parameter means transforming a value into a sequence of bytes Client and server have to agree on the same encoding: How are basic data values represented (integers, floats, characters) How are complex data values represented (arrays, unions) Client and server need to properly interpret messages, transforming them into machine-dependent representations. Some assumptions: Copy in/copy out semantics: while procedure is executed, nothing can be assumed about parameter values. All data that is to be operated on is passed by parameters. Excludes passing references to (global) data. Full access transparency cannot be realized. A remote reference mechanism enhances access transparency: Remote reference offers unified access to remote data Remote references can be passed as parameter in RPCs 故障处理 // TODO 客户端无法定位到服务器 服务器下线、服务器与客户端版本不一致 使用特定的符号作为RPC的返回值 抛出一个异常或者信号 请求信息丢失 发送信息时使用计时器 计时器到期则重传 多次丢失：认为服务器下线，转到&quot;无法定位到服务器&quot; 响应信息丢失 发送信息时使用计时器 使用序列号编码请求信息，以免导致多次运行 服务器崩溃 等待服务器重启，重新操作，保证RPC至少被运行一次 立刻放弃并报告错误，保证RPC至多被运行一次 什么都不做，不保证任何情况 客户端崩溃 使用日志记录每个RPC 按时间进行分片 为每个RPC记录一个过期时间 动态绑定 To register, the server gives the binder its name, its version number, a unique identifier (32-bits), and a handle used to locate it The handle is system dependent (e.g., Ethernet address, IP address, an X.500 address, …) When the client calls one of the remote procedures for the first time, say, read: The client stub sees that it is not yet bound to a server, so it sends a message to the binder asking to import version x of server interface The binder checks to see if one or more servers have already exported an interface with this name and version number. If no currently running server is willing to support this interface, the read call fails If a suitable server exists, the binder gives its handle and unique identifier to the client stub Advantages of Dynamic Binding Flexibility Can support multiple servers that support the same interface, e.g.: Binder can spread the clients randomly over the servers to even load Binder can poll the servers periodically, automatically deregistering the servers that fail to respond, to achieve a degree of fault tolerance Binder can assist in authentication: For example, a server specifies a list of users that can use it; the binder will refuse to tell users not on the list about the server The binder can verify that both client and server are using the same version of the interface Disadvantages of Dynamic Binding The extra overhead of exporting/importing interfaces costs time The binder may become a bottleneck in a large distributed system 基于消息的通信 Lower-level interface to provide more flexibility Two (abstract) primitives are used to implement these Send Receive Issues: Are primitives blocking or nonblocking (synchronous or asynchronous)? Are primitives reliable or unreliable (persistent or transient)? 持久性/非持久性 Transient The sender puts the message on the net and if it cannot be delivered to the sender or to the next communication host, it is lost. There can be different types depending on whether it is asynchronous or synchronous Persistent The message is stored in the communication system as long as it takes to deliver the message to the receiver 同步/异步 Synchronous The sender is blocked until its message is stored in the local buffer at the receiving host or delivered to the receiver. Asynchronous The sender continues immediately after executing a send The message is stored in the local buffer at the sending host or at the first communication server. 流数据 A (continuous) data stream is a connection-oriented communication facility that supports isochronous data transmission. Some common stream characteristics Streams are unidirectional There is generally a single source, and one or more sinks Often, either the sink and/or source is a wrapper around hardware(e.g., camera, CD device, TV monitor) Simple stream: a single flow of data, e.g., audio or video Complex stream: multiple data flows, e.g., stereo audio or combination audio/video 同步与资源管理 同步问题 How processes cooperate and synchronize with one another in a distributed system In single CPU systems, critical regions, mutual exclusion, and other synchronization problems are solved using methods such as semaphores. These methods will not work in distributed systems because they implicitly rely on the existence of shared memory. If two events occur in a distributed system, it is difficult to determine which event occurred first. How to decide on relative ordering of events Does one event precede another event? Difficult to determine if events occur on different machines. 时钟同步机制 In a centralized system: Time is unambiguous: A process gets the time by issuing a system call to the kernel. If process A gets the time and latter process B gets the time. The value B gets is higher than (or possibly equal to) the value A got 逻辑时钟 How do we maintain a global view on the system’s behavior that is consistent with the happened-before relation? Attach a timestamp C(e) to each event e, satisfying the following properties: P1: If a and b are two events in the same process, and a!=b, then we demand that C 𝑎𝑎 &lt; 𝐶𝐶(𝑏𝑏). P2: If a corresponds to sending a message m, and b to the receipt of that message, then also C 𝑎𝑎 &lt; 𝐶𝐶(𝑏𝑏). How to attach a timestamp to an event when there’s no global clock ⇒ maintain a consistent set of logical clocks, one per process. Logical vs Physical Clocks Clock synchronization need not be absolute! (due to Lamport, 1978): If two processes do not interact, their clocks need not be synchronized. What matters is not that all processes agree on exactly what time is it, but rather, that they agree on the order in which events occur. For algorithms where only internal consistency of clocks matters (not whether clocks are close to real time), we speak of logical clocks. For algorithms where clocks must not only be the same, but also must not deviate from real-time, we speak of physical clocks. Lamport算法 Each process 𝑃𝑃𝑖𝑖 maintains a local counter 𝐶𝐶𝑖𝑖 and adjusts this counter according to the following rules: For any two successive events that take place within PiP_iPi​ , CiC_iCi​ is incremented by 1. Each time a message m is sent by process PiP_iPi​ , the message receives a timestamp ts(m)=Cits(m)=C_its(m)=Ci​ . Whenever a message m is received by a process PjP_jPj​ , PjP_jPj​ adjusts its local counter CjC_jCj​ to maxCj,ts(m)max{C_j, ts(m)}maxCj​,ts(m); then executes step 1 before passing m to the application. Property P1 is satisfied by (1); Property P2 by (2) and (3). It can still occur that two events happen at the same time. Avoid this by breaking ties through process IDs. 向量时戳 分布式系统中的互斥访问 Basic solutions Via a centralized server. Completely decentralized, using a peer-to-peer system. Completely distributed, with no topology imposed. Completely distributed along a (logical) ring. 分布式系统中的选举机制 复制与一致性 复制的优势与不足 Why replicate? Reliability Avoid single points of failure Performance Scalability in numbers and geographic area Why not replicate? Replication transparency Consistency issues Updates are costly Availability may suffer if not careful 数据一致性模型 Client-Centric Consistency More relaxed form of consistency only concerned with replicas being eventually consistent (eventual consistency). In the absence of any further updates, all replicas converge to identical copies of each other -&gt;only requires guarantees that updates will be propagated. Easy if a user always accesses the same replica; problematic if the user accesses different replicas. Client-centric consistency: guarantees for a single client the consistency of access to a data store. 数据一致性协议实例 Linearizability Primary-Backup Chain Replication Sequential consistency Primary-based protocols Remote-Write protocols Local-Write protocols Replicated Write protocols Active replication Quorum-based protocols 基于法定数量的协议 容错 可信系统(DependableSystem)特征 可靠性：Reliability 系统的表现符合预期设定 系统在给定时间内不出现任何故障的概率 Typically used to describe systems that cannot be repaired or where the continuous operation of the system is critical. 可用性：Availability The fraction of the time that a system meets its specification. The probability that the system is operational at a given time t. 安全性：Safety 当系统暂时地偏离了预期设定, 也不会造成较大事故 可维护性：Maintainability 用于衡量系统维护是否困难 提高系统可信性的途径 通过冗余掩饰系统异常 冗余信息 通过附加额外的比特检测和恢复传输错误 冗余时间 当一个交易中止后, 在不会造成负面影响的情况下重新执行它 Physical redundancy 硬件冗余 使用多个服务器降低服务器失效风险 软件冗余 通过相同的方式多次运行 冗余处理 处理组: 所有的成员可以相互接替工作, 动态调整, 扁平化的结构 K容错系统 K 容错系统需要的备份数: Fail-silent faults : K+1 Byzantine faults : 2K+1 : majority 组的结构: flat/hierarchical Need for managing groups and group membership centralized: group server distributed: totally-ordered reliable multicast 拜占庭问题（Byzantine Problem） Algorithm to reach agreement. They perform the following : step 1: every general sends a message to every other general telling his strength ( true or lie) step 2: each general collects received messages to form a vector step 3: every general passes his vector to every other general step 4: each general examines the ith element of each of the newly received vectors. If any value has a majority, that value is put into the result vector 系统恢复 回退恢复 前向恢复 检查点（Check point）","link":"/p/7af16b6e/"},{"title":"查找-排序算法","text":"DS中的查找与排序算法 查找 二分查找 123456789101112131415int binarySearch(int l[], int n, int key){ int low = 0, high = n - 1, mid; while (low &lt;= high) { mid = (low + high) / 2; if (l[mid] == key) return mid; else if (l[mid] &gt; key) high = mid - 1; else low = mid + 1; } return -1;} 排序 插入排序 时间复杂度 最好: O(n)O(n)O(n) 平均: O(n2)O(n^2)O(n2) 最差: O(n2)O(n^2)O(n2) 空间复杂度: O(1)O(1)O(1) 稳定性: 是 1234567891011121314void insertSort(int A[], int n){ for (int i = 2; i &lt; n; i++) { if (A[i] &lt; A[i - 1]) { A[0] = A[i]; int j; for (j = i - 1; A[0] &lt; A[j]; j++) A[j + 1] = A[j]; A[j + 1] = A[0]; } }} 冒泡排序 时间复杂度 最好: O(n)O(n)O(n) 平均: O(n2)O(n^2)O(n2) 最差: O(n2)O(n^2)O(n2) 空间复杂度: O(1)O(1)O(1) 稳定性: 是 1234567891011121314151617void bubbleSort(int A[], int n){ for (int i = 0; i &lt; n - 1; i++) { bool flag = false; for (int j = n - 1; j &gt; i; j--) if (A[j - 1] &gt; A[j]) { int t = A[j - 1]; A[j - 1] = A[j]; A[j] = t; flag = true; } if (flag == false) return; }} 选择排序 时间复杂度 最好: O(n2)O(n^2)O(n2) 平均: O(n2)O(n^2)O(n2) 最差: O(n2)O(n^2)O(n2) 空间复杂度: O(1)O(1)O(1) 稳定性: 否 12345678910111213141516void selectSort(int A[], int n){ for (int i = 0; i &lt; n - 1; i++) { int min = i; for (int j = i + 1; j &lt; n; j++) if (A[j] &lt; A[min]) min = j; if (min != i) { int t = A[i]; A[i] = A[min]; A[min] = t; } }} 快速排序 时间复杂度 最好: O(nlog⁡2n)O(n\\log_2n)O(nlog2​n) 平均: O(nlog⁡2n)O(n\\log_2n)O(nlog2​n) 最差: O(n2)O(n^2)O(n2) 空间复杂度: O(log⁡2n)O(\\log_2n)O(log2​n) 稳定性: 否 123456789101112131415int partition(int A[], int low, int high){ int pivot = A[low]; while (low &lt; high) { while (low &lt; high &amp;&amp; A[high] &gt;= pivot) high--; A[low] = A[high]; while (low &lt; high &amp;&amp; A[low &lt;= pivot]) low++; A[high] = A[low]; } A[low] = pivot; return low;} 123456789void quickSort(int A[], int low, int high){ if (low &lt; high) { int pivotpos = partition(A, low, high); quickSort(A, low, pivotpos - 1); quickSort(A, pivotpos + 1, high); }} 堆排序 时间复杂度 最好: O(nlog⁡2n)O(n\\log_2n)O(nlog2​n) 平均: O(nlog⁡2n)O(n\\log_2n)O(nlog2​n) 最差: O(nlog⁡2n)O(n\\log_2n)O(nlog2​n) 空间复杂度: O(1)O(1)O(1) 稳定性: 否 1234567891011121314151617void adjustDown(int A[], int k, int n){ A[0] = A[k]; for (int i = 2 * k; i &lt;= n; i *= 2) { if (i &lt; n &amp;&amp; A[i] &lt; A[i + 1]) i++; if (A[0] &gt;= A[i]) break; else { A[k] = A[i]; k = i; } } A[k] = A[0];} 123456789101112void adjustUp(int A[], int k){ A[0] = A[k]; int i = k / 2; while (i &gt; 0 &amp;&amp; A[i] &gt; A[0]) { A[k] = A[i]; k = i; i = k / 2; } A[k] = A[0];} 1234567void buildMaxHeap(int A[], int n){ for (int i = n / 2; i &gt; 0; i--) { adjustDown(A, i, n); }} 1234567891011void heapSort(int A[], int n){ buildMaxHeap(A, n); for (int i = n; i &gt; 1; i--) { int t = A[i]; A[i] = A[1]; A[1] = t; adjustDown(A, 1, i - 1); }} 归并排序 时间复杂度 最好: O(nlog⁡2n)O(n\\log_2n)O(nlog2​n) 平均: O(nlog⁡2n)O(n\\log_2n)O(nlog2​n) 最差: O(nlog⁡2n)O(n\\log_2n)O(nlog2​n) 空间复杂度: O(n)O(n)O(n) 稳定性: 是 123456789101112131415161718void merge(int A[], int low, int mid, int high){ int B[high + 1]; for (int k = low; k &lt;= high; k++) B[k] = A[k]; int i, j, k; for (i = low, j = mid + 1, k = i; i &lt;= mid &amp;&amp; j &lt;= high; k++) { if (B[i] &lt;= B[j]) A[k] = B[i++]; else A[k] = B[j++]; } while (i &lt;= mid) A[k++] = B[i++]; while (j &lt;= high) A[k++] = B[j++];} 12345678910void mergeSort(int A[], int low, int high){ if (low &lt; high) { int mid = (low + high) / 2; mergeSort(A, low, mid); mergeSort(A, mid + 1, high); merge(A, low, mid, high); }}","link":"/p/b1402186/"},{"title":"计算机系统基础","text":"ICS 中的基本运算和概念 计算机系统概述 计算机的发展 1946年，第1台通用电子计算机 ENIAC诞⽣生 由电子真空管组成 电子管计算机 晶体管 SSI, MSI, LSI, VLSI, ULSI 冯.诺依曼计算机结构 计算机由运算器, 控制器, 存储器, 输入设备, 输出设备组成 指令和数据用二进制表示, 形式上没有差别, 通过CPU访问阶段进行区别 指令和数据存储在存储器中, 按地址访问 指令由 操作码和地址码组成, 操作码指定操作性质, 地址码指定操作数地址 采用 “存储程序” 方式进行工作 计算机系统抽象层的转换 高级语言虚拟机 - 汇编语言虚拟机 - 操作系统虚拟机 - 机器语言机器 程序开发与执行过程 从一个程序的编写到完成程序的执行整个过程简述如下： 通过本文编辑软件编写源程序文件（如hello.c） 然后使用语言处理工具，对源程序文件进行预处理、编译、汇编和链接，最终生成可执行目标文件。 通过双击程序图标或在命令行中输入命令等方式，启动可执行目标文件执行。 每一个可执行文件的执行都采用&quot;存储程序”工作方式。一旦程序被启动就会装入主存，CPU从主存储器中取出指令，并对指令译码，根据译码结果控制数据的运算、传送或存储，每条指令执行完后，CPU能自动控制执行下一条指令或跳转到某一条指令处执行，当可执行文件中包含的所有指令都执行结束，则程序执行结束。 性能参数 时钟周期 = 时钟频率的倒数 CPI MIPS 峰值MIPS 平均每秒执行多少百万条整数运算指令 MFLOPS 百万次浮点运算 GFLOPS TFLOPS 执行时间 数据的机器级表示与处理 整数 加减运算 原码 -&gt; 变成绝对值的运算 补码 -&gt; [X]=2n+X[X] = 2^n + X[X]=2n+X 加法直接相加, 减法中, 被减数取反加 1 再相加 C中的整数 类型转换: 带符号数 -&gt; 无符号数 常用数据: 2147483647=231−12147483647 = 2^{31} - 12147483647=231−1 2147483648=2312147483648 = 2^{31}2147483648=231 在 ISO C90 下, 2147483648 为 **unsigned int**型 溢出判断 对于补码而言, 在进行加法时, 如果两个数的最高位不同, 不会发生溢出. 否则, 如果 运算结果的最高位与加数的最高位不同 最高位进位与次高位进位的异或为 1 则发生了溢出. 比较判断 关系 无符号数 有符号数 等于 ZFZFZF ZFZFZF 大于 CF+ZF‾\\overline{CF+ZF}CF+ZF​ ZF‾⋅(SF⨁OF)‾\\overline{ZF}\\cdot\\overline{(SF \\bigoplus OF)}ZF⋅(SF⨁OF)​ 小于 CF⋅ZF‾CF\\cdot\\overline{ZF}CF⋅ZF ZF‾⋅(SF⨁OF)\\overline{ZF} \\cdot(SF \\bigoplus OF)ZF⋅(SF⨁OF) 大于等于 CF‾+ZF\\overline{CF}+ZFCF+ZF ZF+(SF⨁OF)‾ZF+\\overline{(SF \\bigoplus OF)}ZF+(SF⨁OF)​ 小于等于 CF+ZFCF+ZFCF+ZF ZF+(SF⨁OF)ZF+(SF \\bigoplus OF)ZF+(SF⨁OF) 无符号数情况 等于: 相减后结果为零 大于: 没有借位且相减后不为0 小于: 有借位且相减后不为0 大于等于: 没有借位或相减后结果为0 小于等于: 有借位或相减后结果为0 带符号整数情况 等于: 相减后结果为零 大于: 相减后结果不为0，并且，不溢出时为正，溢出时为负。 小于: 相减后结果不为0，并且，不溢出时为负，溢出时为正。 大于等于: 相减后结果为0，或者，不溢出时为正，溢出时为负。 小于等于: 相减后结果为0，或者，不溢出时为负，溢出时为正。 浮点数 IEEE 754 标准 单精度 1S EEEE EEEE MMM MMMM MMMM MMMM MMMM MMMM 1 位符号位 8 位阶码 (移码) 23 位尾数 (原码) 阶码的偏置常数为 127 尾数最高位默认为 1 程序的转换及机器级表示 ISA ISA 定义了机器语言级虚拟机的属性和功能特性 可执行的指令的集合 指令可以接受的操作数的类型 操作数所能存放的寄存器组的结构 操作数所能存放的存储空间的大小和编址方式 操作数在存储空间存放时按照大端方式还是小端方式存放 指令获取操作数的方式，即寻址方式； 指令执行过程的控制方式，包括程序计数器、条件码定义等。 生成机器代码 这个转换过程分为以下4个步骤。 预处理。例如，在C语言源程序中有一些以＃开头的语句，可以在预处理阶段对这些语句进行处理，在源程序中插入所有用 #include 命令指定的文件和用 #define 声明指定的宏。 编译。将预处理后的源程序文件编译生成相应的汇编语言程序。 汇编。由汇编程序将汇编语言源程序文件转换为可重定位的机器语言目标代码文件。 链接。由链接器将多个可重定位的机器语言目标文件以及库例程（如 printf() 库函数）链接起来，生成最终的可执行文件。 ADD 程序示例 123456// test.cint add(int i, int j){ int x = i + j; return x;} 123456789101112add: pushl %ebp movl %esp, %ebp subl $16, %esp movl 8(%ebp), %edx movl 12(%ebp), %eax # leal (%edx, %eax), %eax addl %edx, %eax movl %eax, -4(%ebp) movl -4(%ebp), %eax leave ret 12345678910111213# test.o: file format elf32-i38600000000 &lt;add&gt;: 0: 55 push %ebp 1: 89 e5 mov %esp,%ebp 3: 83 ec 10 sub $0x10,%esp 6: 8b 55 08 mov 0x8(%ebp),%edx 9: 8b 45 0c mov 0xc(%ebp),%eax c: 01 d0 add %edx,%eax e: 89 45 fc mov %eax,-0x4(%ebp) 11: 8b 45 fc mov -0x4(%ebp),%eax 14: c9 leave 15: c3 ret 对于test.o文件 目标代码从相对地址0开始 机器指令的长度不同, 即为变长指令字结构 可执行文件中: 12345678910111213141508048403 &lt;add&gt;: 8048403: 55 push %ebp 8048404: 89 e5 mov %esp,%ebp 8048406: 83 ec 10 sub $0x10,%esp 8048409: 8b 55 08 mov 0x8(%ebp),%edx 804840c: 8b 45 0c mov 0xc(%ebp),%eax 804840f: 01 d0 add %edx,%eax 8048411: 89 45 fc mov %eax,-0x4(%ebp) 8048414: 8b 45 fc mov -0x4(%ebp),%eax 8048417: c9 leave 8048418: c3 ret 8048419: 66 90 xchg %ax,%ax 804841b: 66 90 xchg %ax,%ax 804841d: 66 90 xchg %ax,%ax 804841f: 90 nop IA32 指令 数据类型与寄存器 x87 浮点寄存器中含有专用的状态寄存器, 8个浮点寄存器 mov 传送指令 算术运算指令 乘法运算 1个操作数 SRC : 另一个操作数隐含在 AL / AX / EAX 中, 结果存放在 AX / DX-AX / EDX-EAX 2个操作数 DST, SRC : DST * SRC -&gt; DST 3个操作数 REG, SRC, IMM : SRC * IMM -&gt; REG 除法运算 1个操作数 SRC : 另一个操作数隐含在 AL / AX / EAX 中 被除数的位数为除数的2倍 16 / 8 : 商: AL 余数: AH 32 / 16 : 商: AX 余数: DX 64 / 32 : 商: EAX 余数: EDX 移位运算 逻辑: SHL SHR 算术: SAL SAR 循环: ROL ROR RCL RCR 控制转移指令 C语言程序的机器级表示 过程调用的执行步骤 假定过程P调用过程Q, 则P称为调用者， Q称为被调用者。 P将入口参数(实参)放到Q能访问到的地方。 P将返回地址存到特定的地方，然后将控制转移到Q。(CALL) Q保存P的现场，并为自己的非静态局部变量分配空间。 执行Q的过程体(函数体)。 Q恢复P的现场，并释放局部变量所占空间。 Q取出返回地址，将控制转移到P。(RET) 寄存器使用约定 寄存器EAX 、ECX 、EDX 是调用者保存寄存器 寄存器EBX 、ESI 、EDI 是被调用者保存寄存器 栈与栈帧 C语句的汇编形式 if 选择语句 12345// if if (cond_expr) then_statementelse else_statement 汇编格式 12345678 c=cond_expr; if(!c) goto false_label; then_statement goto done;false_label: else_statementdone: 12345678 c=cond_expr; if(c) goto true_label; else_statement goto done;true_label: then_statementdone: switch do - while 1234do{ loop_body_statement} while (cond_expr) ; 1234loop: loop_body_statement c = cond_expr ; if (c) goto loop ; while 12while (cond_expr) loop_body_statement 1234567 c = cond_expr; if (!c) goto done;loop: loop_body_statement c = conct_expr; if (c) goto loop;done: for 12for (begin_expr; cond_expr; update_expr) loop_body_statement 123456789 begin_expr ; c = conct_expr; if (!c) goto done ;loop: loop_body_statement update_expr; c = cond_expr; if (c) goto loop ;done: 数据对齐 Windows : 按其长度对齐 IA32 : short : 2 int float double char* : 4 double : 80位, 分配12字节(96位)","link":"/p/a153319c/"},{"title":"西瓜书第一章","text":"第一章 绪论 基本概念 学习算法：假设用 P 来估计计算机程序在某任务 T 上的性能，若一个程序通过利用经验 E 在 T 任务上获得了性能改善，则我们就说关于 T 和 P，该程序对 E 进行了学习。 模型：本书中泛指从数据中学得的结果 示例（instance）或样本（sample）：关于一个事件或对象的描述，也可称为特征向量 样例（example）：拥有标记信息的示例 属性（attribute）或特征（feature）：反映事件或对象在某方面的表现或性质，其值为属性值 数据集（data set）：记录的集合，每条记录都是一个示例或样本 属性空间、样本空间、输入空间：属性张成的空间 标记空间、输出空间：所有标记的集合 监督学习：预测离散值：分类（二分类（正类、反类）、多分类）；预测连续值：回归 无监督学习：聚类（clustering）：将训练集（无标记）中的样本自动分为若干组，每组称为一个簇（cluster） 泛化（generalization）能力：学得模型适用于新样本的能力 假设空间 若“好瓜”仅由“色泽”、“根蒂”、“敲声”完全确定：“ $好瓜 ⟷\\longleftrightarrow⟷ (色泽=?) ⋀\\bigwedge⋀ (根蒂=?) ⋀\\bigwedge⋀ (敲声=?) ” 我们可以把学习过程看做在一个所有假设组成的空间内进行搜索的过程，搜索目标是寻找与训练集匹配(fit)的假设。 这样，若色泽、根蒂、敲声分别有3，3，3种可能取值，再考虑可以取任意值(*)，则假设空间的规模即为 4*4*4+1=65 对假设空间进行搜索，搜索过程中不断删除与正例不一致、与反例一致的假设，最终即可得到与训练集一致的假设，可能会包含多个假设，称之为版本空间 版本空间从假设空间剔除了与正例不一致和与反例一致的假设，它可以看成是对正例的最大泛化。 归纳偏好 机器学习算法再学习过程中对某种类型假设的偏好，称之为归纳偏好 任何一种机器学习算法必有其归纳偏好，否则它将被假设空间内看似“等效”的假设所迷惑，而无法产生确定的结果。 奥卡姆剃刀（Occam’s razor）是一种常用的、自然科学研究最基本的原则：若有多个假设与观察一致，则选择最简单的那个 没有免费的午餐（NFL定理：No Free Lunch Theorem）：在所有问题出现的概率相等、所有问题同等重要的情况下，任何一种算法的总误差与学习算法无关。 证明： 假设样本空间 χ\\chiχ 和假设空间 HHH 都是离散的. 令 P(h∣X,La)P(h|X,L_a)P(h∣X,La​) 代表算法 LaL_aLa​ 基于训练数据 X 产生假设 h 的概率, 再令 fff 表示希望学到的真实目标函数. 则 LaL_aLa​ 的训练集外误差, 即 LaL_aLa​ 在训练集外的所有样本上的误差为:(∏(.)\\prod(.)∏(.) 是指示函数) Eote(La∣X,f)=∑h∑x∈χ−XP(x)∏(h(x)≠f(x))P(h∣X,La)E_{ote}(L_a|X,f) = \\sum_{h}\\sum_{x\\in\\chi-X}{P(x)\\prod(h(x)\\neq f(x))P(h|X, L_a)} Eote​(La​∣X,f)=h∑​x∈χ−X∑​P(x)∏(h(x)=f(x))P(h∣X,La​) 考虑二分类问题, 且真实目标函数可以是任何函数 χ→{0,1}\\chi \\rightarrow {\\lbrace0,1\\rbrace}χ→{0,1}, 函数空间为 {0,1}∣χ∣{\\lbrace0,1\\rbrace}^{|\\chi|}{0,1}∣χ∣ 对所有可能的 fff 按均匀分布对误差求和: ∑fEote(La∣X,f)=∑f∑h∑x∈χ−XP(x)∏(h(x)≠f(x))P(h∣X,La)=∑x∈χ−XP(x)∑hP(h∣X,La)∑f∏(h(x)≠f(x))=∑x∈χ−XP(x)∑hP(h∣X,La)122∣χ∣=122∣χ∣∑x∈χ−XP(x)∑hP(h∣X,La)=2∣χ∣−1∑x∈χ−XP(x)\\begin{aligned} \\sum_fE_{ote}(L_a|X,f)&amp;=\\sum_f\\sum_h\\sum_{x\\in\\chi-X}P(x)\\prod(h(x)\\neq f(x))P(h|X,L_a)\\\\ &amp;=\\sum_{x\\in\\chi-X}P(x)\\sum_hP(h|X,L_a)\\sum_f\\prod(h(x)\\neq f(x))\\\\ &amp;=\\sum_{x\\in\\chi-X}P(x)\\sum_hP(h|X,L_a)\\frac{1}{2}2^{|\\chi|}\\\\ &amp;=\\frac{1}{2}2^{|\\chi|}\\sum_{x\\in\\chi-X}P(x)\\sum_hP(h|X,L_a)\\\\ &amp;=2^{|\\chi|-1}\\sum_{x\\in\\chi-X}P(x) \\end{aligned}f∑​Eote​(La​∣X,f)​=f∑​h∑​x∈χ−X∑​P(x)∏(h(x)=f(x))P(h∣X,La​)=x∈χ−X∑​P(x)h∑​P(h∣X,La​)f∑​∏(h(x)=f(x))=x∈χ−X∑​P(x)h∑​P(h∣X,La​)21​2∣χ∣=21​2∣χ∣x∈χ−X∑​P(x)h∑​P(h∣X,La​)=2∣χ∣−1x∈χ−X∑​P(x)​ 也即,学习算法的总误差与学习算法无关 但是现实生活中的问题并非如此，因此必须结合具体的学习问题，设计相应的算法。 要讨论学习算法的相对优劣，必须针对具体的学习问题，学习算法自身的归纳偏好与问题是否相配，往往会起到决定性的作用。 习题 答案解析部分转载自CSDN博主「四去六进一」的原创文章：参考答案总目录， 第一章答案， 第一章第二题答案 习题 1.1 表 1.1 中若只包含编号为1,4的两个样例，试给出相应的版本空间 编号 色泽 根蒂 敲声 好瓜 1 青绿 蜷缩 浊响 是 4 乌黑 稍蜷 沉闷 否 数据集有3个属性，每个属性2种取值，一共 3∗3∗3+1=283∗3∗3+1=28种假设，分别为 色泽=青绿 根蒂=蜷缩 敲声=浊响 色泽=青绿 根蒂=蜷缩 敲声=沉闷 色泽=青绿 根蒂=稍蜷 敲声=浊响 色泽=青绿 根蒂=稍蜷 敲声=沉闷 色泽=乌黑 根蒂=蜷缩 敲声=浊响 色泽=乌黑 根蒂=蜷缩 敲声=沉闷 色泽=乌黑 根蒂=稍蜷 敲声=浊响 色泽=乌黑 根蒂=稍蜷 敲声=沉闷 色泽=青绿 根蒂=蜷缩 敲声=* 色泽=青绿 根蒂=稍蜷 敲声=* 色泽=乌黑 根蒂=蜷缩 敲声=* 色泽=乌黑 根蒂=稍蜷 敲声=* 色泽=青绿 根蒂=* 敲声=浊响 色泽=青绿 根蒂=* 敲声=沉闷 色泽=乌黑 根蒂=* 敲声=浊响 色泽=乌黑 根蒂=* 敲声=沉闷 色泽=* 根蒂=蜷缩 敲声=浊响 色泽=* 根蒂=蜷缩 敲声=沉闷 色泽=* 根蒂=稍蜷 敲声=浊响 色泽=* 根蒂=稍蜷 敲声=沉闷 色泽=青绿 根蒂=* 敲声=* 色泽=乌黑 根蒂=* 敲声=* 色泽=* 根蒂=蜷缩 敲声=* 色泽=* 根蒂=稍蜷 敲声=* 色泽=* 根蒂=* 敲声=浊响 色泽=* 根蒂=* 敲声=沉闷 色泽=* 根蒂=* 敲声=* 空集Ø 编号1的数据可以删除 2−8，10−12，14−16，18−20，22，24，26，282−8，10−12，14−16，18−20，22，24，26，28(不包含数据1) 编号1的数据可以删除 2 7 27(包含了数据2) 所以版本空间为: 1.色泽=青绿 根蒂=蜷缩 敲声=浊响 9.色泽=青绿 根蒂=蜷缩 敲声=* 13.色泽=青绿 根蒂=* 敲声=浊响 17.色泽=* 根蒂=蜷缩 敲声=浊响 21.色泽=青绿 根蒂=* 敲声=* 23.色泽=* 根蒂=蜷缩 敲声=* 25.色泽=* 根蒂=* 敲声=浊响 一般情况下版本空间是正例的泛化，但由于数据集中只有1个正例，所以在版本空间中依然包含了这个样本的假设(假设1)。","link":"/p/5c7cc0d4/"},{"title":"西瓜书第10章：降维与度量学习","text":"K 近邻学习 (k-Nearest Neighbor, kNN) K 近邻学习器是懒惰学习(lazy learning) 的代表，基本思路是近朱者赤，近墨者黑 与懒惰学习相反的是急切学习（eager learning），二者的差别在于在训练阶段是否对样本进行学习 主要需要注意两个方面： K 值的选取 距离的计算 最近邻学习器的误差分析 给定测试样本 xxx，若其最近样本为 zzz，则最邻近分类器出错的概率就是 xxx 与 zzz 类别标记不同的概率，即 P(err)=1−∑c∈YP(c∣x)P(c∣z)P(err) = 1 - \\sum_{c\\in \\mathcal{Y}}P(c|\\boldsymbol{x})P(c|\\boldsymbol{z}) P(err)=1−c∈Y∑​P(c∣x)P(c∣z) 假设样本独立同分布，令 c⋆=arg maxc∈YP(c∣x)c^\\star=arg\\ max_{c\\in \\mathcal{Y}} P(c|\\boldsymbol{x})c⋆=arg maxc∈Y​P(c∣x) 表示贝叶斯最优分类器的结果，则有： P(err)=1−∑c∈YP(c∣x)P(c∣z)≃1−∑c∈YP2(c∣x)≤1−P2(c⋆∣x)≤(1+P(c⋆∣x))(1−P(c⋆∣x))≤2×(1−P(c⋆∣x))\\begin{aligned} P(err) &amp;= 1-\\sum_{c\\in \\mathcal{Y}}P(c|\\boldsymbol{x})P(c|\\boldsymbol{z})\\\\ &amp;\\simeq 1-\\sum_{c\\in \\mathcal{Y}}P^2(c|\\boldsymbol{x})\\\\ &amp;\\leq 1-P^2(c^\\star|\\boldsymbol{x})\\\\ &amp;\\leq (1 + P(c^\\star | \\boldsymbol{x}) ) (1 - P(c^\\star | \\boldsymbol{x}) )\\\\ &amp;\\leq 2 \\times (1 - P(c^\\star|\\boldsymbol{x})) \\end{aligned} P(err)​=1−c∈Y∑​P(c∣x)P(c∣z)≃1−c∈Y∑​P2(c∣x)≤1−P2(c⋆∣x)≤(1+P(c⋆∣x))(1−P(c⋆∣x))≤2×(1−P(c⋆∣x))​ 也即：最邻近分类器的泛化误差不会超过贝叶斯最优分类器的两倍！ 维数问题 上述结论是基于一个重要假设：任意测试样本 x\\boldsymbol{x}x 附近任意小的 δ\\deltaδ 距离范围内总能找到一个训练样本，即训练样本的采样密度足够大，或称为“密采样”（dense sample） 然而这在现实中很难实现！ 但维数为 1 时，若考虑 δ=0.001\\delta=0.001δ=0.001，则需要 1000 个样本；若属性更多，如属性维数为 20，则需要(103)20=1060(10^3)^{20}=10^{60}(103)20=1060 个样本！同样，对于一张并不是很清晰的图像：70余万维，我们为了找到恰当的近邻，需要多少样本？ 另外一方面，高维空间给距离计算带来很大的麻烦，当维数很高时甚至连计算内积都不再容易！ 事实上，在高位情况下出现的数据样本稀疏、距离计算困难等问题，是所有机器学习算法共同面临的严重障碍，被称为 “维数灾难” 降维 缓解维数灾难的一个重要途径是降维，亦称“维数约简”（dimension reduction） 即：通过某种数学变换将原始高维属性空间转变为一个低维子空间，在这个子空间中样本密度大幅提高，距离计算也变得更为容易。 为什么能进行降维？ 数据样本虽是高维的，但与学习任务密切相关的也许仅是某个低维分布，即高维空间中的一个低维“嵌入” (embedding) 多维缩放方法（MDS） 如果要求原始空间中样本之间的距离在低维空间中得以保持，即为：多维缩放（Multiple Dimensional Scaling） 如何在距离矩阵和内积矩阵之间建立联系？ 假定 m 个样本在原始空间的距离矩阵为 D∈Rm×mD \\in \\mathbb{R}^{m \\times m}D∈Rm×m，其 distijdist_{ij}distij​ 为样本 xi\\boldsymbol{x}_ixi​ 到 xj\\boldsymbol{x}_jxj​ 的距离。 目标为获得样本在 d′d'd′ 维空间的表示 Z∈Rd′×m,d′≤dZ \\in \\mathbb{R}^{d' \\times m}, d' \\leq dZ∈Rd′×m,d′≤d，且这两种表示下的距离不变，即有：∥zi−zj∥=distij\\Vert\\boldsymbol{z}_i - \\boldsymbol{z}_j\\Vert=dist_{ij}∥zi​−zj​∥=distij​ 令 B=ZTZ∈Rm×mB=Z^TZ \\in \\mathbb{R}^{m \\times m}B=ZTZ∈Rm×m 为降维后的样本的内积矩阵，即： bij=ziTzjb_{ij}=\\boldsymbol{z}_i^T\\boldsymbol{z}_jbij​=ziT​zj​，有： distij2=∥zi2∥+∥zj2∥−2ziTzj=bii+bjj−2bij\\begin{aligned} dist_{ij}^2 &amp;= \\Vert\\boldsymbol{z}_i^2\\Vert + \\Vert\\boldsymbol{z}_j^2\\Vert - 2\\boldsymbol{z}_i^T\\boldsymbol{z}_j \\\\ &amp;= b_{ii} + b_{jj} - 2b_{ij} \\end{aligned} distij2​​=∥zi2​∥+∥zj2​∥−2ziT​zj​=bii​+bjj​−2bij​​ 设降维后的样本 ZZZ 被中心化，即：∑i=1mzi=0\\sum_{i=1}^m\\boldsymbol{z}_i=0∑i=1m​zi​=0 则：矩阵 BBB 中行与列之和均为0，即：∑i=1mbij=∑j=1mbij=0\\sum_{i=1}^mb_{ij}=\\sum_{j=1}^mb_{ij}=0∑i=1m​bij​=∑j=1m​bij​=0 ∑i=1mdistij2=tr(B)+mbjj\\sum_{i=1}^mdist_{ij}^2=tr(B) + mb_{jj} i=1∑m​distij2​=tr(B)+mbjj​ ∑j=1mdistij2=tr(B)+mbii\\sum_{j=1}^mdist_{ij}^2=tr(B) + mb_{ii} j=1∑m​distij2​=tr(B)+mbii​ ∑i=1m∑j=1mdistij2=2m tr(B)\\sum_{i=1}^m\\sum_{j=1}^mdist_{ij}^2=2m\\ tr(B) i=1∑m​j=1∑m​distij2​=2m tr(B) 其中 tr(⋅)tr(\\cdot)tr(⋅) 表示矩阵的迹，tr(B)=∑i=1m∥zi∥tr(B)=\\sum_{i=1}^m\\Vert\\boldsymbol{z}_i\\Verttr(B)=∑i=1m​∥zi​∥。令： disti⋅2=1m∑j=1mdistij2dist_{i\\cdot}^2=\\frac{1}{m}\\sum_{j=1}^mdist_{ij}^2 disti⋅2​=m1​j=1∑m​distij2​ dist⋅j2=1m∑i=1mdistij2dist_{\\cdot j}^2=\\frac{1}{m}\\sum_{i=1}^mdist_{ij}^2 dist⋅j2​=m1​i=1∑m​distij2​ dist⋅⋅2=1m2∑i=1m∑j=1mdistij2dist_{\\cdot\\cdot}^2=\\frac{1}{m^2}\\sum_{i=1}^m\\sum_{j=1}^mdist_{ij}^2 dist⋅⋅2​=m21​i=1∑m​j=1∑m​distij2​ 则可得： bij=−12(distij2−disti⋅2−dist⋅j2+dist⋅⋅2)b_{ij}=-\\frac{1}{2}(dist_{ij}^2 - dist_{i\\cdot}^2 - dist_{\\cdot j}^2 + dist_{\\cdot\\cdot}^2) bij​=−21​(distij2​−disti⋅2​−dist⋅j2​+dist⋅⋅2​) 至此，得到了距离矩阵到内积矩阵的变换公式。 如何在低维子空间和高维空间之间保持样本之间的内积不变？ 对矩阵 BBB 进行特征值分解：B=VΛVTB=V\\Lambda V^TB=VΛVT 由谱分解的数学性质，我们知道：谱分布长尾，存在相当数量的小特征值，而只有少量的较大的特征值 因此可取 d′≪dd'\\ll dd′≪d 个最大特征值构成对角矩阵 Λ~=diag(λ1,…,λd′)\\tilde{\\Lambda}=diag(\\lambda_1, \\dots, \\lambda_{d'})Λ~=diag(λ1​,…,λd′​)，且 V~\\tilde{V}V~ 表示相应的特征向量矩阵，则可得到： Z=Λ1/2~V~T∈Rd′×mZ = \\tilde{\\Lambda^{1/2}}\\tilde{V}^T \\in \\mathbb{R}^{d' \\times m} Z=Λ1/2~V~T∈Rd′×m 主成分分析（PCA） 另一种常用的降维方法为主成分分析（principal Component Analysis） 正交属性空间中的样本点，如何使用一个超平面对所有样本进行恰当的表达？ 若存在这样的超平面，那么它大概应具有这样的性质： 最近重构性：样本点到这个超平面的距离都足够近 最大可分性：样本点在这个超平面上的投影能尽可能分开 基于最近重构性和最大可分性，可以得到主成分分析的两种等价推导。 最近重构性 假定对样本进行了中心化：∑ixi=0\\sum_i\\boldsymbol{x}_i=0∑i​xi​=0 假定投影变换后得到的新坐标系为 {w1,…,wd}\\{\\boldsymbol{w}_1,\\dots ,\\boldsymbol{w}_d\\}{w1​,…,wd​} ， 其中 wi\\boldsymbol{w}_iwi​ 是标准正交基向量，∥wi∥2=1,wiTwj=0(i≠j)\\Vert\\boldsymbol{w}_i\\Vert_2=1, \\boldsymbol{w}_i^T\\boldsymbol{w}_j=0 (i\\not ={j})∥wi​∥2​=1,wiT​wj​=0(i=j) 若丢弃新坐标系中的部分坐标，即将维度降低到 d′&lt;dd'&lt;dd′&lt;d，则样本点xi\\boldsymbol{x}_ixi​在低维坐标系中的投影是 zi=(zi1;zi2;… ;zid′)z_{i}=(z_{i1};z_{i2};\\dots;z_{id'})zi​=(zi1​;zi2​;…;zid′​)，其中zij=wjTxiz_{ij}=\\boldsymbol{w}_j^T\\boldsymbol{x}_izij​=wjT​xi​是 xi\\boldsymbol{x}_ixi​ 在低维坐标系下第 jjj 维的坐标。 若基于 zi\\boldsymbol{z}_izi​ 来重构 xi\\boldsymbol{x}_ixi​，则会得到 x^i=∑j=1d′zijwj\\hat{\\boldsymbol{x}}_i=\\sum_{j=1}^{d'}z_{ij}\\boldsymbol{w}_jx^i​=∑j=1d′​zij​wj​ 则原样本点 xi\\boldsymbol{x}_ixi​ 与基于投影重构的样本点 x^i\\hat{\\boldsymbol{x}}_ix^i​ 之间的距离为： ∑i=1m∥∑j=1d′zijwj−xi∥22=∑i=1mziTzi−2∑i=1mziTWTxi+const∝−tr(WT(∑i=1mxixiT)W)\\begin{aligned} \\sum_{i=1}^m\\Vert\\sum_{j=1}^{d'}z_{ij}\\boldsymbol{w}_j-\\boldsymbol{x}_i\\Vert_2^2 &amp;= \\sum_{i=1}^m\\boldsymbol{z}_i^T\\boldsymbol{z}_i-2\\sum_{i=1}^m\\boldsymbol{z}_i^TW^T\\boldsymbol{x}_i+const \\\\ &amp;\\propto -tr\\left(W^T\\left(\\sum_{i=1}^m \\boldsymbol{x}_i\\boldsymbol{x}_i^T\\right)W \\right) \\end{aligned} i=1∑m​∥j=1∑d′​zij​wj​−xi​∥22​​=i=1∑m​ziT​zi​−2i=1∑m​ziT​WTxi​+const∝−tr(WT(i=1∑m​xi​xiT​)W)​ 其中 W=(w1,…,wd)W=(\\boldsymbol{w}_1,\\dots,\\boldsymbol{w}_d)W=(w1​,…,wd​)，根据最近重构性，上式应该被最小化，由于 wj\\boldsymbol{w}_jwj​ 是标准正交基，∑ixixiT\\sum_i\\boldsymbol{x}_i\\boldsymbol{x}_i^T∑i​xi​xiT​ 是协方差矩阵，则有主成分分析的优化目标： min −tr(WTXXTW), s.t. WTW=I{min}\\ -tr(W^TXX^TW), \\ s.t.\\ W^TW=I min −tr(WTXXTW), s.t. WTW=I 最大可分性 样本点 xi\\boldsymbol{x}_ixi​ 在新空间中超平面上的投影为 WTxiW^T\\boldsymbol{x}_iWTxi​，若所有的样本点的投影尽可能分开，则应该使投影后样本点的方差最大化 由于投影后样本点的协方差矩阵是 ∑iWTxixiTW\\sum_iW^T\\boldsymbol{x}_i\\boldsymbol{x}_i^TW∑i​WTxi​xiT​W，因此优化目标即为： max tr(WTXXTW), s.t. WTW=I{max}\\ tr(W^TXX^TW), \\ s.t.\\ W^TW=I max tr(WTXXTW), s.t. WTW=I PCA 求解 对优化目标使用拉格朗日乘子法: XXTwi=λiwiXX^T\\boldsymbol{w}_i=\\lambda_i\\boldsymbol{w}_i XXTwi​=λi​wi​ 于是只需对协方差矩阵 XXTXX^TXXT 进行特征值分解，将求得的特征值排序：λ1≥λ2≥⋯≥λd\\lambda_1\\ge\\lambda_2\\ge\\dots\\ge\\lambda_dλ1​≥λ2​≥⋯≥λd​，再取前d′d'd′个特征值对应的特征向量构成 W∗=(w1,w2,…,wd′)W^*=(\\boldsymbol{w}_1, \\boldsymbol{w}_2, \\dots,\\boldsymbol{w}_{d'}) W∗=(w1​,w2​,…,wd′​) 这就是主成分分析的解 参数设置 d′d'd′ 的设置： 用户指定 在低维空间中对k近邻或其他分类器进行交叉验证 设置重构阈值，例如 t=95%t=95\\%t=95%，然后选取最小的 d′d'd′ 使得 ∑i=1d′λi∑i=1dλi≥t\\frac{\\sum_{i=1}^{d'}\\lambda_i}{\\sum_{i=1}^d\\lambda_i}\\ge t∑i=1d​λi​∑i=1d′​λi​​≥t PCA 是最常用的降维方法，在不同领域有不同的称谓 例如在人脸识别中该技术被称为“特征脸”(eigenface)，因为若将前 d′d'd′ 个特征值对应的特征向量还原为图像，则得到近似于人脸的识别模型示意图 非线性降维 线性降维方法假设从高维空间到低维空间的函数映射是线性的，然而在许多现实任务中，可能需要非线性映射才能找到恰当的低维嵌入 非线性降维的常用方法： 核化线性降维: 如KPCA, KLDA, … 流形学习(manifold learning) 核化PCA方法（KPCA） 首先在高维特征空间中，将数据投影到由 W=(w1,…,wd)W=(\\boldsymbol{w}_1, \\dots , \\boldsymbol{w}_d)W=(w1​,…,wd​) 确定的超平面上。则有： (∑i=1mziziT)wj=λjwj\\left( \\sum_{i=1}^m\\boldsymbol{z}_i\\boldsymbol{z}_i^T \\right)\\boldsymbol{w}_j=\\lambda_j\\boldsymbol{w}_j (i=1∑m​zi​ziT​)wj​=λj​wj​ wj=1λj(∑i=1mziziT)wj=∑i=1mziziTwjλj=∑i=1mziαij\\boldsymbol{w}_j=\\frac{1}{\\lambda_j}\\left(\\sum_{i=1}^m\\boldsymbol{z}_i\\boldsymbol{z}_i^T \\right)\\boldsymbol{w}_j=\\sum_{i=1}^m\\boldsymbol{z}_i\\frac{\\boldsymbol{z}_i^T\\boldsymbol{w}_j}{\\lambda_j}=\\sum_{i=1}^m\\boldsymbol{z}_i\\alpha_i^j wj​=λj​1​(i=1∑m​zi​ziT​)wj​=i=1∑m​zi​λj​ziT​wj​​=i=1∑m​zi​αij​ 其中 αij=1λjziTwj\\alpha_i^j=\\frac{1}{\\lambda_j}\\boldsymbol{z}_i^T\\boldsymbol{w}_jαij​=λj​1​ziT​wj​ 是 αi\\alpha_iαi​ 的第 jjj 个分量，zi\\boldsymbol{z}_izi​ 是由样本点 xi\\boldsymbol{x}_ixi​ 在高维特征空间中通过映射 ϕ\\phiϕ 产生，即 zi=ϕ(xi)\\boldsymbol{z}_i=\\phi(\\boldsymbol{x}_i)zi​=ϕ(xi​)。 若 ϕ\\phiϕ 能显式的表达出来，则可通过它将样本映射到高维特征空间，再在高维特征空间中实施 PCA 即可。从而有： (∑i=1mϕ(xi)ϕ(xi)T)wj=λjwj\\left( \\sum_{i=1}^m\\phi(\\boldsymbol{x}_i)\\phi(\\boldsymbol{x}_i)^T \\right)\\boldsymbol{w}_j=\\lambda_j\\boldsymbol{w}_j (i=1∑m​ϕ(xi​)ϕ(xi​)T)wj​=λj​wj​ wj=∑i=1mϕ(xi)αij\\boldsymbol{w}_j=\\sum_{i=1}^m\\phi(\\boldsymbol{x}_i)\\alpha_i^j wj​=i=1∑m​ϕ(xi​)αij​ 但是一般情况下， ϕ\\phiϕ 的形式不清楚，因此引入核函数：κ(xi,xj)=ϕ(xi)Tϕ(xi),(K)ij=κ(xi,xj)\\kappa(\\boldsymbol{x}_i,\\boldsymbol{x}_j)=\\phi(\\boldsymbol{x}_i)^T\\phi(\\boldsymbol{x}_i), (K)_{ij}=\\kappa(\\boldsymbol{x}_i,\\boldsymbol{x}_j)κ(xi​,xj​)=ϕ(xi​)Tϕ(xi​),(K)ij​=κ(xi​,xj​)，代入可得： Kαj=λjαjK\\boldsymbol{\\alpha}^j=\\lambda_j\\boldsymbol{\\alpha}^j Kαj=λj​αj 显然这是特征值分解问题，取 KKK 最大的 d′d'd′ 个特征值对应的特征向量即可。 从而，对于样本 x\\boldsymbol{x}x ，其投影后的第 jjj 维坐标为： zj=wjTϕ(x)=∑i=1mαijϕ(xi)Tϕ(x)=∑i=1mαijκ(xi,x)z_j=\\boldsymbol{w}_j^T\\phi(\\boldsymbol{x})=\\sum_{i=1}^m\\alpha_i^j\\phi(\\boldsymbol{x}_i)^T\\phi(\\boldsymbol{x}) = \\sum_{i=1}^m\\alpha_i^j\\kappa(\\boldsymbol{x}_i,\\boldsymbol{x}) zj​=wjT​ϕ(x)=i=1∑m​αij​ϕ(xi​)Tϕ(x)=i=1∑m​αij​κ(xi​,x) 此式表明，为获得投影后的坐标，KPCA需要对所有样本求和，因此计算开销比较大。 流形学习 “流形”是在局部与欧氏空间同胚的空间，即在局部具有欧氏空间的性质，可用欧氏距离进行距离计算。 应用到降维：若低维流形嵌入到高维空间中，则数据样本在高维空间上的分布看似复杂，但在局部仍具有欧氏空间的性质，因此可以容易的在局部建立降维映射关系，然后再设法将局部映射推广到全局。 等度量映射（Isomap） 基本出发点：试图保持近邻样本之间的距离 但：低维流形嵌入到高维空间后，直接在高维空间中计算直线距离具有误导性，因为高维空间上的直线距离在低维空间中是不可达的。 低维空间上两点的距离是 “测地线” 距离，这是两点之间的本真距离。 如何计算测地线距离： 利用流形的距离性质，对每个点基于欧氏距离找出近邻点，图中近邻点之间存在连接，非近邻点之间无连接 距离问题就变成了计算近邻连接图上两点之间最短路径问题，可用 Dijkstra 算法或者 Floyd 算法 得到距离后，再使用 MDS 方法获得样本在低维空间中的坐标 Isomap 算法得到的是训练样本在低维空间的坐标，对于新样本，如何进行映射？ 将训练样本的高维坐标作为输入，低维坐标作为输出，训练一个回归学习器。（权宜之计，暂时没有更好的办法） 如何构造近邻图： 指定近邻点个数，得到 kkk 近邻图 指定距离阈值 ϵ\\epsilonϵ，得到 ϵ\\epsilonϵ 近邻图 不足之处： 若近邻范围过大：距离比较远的点仍认为是近邻，导致“短路”问题 若距离范围过小：图中某些区域与其他区域会不存在连接，导致“断路”问题 局部线性嵌入（LLE） 基本出发点：试图保持邻域内样本间的线性关系，重构权值 // TODO： 添加推导步骤 基本步骤： 为每个样本构造近邻集合 QiQ_iQi​ 为每个样本计算基于 QiQ_iQi​ 的线性重构系数： 在低维空间中保持 WijW_{ij}Wij​ 不变，求解： 度量学习 对高维数据进行降维的主要目的是希望找到一个“合适的”低维空间，从而获得更好的学习性能。 实际上，每个空间对应了在样本属性上定义的一个距离度量，寻找合适的空间，就是寻找一个合适的距离度量。 那么，能否直接尝试“学出”合适的距离度量？ 马氏距离 首先，要有可以通过学习来“参数化”的距离度量形式: 马氏距离(Mahalanobis distance) 是一个很好的选择： distmah2(xi,xj)=(xi−xj)TM(xi−xj)=∥xi−xj∥M2dist_{mah}^2(\\boldsymbol{x}_i,\\boldsymbol{x}_j) = (\\boldsymbol{x}_i-\\boldsymbol{x}_j)^TM(\\boldsymbol{x}_i-\\boldsymbol{x}_j) = \\Vert\\boldsymbol{x}_i-\\boldsymbol{x}_j\\Vert_M^2 distmah2​(xi​,xj​)=(xi​−xj​)TM(xi​−xj​)=∥xi​−xj​∥M2​ 其中 MMM 即称之为度量矩阵，必须是半正定对称矩阵（M=PPTM=PP^TM=PPT, PPP为正交基），而度量学习即是对 MMM 进行学习。 学习目标 其次，对 MMM 进行学习需要设置一个目标： 某种分类器的性能 例如，若以近邻分类器的性能为目标，则得到近邻成分分析（NCA） 领域知识 例如，若已知“必连”(must-link) 约束集合与“勿连”(cannot-link) 约束集合 ，则C可通过求解这个凸优化问题得到 M: 近邻成分分析（NCA） 近邻分类器在进行判别时通常使用多数投票法，邻域内的样本投1票，其他投0票。 不妨将其替换为概率投票法：对于任意样本 xj\\boldsymbol{x}_jxj​，他对 xi\\boldsymbol{x}_ixi​ 分类结果的影响的概率为： pij=exp⁡(−∥xi−xj∥M2)∑lexp⁡(−∥xi−xl∥M2)p_{ij} = \\frac{\\exp(-\\Vert\\boldsymbol{x}_i-\\boldsymbol{x}_j\\Vert_M^2)}{\\sum_l\\exp(-\\Vert\\boldsymbol{x}_i-\\boldsymbol{x}_l\\Vert_M^2)} pij​=∑l​exp(−∥xi​−xl​∥M2​)exp(−∥xi​−xj​∥M2​)​ 显然，xj\\boldsymbol{x}_jxj​ 对 xi\\boldsymbol{x}_ixi​ 的影响随着它们之间距离的增大而减少。若以留一法（LOO）正确率的最大化为目标，则 xi\\boldsymbol{x}_ixi​ 的 LOO 正确率为： pi=∑j∈Ωipijp_i=\\sum_{j \\in \\Omega_i}p_{ij} pi​=j∈Ωi​∑​pij​ 整个样本集上的 LOO 正确率为： ∑i=1mpi=∑i=1m∑j∈Ωipij\\sum_{i=1}^mp_i=\\sum_{i=1}^m\\sum_{j \\in \\Omega_i}p_{ij} i=1∑m​pi​=i=1∑m​j∈Ωi​∑​pij​ 则可得NCA的优化目标为： min 1−∑i=1m∑j∈Ωiexp⁡(−∥PTxi−PTxj∥22)∑lexp⁡(−∥PTxi−PTxl∥22)min\\ 1-\\sum_{i=1}^m\\sum_{j \\in \\Omega_i}\\frac{\\exp(-\\Vert P^T\\boldsymbol{x}_i-P^T\\boldsymbol{x}_j\\Vert_2^2)}{\\sum_l\\exp(-\\Vert P^T\\boldsymbol{x}_i-P^T\\boldsymbol{x}_l\\Vert_2^2)} min 1−i=1∑m​j∈Ωi​∑​∑l​exp(−∥PTxi​−PTxl​∥22​)exp(−∥PTxi​−PTxj​∥22​)​ 求解此式即可得到最大化近邻分类器LOO正确率的距离度量矩阵 MMM LMNN 若已知某些样本相似，某些样本不相似，则可定义： “必连”约束集合：MMM, (xi,xj)∈M(\\boldsymbol{x}_i, \\boldsymbol{x}_j)\\in M(xi​,xj​)∈M 表示 xi,xj\\boldsymbol{x}_i, \\boldsymbol{x}_jxi​,xj​ 相似 “勿连”约束集合：CCC, (xi,xj)∈C(\\boldsymbol{x}_i, \\boldsymbol{x}_j)\\in C(xi​,xj​)∈C 表示 xi,xj\\boldsymbol{x}_i, \\boldsymbol{x}_jxi​,xj​ 不相似 显然，我们希望相似的样本之间的距离较小，不相似的比较大，因此可以转化为下面这个凸优化问题获取适当的度量矩阵 MMM： min⁡M∑(xi,xj)∈M∥xi−xj∥M2 s.t. ∑(xi,xk)∈C∥xi−xk∥M2⩾1M⪰0\\begin{array}{ll} {\\min _{\\mathbf{M}}} &amp; {\\sum_{\\left(\\boldsymbol{x}_{i}, \\boldsymbol{x}_{j}\\right) \\in \\mathcal{M}}\\left\\|\\boldsymbol{x}_{i}-\\boldsymbol{x}_{j}\\right\\|_{\\mathrm{M}}^{2}} \\\\\\\\ {\\text { s.t. }} &amp; {\\sum_{\\left(\\boldsymbol{x}_{i}, \\boldsymbol{x}_{k}\\right) \\in \\mathcal{C}}\\left\\|\\boldsymbol{x}_{i}-\\boldsymbol{x}_{k}\\right\\|_{\\mathbf{M}}^{2} \\geqslant 1} \\\\\\\\ {} &amp; {\\mathbf{M} \\succeq 0} \\end{array} minM​ s.t. ​∑(xi​,xj​)∈M​∥xi​−xj​∥M2​∑(xi​,xk​)∈C​∥xi​−xk​∥M2​⩾1M⪰0​","link":"/p/7e4fc966/"},{"title":"西瓜书第11章：特征选择与稀疏学习","text":"特征选择 从给定的特征集合中选出任务相关特征子集 必须确保不丢失重要特征 原因 减轻维度灾难：在少量属性上构建模型 降低学习难度：留下关键信息 主要步骤： 产生初始候选子集 评价候选子集的好坏 基于评价结果产生下一个候选子集 两个关键环节：子集搜索和子集评价 子集搜索 用贪心策略选择包含重要信息的特征子集 前向搜索：逐渐增加相关特征，最优子集初始为空集，特征集合初始时包括所有给定特征 后向搜索：从完整的特征集合开始，逐渐减少特征 双向搜索：每一轮逐渐增加相关特征，同时减少无关特征 子集评价 特征子集确定了对数据集的一个划分 每个划分区域对应着特征子集的某种取值 样本标记对应着对数据集的真实划分 特征子集𝐴的信息增益为： Gain⁡(A)=Ent⁡(D)−∑v=1V∣Dv∣∣D∣Ent⁡(Dv)\\operatorname{Gain}(A)=\\operatorname{Ent}(D)-\\sum_{v=1}^{V} \\frac{\\left|D^{v}\\right|}{|D|} \\operatorname{Ent}\\left(D^{v}\\right) Gain(A)=Ent(D)−v=1∑V​∣D∣∣Dv∣​Ent(Dv) 特征选择方法 将特征子集搜索机制与子集评价机制相结合，即可得到特征选择方法 过滤式（Relief） 先用特征选择过程过滤原始数据，再用过滤后的特征来训练模型；特征选择过程与后续学习器无关 Relief (Relevant Features) 方法 为每个初始特征赋予一个“相关统计量”，度量特征的重要性 特征子集的重要性由子集中每个特征所对应的相关统计量之和决定 设计一个阈值，然后选择比阈值大的相关统计量分量所对应的特征 或者指定欲选取的特征个数，然后选择相关统计量分量最大的指定个数特征 Relief-F? 包裹式（LVW） LVW（Las Vegas Wrapper）在拉斯维加斯方法框架下使用随机策略来进行子集搜索，并以最终分类器的误差作为特征子集评价准则 基本步骤 在循环的每一轮随机产生一个特征子集 在随机产生的特征子集上通过交叉验证推断当前特征子集的误差 进行多次循环，在多个随机产生的特征子集中选择误差最小的特征子集作为最终解 若有运行时间限制，则该算法有可能给不出解 嵌入式 嵌入式特征选择是将特征选择过程与学习器训练过程融为一体，两者在同一个优化过程中完成，在学习器训练过程中自动地进行特征选择 岭回归（L2L_2L2​范数） min⁡w∑i=1m(yi−w⊤xi)2+λ∥w∥22\\min _{\\boldsymbol{w}} \\sum_{i=1}^{m}\\left(y_{i}-\\boldsymbol{w}^{\\top} \\boldsymbol{x}_{i}\\right)^{2}+\\lambda\\|\\boldsymbol{w}\\|_{2}^{2} wmin​i=1∑m​(yi​−w⊤xi​)2+λ∥w∥22​ LASSO（L1L_1L1​范数） min⁡w∑i=1m(yi−w⊤xi)2+λ∥w∥1\\min _{\\boldsymbol{w}} \\sum_{i=1}^{m}\\left(y_{i}-\\boldsymbol{w}^{\\top} \\boldsymbol{x}_{i}\\right)^{2}+\\lambda\\|\\boldsymbol{w}\\|_{1} wmin​i=1∑m​(yi​−w⊤xi​)2+λ∥w∥1​ L1正则化问题的求解 近端梯度下降（Proximal Gradient Descend，简称PGD）解法 写出f(x)f(\\boldsymbol{x})f(x)的二阶泰勒展式： f(x)=f(xk)+⟨∇f(xk),x−xk⟩+12(x−xk)⊤δ2f(xk)δxk2(x−xk)f(\\boldsymbol{x})=f\\left(\\boldsymbol{x}_{k}\\right)+\\left\\langle\\nabla f\\left(\\boldsymbol{x}_{k}\\right), \\boldsymbol{x}-x_{k}\\right\\rangle+\\frac{1}{2}\\left(\\boldsymbol{x}-\\boldsymbol{x}_{k}\\right)^{\\top} \\frac{\\delta^{2} f\\left(\\boldsymbol{x}_{k}\\right)}{\\delta \\boldsymbol{x}_{k}^{2}}\\left(\\boldsymbol{x}-\\boldsymbol{x}_{k}\\right) f(x)=f(xk​)+⟨∇f(xk​),x−xk​⟩+21​(x−xk​)⊤δxk2​δ2f(xk​)​(x−xk​) 假设f(x)f(\\boldsymbol{x})f(x)满足L-Lipschitz条件， 即存在常数𝐿 &gt; 0, 使得 ∥∇f(x′)−∇f(x)∥≤L∥x′−x∥22\\left\\|\\nabla f\\left(\\boldsymbol{x}^{\\prime}\\right)-\\nabla f(\\boldsymbol{x})\\right\\| \\leq L\\left\\|\\boldsymbol{x}^{\\prime}-\\boldsymbol{x}\\right\\|_{2}^{2} ∥∇f(x′)−∇f(x)∥≤L∥x′−x∥22​ L-Lipschitz条件代入泰勒展式，可得： f(x)≅f(xk)+⟨∇f(xk),x−xk⟩+L2∥x−xk∥2=L2∥x−(xk−1L∇f(xk))∥2+const\\begin{aligned} f(\\boldsymbol{x}) &amp; \\cong f\\left(\\boldsymbol{x}_{k}\\right)+\\left\\langle\\nabla f\\left(\\boldsymbol{x}_{k}\\right), \\boldsymbol{x}-\\boldsymbol{x}_{k}\\right\\rangle+\\frac{L}{2}\\left\\|\\boldsymbol{x}-\\boldsymbol{x}_{k}\\right\\|^{2} \\\\ &amp;=\\frac{L}{2}\\left\\|\\boldsymbol{x}-\\left(\\boldsymbol{x}_{k}-\\frac{1}{L} \\nabla f\\left(\\boldsymbol{x}_{k}\\right)\\right)\\right\\|^{2}+\\mathrm{const} \\end{aligned} f(x)​≅f(xk​)+⟨∇f(xk​),x−xk​⟩+2L​∥x−xk​∥2=2L​∥∥​x−(xk​−L1​∇f(xk​))∥∥​2+const​ 将上式关于𝑓(𝒙)的近似代入到原优化问题中，得 min⁡x∑i=1mL2∥x−(xk−1L∇f(xk))∥2+λ∥x∥1\\min _{x} \\sum_{i=1}^{m} \\frac{L}{2}\\left\\|x-\\left(\\boldsymbol{x}_{k}-\\frac{1}{L} \\nabla f\\left(\\boldsymbol{x}_{k}\\right)\\right)\\right\\|^{2}+\\lambda\\|\\boldsymbol{x}\\|_{1} xmin​i=1∑m​2L​∥∥​x−(xk​−L1​∇f(xk​))∥∥​2+λ∥x∥1​ 每次在xkx_kxk​的附近寻找最优点，不断迭代，即寻找 xk+1=min⁡x∑i=1mL2∥x−(xk−1L∇f(xk))∥2+λ∥x∥1\\boldsymbol{x}_{k+1}=\\min _{\\boldsymbol{x}} \\sum_{i=1}^{m} \\frac{L}{2}\\left\\|\\boldsymbol{x}-\\left(\\boldsymbol{x}_{k}-\\frac{1}{L} \\nabla f\\left(\\boldsymbol{x}_{k}\\right)\\right)\\right\\|^{2}+\\lambda\\|\\boldsymbol{x}\\|_{1} xk+1​=xmin​i=1∑m​2L​∥∥​x−(xk​−L1​∇f(xk​))∥∥​2+λ∥x∥1​ 假设z=xk−1/L∇f(xk)\\mathbf{z}=\\boldsymbol{x}_{k}-1 / L \\nabla f\\left(\\boldsymbol{x}_{k}\\right)z=xk​−1/L∇f(xk​)，上式有闭式解 xk+1,i={zi−λ/Lzi&gt;λ/L0∣zi∣≤λ/Lzi+λ/Lzi&lt;−λ/Lx_{k+1, i}=\\left\\{\\begin{array}{ll} {z_{i}-\\lambda / L} &amp; {z_{i}&gt;\\lambda / L} \\\\ {0} &amp; {\\left|z_{i}\\right| \\leq \\lambda / L} \\\\ {z_{i}+\\lambda / L} &amp; {z_{i}&lt;-\\lambda / L} \\end{array}\\right. xk+1,i​=⎩⎨⎧​zi​−λ/L0zi​+λ/L​zi​&gt;λ/L∣zi​∣≤λ/Lzi​&lt;−λ/L​ 稀疏表示（字典学习） 为普通稠密表达的样本找到合适的字典，将样本转化为稀疏表示，这一过程称为字典学习 给定数据集 {x1,x2,…,xm},xi∈Rn×k\\left\\{\\boldsymbol{x}_{1}, \\boldsymbol{x}_{2}, \\ldots, \\boldsymbol{x}_{m}\\right\\}, \\boldsymbol{x}_{i} \\in \\mathbb{R}^{n \\times k}{x1​,x2​,…,xm​},xi​∈Rn×k 学习目标是字典矩阵 B∈Rd×k\\mathbf{B} \\in \\mathbb{R}^{d \\times k}B∈Rd×k 以及样本的稀疏表示 αi∈Rk\\boldsymbol{\\alpha}_{i} \\in \\mathbb{R}^{k}αi​∈Rk 𝑘称为字典的词汇量，通常由用户指定 则最简单的字典学习的优化形式为: min⁡B,αi∑i=1m∥xi−Bαi∥22+λ∑i=1m∥αi∥1\\min _{\\mathbf{B}, \\alpha_{i}} \\sum_{i=1}^{m}\\left\\|\\mathbf{x}_{i}-\\mathbf{B} \\boldsymbol{\\alpha}_{i}\\right\\|_{2}^{2}+\\lambda \\sum_{i=1}^{m}\\left\\|\\boldsymbol{\\alpha}_{i}\\right\\|_{1} B,αi​min​i=1∑m​∥xi​−Bαi​∥22​+λi=1∑m​∥αi​∥1​ 字典学习的解法 压缩感知 长度为𝑚的离散信号𝒙，用远小于奈奎斯特采样定理的要求的采样率采样得到长度为𝑛的采样后信号𝒚，𝑛 ≪ 𝑚，即 y=Φx\\boldsymbol{y}=\\boldsymbol{\\Phi} \\boldsymbol{x} y=Φx 一般情况下，𝑛 ≪ 𝑚，不能利用𝒚还原𝒙，但是若存在某个线性变换Ψ，使得𝒙 = Ψ𝒔， 𝒔是稀疏向量，即 y=Φx=ΦΨs=As\\boldsymbol{y}=\\boldsymbol{\\Phi} \\boldsymbol{x}=\\boldsymbol{\\Phi} \\Psi s=\\mathbf{A} \\boldsymbol{s} y=Φx=ΦΨs=As 𝐴具有“限定等距性”时，可以近乎完美地恢复𝒔","link":"/p/7da1e18e/"},{"title":"西瓜书第12章：计算学习理论","text":"概述 一些概念及记号 DDD 是 D\\mathcal{D}D 的独立同分布采样，因此 hhh 的经验误差的期望等于其泛化误差。 泛化误差： E(h;D)=Px∼D(h(x)≠y)E(h ; \\mathcal{D})=P_{x \\sim \\mathcal{D}}(h(\\boldsymbol{x}) \\neq y) E(h;D)=Px∼D​(h(x)=y) 经验误差： E^(h;D)=1m∑i=1mI(h(xi)≠yi)\\hat{E}(h ; D)=\\frac{1}{m} \\sum_{i=1}^{m} \\mathbb{I}\\left(h\\left(\\boldsymbol{x}_{i}\\right) \\neq y_{i})\\right. E^(h;D)=m1​i=1∑m​I(h(xi​)=yi​) 经验误差与泛化误差之间逼近程度： 一致与不一致：若 hhh 在数据集 DDD 上的经验误差为0, 则称 hhh 与 DDD 一致, 否则不一致。 概率近似正确（Probably Approximately Correct) PAC学习 什什么是“可学习的” 假设空间复杂性 有限假设空间 ⽆无限假设空间：VC维 ⽆无限假设空间：Rademacher复杂度 稳定性","link":"/p/9b37d400/"},{"title":"OS","text":"OS 中的 P-V 操作 生产者-消费者 &amp;&amp; 哲学家 &amp;&amp; 读者-写者 &amp;&amp; 理发师-顾客 生产者-消费者 1234567891011121314151617181920212223242526272829semaphore mutex = 1;semaphore empty = n;semaphore full = 0;Producer(){ while(1){ produce; P(empty); P(mutex); add to buffer; V(mutex); V(full); }}Consumer(){ while(1){ P(full); P(mutex); remove from buffer; V(mutex); V(empty); consume; }} 哲学家就餐 123456789101112131415161718semaphore chop[5] = {1, 1, 1, 1, 1};semaphore mutex = 1;Pi(){ while(1){ think; P(mutex); P(chop[i]); P(chop[(i+1)%5]); V(mutex); eat; V(chop[i]); V(chop[(i+1)%5]); }} 读者-写者 12345678910111213141516171819202122232425262728293031323334int count = 0;semaphore mutex = 1;semaphore rw = 1;semaphore w = 1;Writer(){ while(1){ // P(w); // 写优先信号 P(rw); writing; V(rw); // V(w); }}Reader(){ while(1){ // P(w); // 写优先信号 P(mutex); if(count == 0) P(rw); count++; V(mutex); // V(w); reading; P(mutex); count--; if(count == 0) V(rw); V(mutex); }} 理发师-顾客 1234567891011121314151617181920212223242526272829int waiting = 0;int chairs = N;semaphore customers = 0;semaphore barbers = 0;semaphore mutex = 1;Barbers(){ while(1){ P(customers); P(mutex); waiting--; V(barbers); V(mutex); cut hair; }}Customes(){ P(mutex); if(waiting &lt; chairs){ waiting++; V(customes); V(mutex); P(barbers); get haircut; } else V(mutex);}","link":"/p/c45a417b/"},{"title":"Tree","text":"二叉树的相关算法 递归 &amp;&amp; 非递归 &amp;&amp; 搜索树 树的递归算法 先-中-后序遍历 12345678void preOrder(TreeNode *root){ // visit(p); 先序 preOrder(root-&gt;left); // visit(p); 中序 preOrder(root-&gt;right); // visit(p); 后序} 统计节点数 123456789101112int degree(TreeNode *root){ if (!root) return 0; if (!(root-&gt;left || root-&gt;right)) // 0-degree if ((root-&gt;left &amp;&amp; !root-&gt;right) || (root-&gt;right &amp;&amp; !root-&gt;left)) // 1-degree if (root-&gt;left &amp;&amp; root-&gt;right) // 2-degree return degree(root-&gt;left) + degree(root-&gt;right) + 1; else return degree(root-&gt;left) + degree(root-&gt;right);} 树的高度 12345678int height(TreeNode *root){ if (!root) return 0; int hleft = height(root-&gt;left); int hright = height(root-&gt;right); return (hleft &gt; hright) ? hleft + 1 : hright + 1;} 树的宽度 12345678910void width(TreeNode *root, int k, int *v){ if (!root) return; v[k]++; if (v[0] &lt; v[k]) v[0] = v[k]; width(root-&gt;left, k + 1, v); width(root-&gt;right, k + 1, v);} 先序+中序构建树 1234567891011121314151617TreeNode *buildTree(int *pre, int s1, int e1, int *in, int s2, int e2){ if (s1 &gt; e1) return NULL; int f = pre[s1]; TreeNode *p = new TreeNode(f); int i; for (i = 0; in[s2 + i] != f; i++) ; p-&gt;left = buildTree(pre, s1 + 1, s1 + i, in, s2, s2 + i - 1); p-&gt;right = buildTree(pre, s1 + i + 1, e1, in, s2 + i + 1, e2); cout &lt;&lt; &quot;Build Tree is:&quot; &lt;&lt; endl; prettyPrintTree(p); return p;} 交换左右子树 12345678910111213TreeNode *swapLeftAndRight(TreeNode *root){ if (root) { swapLeftAndRight(root-&gt;left); swapLeftAndRight(root-&gt;right); TreeNode *temp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = temp; } return root;} 先序第k个节点 12345678910111213int preOrderOfK(TreeNode *root, int &amp;i, int k){ if (!root) return -1; if (i == k) return root-&gt;val; i++; int val = preOrderOfK(root-&gt;left, i, k); if (val != -1) return val; val = preOrderOfK(root-&gt;right, i, k); return val;} 最大值 123456789int maxVal(TreeNode *root){ if (!root) return -1; int maxL = maxVal(root-&gt;left); int maxR = maxVal(root-&gt;right); int max = maxL &gt; maxR ? maxL : maxR; return root-&gt;val &gt; max ? root-&gt;val : max;} 删除节点 123456789void deleteTree(TreeNode *root){ if (root) { deleteTree(root-&gt;left); deleteTree(root-&gt;right); delete root; }} 删除特点节点 1234567891011121314151617TreeNode *deleteValOfX(TreeNode *root, int x){ if (!root) return NULL; if (root-&gt;val == x) { deleteTree(root); root = NULL; } else { root-&gt;left = deleteValOfX(root-&gt;left, x); root-&gt;right = deleteValOfX(root-&gt;right, x); } return root;} 树的非递归算法 先序遍历 算法1 123456789101112131415161718void preOrder1(TreeNode *root){ Stack S; TreeNode *p = root; while (p || !S.empty()) { if (p) { visit(p); if (p-&gt;right) S.push(p-&gt;right); p = p-&gt;left; } else p = S.pop(); }} 算法2 1234567891011121314151617void preOrder2(TreeNode *root){ Stack S; TreeNode *p = root; S.push(p); while (!S.empty()) { p = S.pop(); if (p) { visit(p); S.push(p-&gt;right); S.push(p-&gt;left); } }} 中序遍历 1234567891011121314151617181920void inOrder(TreeNode *root){ Stack S; TreeNode *p = root; while (p || !S.empty()) { if (p) { S.push(p); p = p-&gt;left; } else { p = S.pop(); visit(p); p = p-&gt;right; } }} 后序遍历 12345678910111213141516171819202122232425262728293031void postOrder(TreeNode *root){ Stack S; TreeNode *p = root, *r; while (p || !S.empty()) { if (p) { S.push(p); p = p-&gt;left; } else { p = S.top(); if (p-&gt;right &amp;&amp; p-&gt;right != r) { p = p-&gt;right; S.push(p); p = p-&gt;left; } else { p = S.pop(); visit(p); r = p; p = NULL; } } }} 层次遍历 1234567891011121314151617181920void levelOrder(TreeNode *root){ Queue Q; if (!root) return; TreeNode *p = root; Q.enqueue(p); while (!Q.empty()) { p = Q.dequeue(); visit(p); if (p-&gt;left) Q.enqueue(p-&gt;left); if (p-&gt;right) Q.enqueue(p-&gt;right); }} 求树高 1234567891011121314151617181920212223242526int height(TreeNode *root){ if (root == NULL) return 0; Queue Q; TreeNode *p = root, *r = root; int height = 0; Q.enqueue(p); while (!Q.empty()) { p = Q.dequeue(); if (p-&gt;left) Q.push(p-&gt;left); if (p-&gt;right) Q.push(p-&gt;right); if (p == r) { height++; r = Q.back(); } } return height;} 树的宽度 12345678910111213141516171819202122232425262728int width(TreeNode *root){ if (!root) return 0; int width = 0; int levelwidth = 0; queue&lt;TreeNode *&gt; q; TreeNode *p = root, *r = root; q.push(p); while (!q.empty()) { p = q.front(); q.pop(); levelwidth++; if (p-&gt;left) q.push(p-&gt;left); if (p-&gt;right) q.push(p-&gt;right); if (p == r) { width = (levelwidth &gt; width) ? levelwidth : width; levelwidth = 0; r = q.back(); } } return width;} 搜索树结构 递归搜索 1234567891011TreeNode *search(TreeNode *root, int key){ if (root == NULL) return NULL; else if (root-&gt;val == key) return root; else if (root-&gt;val &lt; key) return search(root-&gt;right, key); else return search(root-&gt;left, key);} 非递归搜索 1234567891011TreeNode *search(TreeNode *root, int key){ while (root &amp;&amp; key != root-&gt;val) { if (key &lt; root-&gt;val) root = root-&gt;left; else root = root-&gt;right; } return root;} 插入 123456789101112131415161718192021bool insert(TreeNode *&amp;root, int key){ if (!root) { root = new TreeNode(key); root-&gt;left = root-&gt;right = NULL; return true; } else { TreeNode *p = NULL, *q = NULL; q = search(root, key, p); if (q) return false; else if (key &lt; p-&gt;val) p-&gt;left = new TreeNode(key); else p-&gt;right = new TreeNode(key); return true; }} 删除","link":"/p/170cf1e2/"},{"title":"MapReduce 课程总结","text":"MapReduce 大数据分析课程总结 大数据技术简介 大数据的类型分类 结构特征 结构化数据 非结构化/半结构化数据 获取和处理方式 静态(线下数据)/非实时数据 动态(流式/增量式/线上)/实时数据 关联特征 无关联/简单关联数据(键值记录型数据) 复杂关联数据(图数据) 大数据处理的主要技术问题 存储：巨量数据如何存得下？数据存储问题 数据规模导致难以应对的存储量，传统数据库技术失效 需要研究开发有效的分布式大数据存储技术与系统 计算：巨量数据如何快速完成计算？计算性能问题 数据规模导致传统算法失效 复杂的数据关联性导致高复杂度的计算 需要研究开发高效的大数据并行计算技术与系统 分析：如何发现大数据的深度价值？数据分析问题 大数据隐含很多小数据时难以发现的深度价值 需要研究开发有效的大数据分析挖掘技术与工具 大数据研究的基本途径 新算法：寻找新算法降低计算复杂度 降低尺度：寻找数据尺度无关近似算法 并行化：分而治之，并行化处理 ？什么是大数据 Wiki百科：大数据意指一个超大的、难以用现有常规的数据库管理技术和工具处理的数据集 IDC报告：大数据技术描述了一种新一代技术和构架，用于以很经济的方式、以高速的捕获、发现和分析技术，从各种超大规模的数据中提取价值 “大数据”的真实含义： 大数据是以下内容的一个总称： 大数据带来了新的技术时代转型 大数据所带来的问题和技术挑战 大数据处理所需的新的技术和方法 大数据时代需要的大数据思维 大数据分析和应用所带来的新发明、新服务和新的发展机遇 GB -&gt; Tb -&gt; PB -&gt; EB -&gt; ZB ？大数据特点: 5V Volume: 大容量：PB级规模 Variety: 多样性：结构化/非结构化 Velocity: 时效性：实时处理 Veracity: 准确性：结果准确 Value: 大价值：深度价值 ？三个层面的挑战 大数据的技术挑战 数据存储能力大幅落后于数据增长速度 数据处理能力大幅落后于数据增长速度 企业应用的挑战 大企业内竖井式应用，大量系统相互隔离，形成信息孤岛 政府数据开放政策的挑战 政府机构掌握的大量数据不能开放使用 MapReduce 简介 为什么需要大规模数据并行处理 处理数据的能力大幅落后于数据增长 海量数据隐含着更准确的事实 什么是MapReduce？ MapReduce是Google公司发明的一种面向大规模大数据处理的高性能并行计算平台和软件编程框架，是目前最为成功和最易于使用的大规模大数据并行处理技术，广泛应用于搜索引擎（文档倒排索引，网页链接图分析与页面排序等）、Web日志分析、文档分析处理、机器学习、机器翻译等各种大规模数据并行计算应用领域 基于集群的高性能并行计算平台(Cluster Infrastructure) 允许用市场上现成的普通PC或性能较高的刀架或机架式服务器，构成一个包含数千个节点的分布式并行计算集群 并行程序开发与运行框架(Software Framework) 提供了一个庞大但设计精良的并行计算软件构架，能自动完成计算任务的并行化处理，自动划分计算数据和计算任务，在集群节点上自动分配和执行子任务以及收集计算结果，将数据分布存储、数据通信、容错处理等并行计算中的很多复杂细节交由系统负责处理，大大减少了软件开发人员的负担 并行程序设计模型与方法(Programming Model &amp; Methodology) 借助于函数式语言中的设计思想，提供了一种简便的并行程序设计方法，用Map和Reduce两个函数编程实现基本的并行计算任务，提供了完整的并行编程接口，完成大规模数据处理 为什么MapReduce如此重要？ 高效的大规模数据处理方法 改变了大规模尺度上组织计算的方式 第一个不同于冯诺依曼结构的、基于集群而非单机的计算方式的重大突破 目前为止最为成功的基于大规模计算资源的并行计算抽象方法 MapReduce在三个层面上的基本构思 如何对付大数据处理：分而治之 对相互间不具有计算依赖关系的大数据，实现并行最自然的办法就是采取分而治之的策略 什么样的计算任务可进行并行化计算？ 不可分拆的计算任务或相互间有依赖关系的数据无法进行并行计算 一个大数据若可以分为具有同样计算过程的数据块，并且这些数据块之间不存在数据依赖关系，则提高处理速度的最好办法就是并行计算 上升到抽象模型：Mapper与Reducer 主要设计思想：为大数据处理过程中的两个主要处理操作：Map和Reduce提供了高层的并行编程抽象模型 典型的流式大数据问题的特征： 大量数据记录/元素进行重复处理 对每个数据记录/元素作感兴趣的处理、获取感兴趣的中间结果信息 排序和整理中间结果以利后续处理 收集整理中间结果 产生最终结果输出 Map Reduce：提供一种抽象机制，把做什么和怎么做分开，程序员仅需要描述做什么，不需要关心怎么做 Map: 对一组数据元素进行某种重复式的处理：(k1; v1) -&gt; [(k2; v2)] 输入：键值对(k1; v1)表示的数据 处理：文档数据记录(如文本文件中的行，或数据表格中的行)将以“键值对”形式传入map函数；map函数将处理这些键值对，并以另一种键值对形式输出处理的一组键值对中间结果[(k2; v2)] 输出：键值对[(k2; v2)]表示的一组中间数据 Reduce: 对Map的中间结果进行某种进一步的结果整理：(k2; [v2]) -&gt; [(k3; v3)] 输入： 由map输出的一组键值对[(k2; v2)] 将被进行合并处理将同样主键下的不同数值合并到一个列表[v2]中，故reduce的输入为(k2; [v2]) 处理：对传入的中间结果列表数据进行某种整理或进一步的处理,并产生最终的某种形式的结果输出[(k3; v3)] 。 输出：最终输出结果[(k3; v3)] 上升到构架：统一构架，为程序员隐藏系统层细节 主要需求、目标和设计思想 实现自动并行化计算 为程序员隐藏系统层细节 MapReduce提供统一的构架并完成以下的主要功能 任务调度：提交的一个计算作业(job)将被划分为很多个计算任务(tasks), 任务调度功能主要负责为这些划分后的计算任务分配和调度计算节点(map节点或reducer节点); 同时负责监控这些节点的执行状态, 并负责map节点执行的同步控制(barrier); 也负责进行一些计算性能优化处理, 如对最慢的计算任务采用多备份执行、选最快完成者作为结果 数据/代码互定位：为了减少数据通信，一个基本原则是本地化数据处理(locality)，即一个计算节点尽可能处理其本地磁盘上所分布存储的数据，这实现了代码向数据的迁移；当无法进行这种本地化数据处理时，再寻找其它可用节点并将数据从网络上传送给该节点(数据向代码迁移)，但将尽可能从数据所在的本地机架上寻找可用节点以减少通信延迟 出错处理：以低端商用服务器构成的大规模MapReduce计算集群中,节点硬件(主机、磁盘、内存等)出错和软件有bug是常态，因此,MapReducer需要能检测并隔离出错节点，并调度分配新的节点接管出错节点的计算任务 分布式数据存储与文件管理：海量数据处理需要一个良好的分布数据存储和文件管理系统支撑,该文件系统能够把海量数据分布存储在各个节点的本地磁盘上,但保持整个数据在逻辑上成为一个完整的数据文件；为了提供数据存储容错机制,该文件系统还要提供数据块的多备份存储管理能力 Combiner和Partitioner:为了减少数据通信开销,中间结果数据进入reduce节点前需要进行合并(combine)处理,把具有同样主键的数据合并到一起避免重复传送; 一个reducer节点所处理的数据可能会来自多个map节点, 因此, map节点输出的中间结果需使用一定的策略进行适当的划分(partitioner)处理，保证相关数据发送到同一个reducer节点 主要设计思想与特点 向“外”横向扩展，而非向“上”纵向扩展 失效被认为是常态 把处理向数据迁移 顺序处理数据、避免随机访问数据 为应用开发者隐藏系统层细节 平滑无缝的可扩展性 Google/Hadoop MapReduce基本构架 借鉴函数式程序设计语言Lisp中的思想，定义了Map和Reduce两个抽象的操作函数： map: (k1; v1) -&gt; [(k2; v2)] reduce: (k2; [v2]) -&gt; [(k3; v3)] 特点： 描述了对一组数据处理的两个阶段的抽象操作 仅仅描述了需要做什么，不需要关注怎么做 Google MapReduce的基本工作原理 失效处理 主节点失效 主节点中会周期性地设置检查点(checkpoint)，检查整个计算作业的执行情况，一旦某个任务失效，可以从最近有效的检查点开始重新执行，避免从头开始计算的时间浪费。 工作节点失效 工作节点失效是很普遍发生的，主节点会周期性地给工作节点发送心跳检测，如果工作节点没有回应，这认为该工作节点失效，主节点将终止该工作节点的任务并把失效的任务重新调度到其它工作节点上重新执行 带宽优化 问题 大量的键值对数据在传送给Reduce节点时会引起较大的通信带宽开销。 解决方案 每个Map节点处理完成的中间键值队将由combiner做一个合并压缩，即把那些键名相同的键值对归并为一个键名下的一组数值。 计算优化 问题 Reduce节点必须要等到所有Map节点计算结束才能开始执行，因此，如果有一个计算量大、或者由于某个问题导致很慢结束的Map节点，则会成为严重的“拖后腿者”。 解决方案 把一个Map计算任务让多个Map节点同时做，取最快完成者的计算结果。 用数据分区解决数据相关性问题 问题 一个Reduce节点上的计算数据可能会来自多个Map节点，因此，为了在进入Reduce节点计算之前，需要把属于一个Reduce节点的数据归并到一起。 解决方案 在Map阶段进行了Combining以后，可以根据一定的策略对Map输出的中间结果进行分区(partitioning)，这样即可解决以上数据相关性问题避免Reduce计算过程中的数据通信。 例如：有一个巨大的数组,其最终结果需要排序,每个Map节点数据处理好后,为了避免在每个Reduce节点本地排序完成后还需要进行全局排序,我们可以使用一个分区策略如:(d%R),d为数据大小，R为Reduce节点的个数，则可根据数据的大小将其划分到指定数据范围的Reduce节点上,每个Reduce将本地数据拍好序后即为最终结果 Hadoop MapReduce的基本工作原理 程序执行时的容错处理与计算性能优化 由Hadoop系统自己解决 主要方法是将失败的任务进行再次执行 TaskTracker会把状态信息汇报给JobTracker，最终由JobTracker决定重新执行哪一个任务 为了加快执行的速度，Hadoop也会自动重复执行同一个任务，以最先执行成功的为准（投机执行） mapred.map.tasks.speculative.execution mapred.reduce.tasks.speculative.execution Hadoop MapReduce主要组件 文件输入格式InputFormat 定义了数据文件如何分割和读取 InputFormat提供了以下一些功能 选择文件或者其它对象，用来作为输入 定义InputSplits, 将一个文件分为不同任务 为RecordReader提供一个工厂，用来读取这个文件 有一个抽象的类FileInputFormat，所有的输入格式类都从这个类继承其功能以及特性。当启动一个Hadoop任务的时候，一个输入文件所在的目录被输入到FileInputFormat对象中。 FileInputFormat从这个目录中读取所有文件。然后FileInputFormat将这些文件分割为多个InputSplits。 通过在JobConf对象上设置JobConf.setInputFormat设置文件输入 的格式 InputFormat: Description: Key: Value: TextInputFormat Default format; reads lines of text files The byte offset of the line The line contents KeyValueTextInputFormat Parses lines into key-val pairs Everything up to the first tab character The remainder of the line SequenceFileInputFormat A Hadoop-specific high performance binary format user-defined user-defined 输入数据分块InputSplits InputSplit定义了输入到单个Map任务的输入数据 一个MapReduce程序被统称为一个Job，可能有上百个任务构成 InputSplit将文件分为64MB的大小 配置文件hadoop-site.xml中的mapred.min.split.size参数控制这个大小 mapred.tasktracker.map.taks.maximum用来控制某一个节点上所有map任务的最大数目 数据记录读入RecordReader InputSplit定义了一个数据分块，但是没有定义如何读取数据记录 RecordReader实际上定义了如何将数据记录转化为一个(key,value)对的详细方法，并将数据记录传给Mapper类 TextInputFormat提供了LineRecordReader，读入一个文本行数据记录 Mapper 每一个Mapper类的实例生成了一个Java进程，负责处理某一个InputSplit上的数据 用Mapper.Context提供给每一个Mapper函数，用来提供上面两个对象的功能 Combiner 合并相同key的键值对，减少partitioning时候的数据通信开销 conf.setCombinerClass(Reduce.class); 是在本地执行的一个Reducer，满足一定的条件才能够执行。 Partitioner &amp; Shuffle 在Map工作完成之后，每一个 Map函数会将结果传到对应的Reducer所在的节点，此时，用户可以提供一个Partitioner类，用来决定一个给定的(key,value)对传给哪个Reduce节点 Sort 传输到每一个Reducer节点上的、将被所有的Reduce函数接收到的Key,value对会被Hadoop自动排序（即Map生成的结果传送到某一个节点的时候，会被自动排序） Reducer 做用户定义的Reduce操作 输出环境编程接口是Reducer.Context 文件输出格式OutputFormat 写入到HDFS的所有OutputFormat都继承自FileOutputFormat 每一个Reducer都写一个文件到一个共同的输出目录，文件名是part-nnnnn，其中nnnnn是与每一个reducer相关的一个号（partition id） FileOutputFormat.setOutputPath() JobConf.setOutputFormat() OutputFormat: Description TextOutputFormat Default; writes lines in “key \\t value” form SequenceFileOutputFormat Writes binary files suitable for reading into subsequent MapReduce jobs NullOutputFormat Disregards its inputs RecordWriter TextOutputFormat实现了缺省的LineRecordWriter，以“key\\t value”形式输出一行结果 Hadoop 分布式文件系统HDFS HDFS的基本特征 模仿Google GFS设计实现 存储极大数目的信息（terabytes or petabytes），将数据保存到大量的节点当中；支持很大的单个文件。 提供数据的高可靠性和容错能力，单个或者多个节点不工作，对系统不会造成任何影响，数据仍然可用。通过一定数量的数据复制保证数据存储的可靠性和出错恢复能力。 提供对数据的快速访问；并提供良好的可扩展性，通过简单加入更多服务器快速扩充系统容量，服务更多的客户端。 与GFS类似，HDFS是MapReduce的底层数据存储支撑，并使得数据尽可能根据其本地局部性进行访问与计算。 HDFS对顺序读进行了优化，支持大量数据的快速顺序读出，代价是对于随机的访问负载较高。 数据支持一次写入，多次读取；不支持已写入数据的更新操作，但允许在文件尾部添加新的数据 数据不进行本地缓存（文件很大，且顺序读没有局部性） 基于块的文件存储，默认的块的大小是64MB 减少元数据的量 有利于顺序读写（在磁盘上数据顺序存放） 多副本数据块形式存储，按照块的方式随机选择存储节点，默认副本数目是3 HDFS可靠性与出错恢复 DataNode节点的检测 心跳：NameNode 不断检测DataNode是否有效 若失效，则寻找新的节点替代，将失效节点数据重新分布 集群负载均衡 数据一致性: 校验和checksum 主节点元数据失效 Multiple FsImage and EditLog Checkpoint HDFS文件系统操作命令 命令 说明 -ls path 显示所有目录与文件，包含拥有者、权限、修改时间等 -lsr path 同上，递归显示 -put localSrc dest 从Local传输文件、目录到HDFS -copyFromLocal localSrc dest 同上 -moveFromLocal localSrc dest 同上，但会删除Local源文件、目录 -get [-crc] src localDest 从HDFS传输文件、目录到Local -copyToLocal [-crc] src localDest 同上 -moveToLocal [-crc] src localDest 同上，但会删除HDFS源文件、目录 -mv src dest 在HDFS内移动文件、目录 -cp src dest 在HDFS内复制文件、目录 -rm path 删除文件、空目录 -rmr path 递归删除文件、空目录 -mkdir path 递归创建目录 -touchz path 以当前时间戳创建新文件，当已存在且大小不为0时返回0 -cat filename 显示文件内容 -tail [-f] file 显示文件最后1KB内容 -test -[ezd] path 当路径存在、大小不为0、为目录时返回1 -chmod [-R] mode,mode,... path... 更改文件权限 -chown [-R] [owner][:[group]] path... 更改文件拥有者 -chgrp [-R] group path... 更改文件拥有者的组 -du path 以Byte形式显示所有匹配文件的磁盘使用量 -dus path 显示总的磁盘使用量 -getmerge src localDest [addnl] 将所有匹配文件复制到LocalDest中 -setrep [-R] [-w] rep path 更改目标副本数目 -stat [format] path 显示文件、目录信息. -help cmd 显示关于cmd的帮助信息。-可省略 在MapReduce程序中使用HDFS 通过fs.default.name的配置选项，Hadoop MapReduce程序可以自动从NameNode中获得文件的情况 HDFS接口包括： 命令行接口 Hadoop MapReduce Job隐含的输入 Java程序直接操作 libhdfs从c/c++程序中操作 HDFS权限控制与安全特性 类似于POSIX的安全特性，不完全，主要预防操作失误 不是一个强的安全模型，不能保证操作的完全安全性 用户:当前登录的用户名, 即使用Linux自身设定的用户与组的概念 超级用户: 用于启动 bin/start-all.sh 或者 bin/start-dfs.sh 的用户名 超级用户组：配置参数：dfs.permissions.supergroup Hadoop HDFS的编程 // TODO：暂时省略，有时间再加 编程示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.Scanner;import java.io.IOException;import java.io.File;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FSDataInputStream;import org.apache.hadoop.fs.FSDataOutputStream;import org.apache.hadoop.fs.FileStatus;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;public class resultFilter{ public static void main(String[] args) throws IOException { Configuration conf = new Configuration(); // 以下两句中，hdfs和local分别对应HDFS实例和本地文件系统实例 FileSystem hdfs = FileSystem.get(conf); FileSystem local = FileSystem.getLocal(conf); Path inputDir, localFile; FileStatus[] inputFiles; FSDataOutputStream out = null; FSDataInputStream in = null; Scanner scan; String str; byte[] buf; int singleFileLines; int numLines, numFiles, i; inputDir = new Path(args[0]); singleFileLines = Integer.parseInt(args[3]); try { inputFiles = hdfs.listStatus(inputDir); //获得目录信息 numLines = 0; numFiles = 1; //输出文件从1开始编号 localFile = new Path(args[1]); if(local.exists(localFile)) local.delete(localFile, true); //若目标路径存在，则删除之 for (i = 0; i&lt;inputFiles.length; i++) { if(inputFiles[i].isDir() == true) //忽略子目录 continue; System.out.println(inputFiles[i].getPath().getName()); in = hdfs.open(inputFiles[i].getPath());scan = new Scanner(in); while (scan.hasNext()) { str = scan.nextLine(); if(str.indexOf(args[2])==-1) continue; //如果该行没有match字符串，则忽略 numLines++; if(numLines == 1) //如果是1，说明需要新建文件了 { localFile = new Path(args[1] + File.separator + numFiles); out = local.create(localFile); //创建文件 numFiles++; } buf = (str+&quot;\\n&quot;).getBytes(); out.write(buf, 0, buf.length); //将字符串写入输出流 if(numLines == singleFileLines) //如果已满足相应行数，关闭文件 { out.close(); numLines = 0; //行数变为0，重新统计 } }//end of while scan.close(); in.close(); }//end of for if(out != null) out.close(); } //end of try catch (IOException e) { e.printStackTrace();} } //end of main} //end of resultFilter Hadoop系统安装运行与程序开发 // TODO: 暂时省略 MapReduce算法设计 MapReduce可解决哪些算法问题？ MapReduce 可广泛应用于搜索引擎（文档倒排索引，网页链接图分析与页面排序等）、Web日志分析、文档分析处理、机器学习、机器翻译等各种大规模数据并行计算应用领域各类大规模数据并行处理算法。 基本算法 各种全局数据相关性小、能适当划分数据的计算任务，如： 分布式排序 分布式GREP(文本匹配查找) 关系代数操作：如：选择，投影，求交集、并集，连接，成组，聚合… 矩阵向量相乘、矩阵相乘 词频统计(word count)，词频重要性分析(TF-IDF) 单词同现关系分析：典型的应用如从生物医学文献中自动挖掘基因交互作用关系 文档倒排索引 … 复杂算法或应用 Web搜索:：网页爬取、倒排索引、网页排序、搜索算法 Web访问日志分析：分析和挖掘用户在Web上的访问、购物行为特征、以定制个性化用户界面或投放用户感兴趣的产品广告 数据/文本统计分析：如科技文献引用关系分析和统计、专利文献引用分析和统计 图算法：并行化宽度优先搜索(最短路径问题，可克服Dijkstra串行算法的不足)，最小生成树，子树搜索、比对Web链接图分析算法PageRank，垃圾邮件连接分析 聚类(clustring)：文档聚类、图聚类、其它数据集聚类 相似性比较分析算法：字符序列、文档、图、数据集相似性比较分析 基于统计的文本处理：最大期望(EM)统计模型，隐马可夫模型(HMM)，…… 机器学习：监督学习、无监督学习、分类算法（决策树、SVM…) 数据挖掘： 统计机器翻译 生物信息处理：DNA序列分析比对算法Blast：双序列比对、多序列比对生物网络功能模块(Motif)查找和比对 广告推送与推荐系统 … 大数据集上的简单算法能比小数据集上的复杂算法产生更好的结果！ MapReduce中可编程控制的阶段 Mapper / Reducer Initialize: setup() map() / reduce() Close: cleanup() Shuffle Partitioner() 默认：HashPartitioner() (hadoop v0.21.0) Sort 通过自定义的比较函数实现排序 MapReduce排序算法 Sort Algorithm in MapReduce map(k1, *) -&gt; (k1, *) // Identity function shuffle and sort (1) total-order partitioning (2) local sorting reduce(k1, *) -&gt; (k1, *) // Identity function A customized total-order Partitioner recall that shuffle phase needs a Partitioner to partition the key space Partitioner (1) 如何避免在某些Reducer上聚集过多的数据而拖慢了整个程序 (2) 当有大量的key要分配到多个partition（也就是Reducer）时，如何高效地找到每个Key所属的partition 对Partitioner的要求 划分均匀 查找快速 TotalOrderPartitioner for TeraSort 一个提供全序划分的Partitioner 从Hadoop v0.19.0开始正式发布在库类中 为满足两个要求所采用的策略 通过采样获取数据的分布：预读一小部分数据采样(sample)，对采样数据排序后均分，假设有N个reducer，则取得N-1个分割点，以这些分割点划分区间 构建高效的划分模型：若Key 的数据类型是BinaryComparable的，即可以直接按字节比较大小（如Text），则以key构造TrieTree；否则以二分查找来确定key的所属区间 Trie Tree, 一种高效的适于查找的数据结构，两级的trie可以最多对应大约256*256个reducer, 通常是足够的 MapReduce单词同现分析算法 单词同现矩阵 语料库的单词同现矩阵是一个二维 N×N矩阵 N是语料库的词汇量（即，不同单词的数目） 矩阵元素M[i, j] 代表单词W[i] 与单词W [j]在一定范围内同现的次数（一个语句中，一个段落中，一篇文档中，或文本串中一个宽度为M个单词的窗口中，这些都依具体问题而定） 构建单词同现矩阵 同现矩阵的空间开销为 O(n2)O(n^2)O(n2)，因此难以直接放入内存中计算 简单地在单机上的实现，内存与磁盘之间的换页会使任务的执行十分缓慢 M.R. Algorithm (“pairs” approach) 伪代码: 123456789101112class Mapper method Map(docid a, doc d) for all term w ∈ doc d do for all term u ∈ Neighbors(w) do //Emit count for each co-occurrence Emit(pair (w, u), count 1) class Reducer method Reduce(pair p; counts [c1, c2,…]) s ← 0 for all count c in counts [c1, c2,…] do s ← s + c //Sum co-occurrence counts Emit(pair p, count s) 算法的扩展 同现定义 Neighbors(w)为其他形式时该怎么实现？ 根据同现关系的不同，可能需要实现和定制不同的FileInputFormat和RecordReader 同现关系可扩展为从大量观察数据中进行任意离散关联事件的分析和数据挖掘 类似应用问题 零售商通过分析大量的交易记录，识别出关联的商品购买行为（如：“啤酒和纸尿裤”的故事） 从生物医学文献中自动挖掘基因交互作用关系 MapReduce文档倒排索引算法 Inverted Index(倒排索引)是目前几乎所有支持全文检索的搜索引擎都要依赖的一个数据结构。基于索引结构，给出一个词(term)，能取得含有这个term的文档列表(the list of documents) Web Search中的问题主要分为三部分： crawling(gathering web content) indexing(construction of the inverted index) retrieval(ranking documents given a query) crawling和indexing都是离线的，retrieval是在线、实时的 专利文献数据分析 HBase与Hive程序设计 HBase基本工作原理 HBase的设计目标和功能特点 针对 HDFS 缺少结构化半结构化数据存储访问能力的缺陷，提供一个分布式数据管理系统，解决大规模的结构化和半结构化数据存储访问问题 提供基于列存储模式的大数据表管理能力 可存储管理数十亿以上的数据记录，每个记录可包含百万以上的数据列 试图提供随机和实时的数据读写访问能力 具有高可扩展性、高可用性、容错处理能力、负载平衡能力、以及实时数据查询能力 HBase数据模型 逻辑数据模型 数据存储逻辑模型与 BigTable 类似 但实现上有一些不同之处。 是一个分布式多维表，表中的数据通过： 一个行关键字：row key 一个列关键字：column key 一个时间戳：time stamp 进行索引和查询定位的。 按照列存储的稀疏行 列矩阵。物理存储格式上按逻辑模型中的行进行分割，并按照列族存储。 值为空的列不予存储，以节省存储空间 HBase的基本构架 由一个 MasterServer 和由一组子表数据区服务器 RegionServer 构成，分别存储逻辑大表中的部分数据 大表中的底层数据存于 HDFS 中 HBase的数据存储和管理 与 BigTable 类似，大表被分为很多个子表（ Region ），每个子表存储在一个子表服务器 RegionServer上 每个子表中的数据区 Region 由很多个数据存储块 Store 构成 而每个 Store 数据块又由存放在内存中的 memStore 和存放在文件中的 StoreFile 构成 HBase基本操作与编程方法示例 HBase shell 操作 创建表格与列举表格：create 'table', 'column', ... 插入数据：put 'table', 'column', ... 描述表信息：describe ''table 扫描数据：scan 'table' 限制列进行扫描：scan 'table', {COLUMN=&gt;'cloumn:'} HBase中的disable和enable Hive基本工作原理 在Hadoop上用SQL进行数据分析 Hive 包括一个高层语言的执行引擎，类似于 SQL 的执行引擎 Hive 建立在 Hadoop 的其它组成部分之上，包括 Hive 依赖于HDFS 进行数据保存，依赖于 MapReduce 完成查询操作 Hive的组成模块 Hive的系统结构 Hive的数据模型 元数据存储：Metastore 数据的物理分布情况 Hive系统的配置 高级MapReduce编程技术 复合键值对的使用 用复合键让系统完成排序 将value中需要排序的部分加入到key中形成复合键，这样将能利用MapRecue系统的排序功能完成排序。 但需要实现一个新的Partitioner，保证原来同一key值的键值对最后分区到同一个Reduce节点上。 把小的键值对合并成大的键值对 通常一个计算问题会产生大量的键值对，为了减少键值对传输和排序的开销，一些问题中的大量小的键值对可以被合并成一些大的键值对 用户自定义数据类型 Hadoop内置的数据类型 用户自定义数据类型 需要实现Writable接口 作为key或者需要比较大小时则需要实现WritableComparable接口","link":"/p/c27cf766/"},{"title":"Markdown language","text":"Markdown 语言的简单使用 Markdown 简介 摘选自 Markdown - wikipedia Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 John Gruber 在 2004 年创造了 Markdown 语言，在语法上有很大一部分是跟亚伦·斯沃茨（Aaron Swartz）共同合作的。这个语言的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的 XHTML (或是HTML)”。 其中最重要的设计是可读性，也就是说这个语言应该要能直接在字面上的被阅读，而不用被一些格式化指令标记 (像是 RTF 与 HTML)。 因此，它是现行电子邮件标记格式的惯例，虽然它也借鉴了很多早期的标记语言，如：setext、Texile、reStructuredText。 许多网站都使用 Markdown 或是其变种，例如：GitHub、reddit、Diaspora、Stack Exchange、OpenStreetMap 与 SourceForge 让用户更利于讨论。 Markdown同时还是一个由Gruber编写的Perl脚本：Markdown.pl。它把用markdown语法编写的内容转换成有效的、结构良好的XHTML或HTML内容，并将左尖括号(‘&lt;’)和&amp;号替换成它们各自的字符实体引用。它可以用作单独的脚本，Blosxom和Movable Type的插件又或者BBEdit的文本过滤器. Markdown也已经被其他人用Perl和别的编程语言重新实现，其中一个Perl模块放在了CPAN(Text::Markdown)上。它基于一个BSD风格的许可证分发并可以作为几个内容管理系统的插件。 宗旨 Markdown 语法说明 (简体中文版) - wowubuntu Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像强调。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 Markdown 语法 标题 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 显示如下： 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 一级和二级标题还有一种写法： 12345一级标题===================二级标题-------------------- 显示如下： 一级标题 二级标题 换行 在行尾输入两个或以上的空格，然后回车 列表 无序列表使用星号、加号或是减号作为列表标记： 123- 列表1- 列表2- 列表3 显示如下： 列表1 列表2 列表3 有序列表则使用数字接着一个英文句点： 1231. 列表12. 列表23. 列表3 显示如下： 列表1 列表2 列表3 水平分区线 12345* * *********- - ---------------------------------------- 链接 1[显示的文字](url) 显示如下： 显示的文字 另一种选择是，链接地址可以放在段落后面的脚注，前面放上链接引用标签区分。举例说，先在内容行内插入以下内容： 1[链接文字][链接引用标签] 然后在段落的后面（或者文档的结尾）放上以下内容，就可以生成一个链接： 1[链接引用标签]: 链接地址 &quot;链接标题&quot; 图片 1![](url) 显示如下： 引用： 单行引用： 12&gt; 引用的文字&gt;&gt; 嵌套的引用 显示如下： 引用的文字 嵌套的引用 单行代码引用： 1`单行代码` 显示如下： 单行代码 多行代码引用： ``` 多行代码引用 ``` 字体 粗体： 1**粗体文字** 显示如下： 粗体文字 斜体： 1*斜体文字* 显示如下： 斜体文字 表格 12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 显示如下： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 : 为对齐方式， 缺省则为左对齐 (The End)","link":"/p/c3b2e8c9/"},{"title":"Markdown 中插入 latex 公式","text":"在 Markdown 中使用 Latex 渲染公式 数学公式 &amp;&amp; 上下标 &amp;&amp; 括号 &amp;&amp; 分数 &amp;&amp; 开方 &amp;&amp; 希腊字母 关系运算符 &amp;&amp; 集合运算符 &amp;&amp; 对数运算符 &amp;&amp; 三角运算符 &amp;&amp; 微积分运算符 参考: https://blog.csdn.net/gsww404/article/details/78684278 插入数学公式 在Markdown中插入数学公式的语法是 $数学公式$ 和 $$数学公式$$ 。 行内公式是可以让公式在文中与文字或其他东西混编，不独占一行。 质能方程 $E = mc^2$ E=mc2E = mc^2E=mc2 独立公式使公式单独占一行，不与文中其他文字等混编。 质能方程 $$E = mc^2$$ E=mc2E = mc^2 E=mc2 $$x = 100 * y + z - 10 / 33 + 10 % 3$$ x=100∗y+z−10/33+10x=100*y+z-10/33+10 x=100∗y+z−10/33+10 上下标 使用 ^ 来表示上标，_ 来表示下标，同时如果上下标的内容多于一个字符，可以使用 {} 来将这些内容括起来当做一个整体。 与此同时，上下标是可以嵌套的。 $$x = a_{1}^n + a_{2}^n + a_{3}^n$$ x=a1n+a2n+a3nx = a_{1}^n + a_{2}^n + a_{3}^n x=a1n​+a2n​+a3n​ 如果希望左右两边都能有上下标，可以使用 \\sideset 语法 $$\\sideset{^1_2}{^3_4}A$$ \\sideset{^1_2}{^3_4}A 括号 () ，[] 和 | 都表示它们自己，但是 {} 因为有特殊作用因此当需要显示大括号时一般使用 \\lbrace \\rbrace 来表示。 $$f(x, y) = 100 * \\lbrace[(x + y) * 3] - 5\\rbrace$$ f(x,y)=100∗{[(x+y)∗3]−5}f(x, y) = 100 * \\lbrace[(x + y) * 3] - 5 \\rbrace f(x,y)=100∗{[(x+y)∗3]−5} 分数 分数使用 \\frac{分母}{分子} 这样的语法，不过推荐使用 \\cfrac 来代替 \\frac，显示公式不会太挤。 $$\\frac{1}{3} \\cfrac{1}{3}$$ 1313\\frac{1}{3} \\cfrac{1}{3} 31​31​ 开方 开方使用\\sqrt[次数]{被开方数}这样的语法 $$\\sqrt[3]{X}$$ X3\\sqrt[3]{X} 3X​ $$\\sqrt{5 - x}$$ 5−x\\sqrt{5 - x} 5−x​ 常用符号 代码 显示 代码 显示 \\sum ∑\\sum∑ \\alpha α 数学符号表 数学模式重音符 希腊字母 代码 大写 代码 小写 A A \\alpha α B B \\beta β \\Gamma Γ \\gamma γ \\Delta Δ \\delta δ E E \\epsilon ϵ Z Z \\zeta ζ H H \\eta η \\Theta Θ \\theta θ I I \\iota ι K K \\kappa κ \\Lambda Λ \\lambda λ M M \\mu μ N N \\nu ν \\Xi Ξ \\xi ξ O O \\omicron ο \\Pi Π \\pi π P P \\rho ρ \\Sigma Σ \\sigma σ T T \\tau τ \\Upsilon Υ \\upsilon υ \\Phi Φ \\phi ϕ X X \\chi χ \\Psi Ψ \\psi ψ \\Omega Ω \\omega ω 二元关系符 二元运算符 大尺寸运算符 符号 代码 ′ \\prime ∫ \\int ∬ \\iint ∭ \\iiint ∬∬ \\iiiint ∮ \\oint lim \\lim ∞ \\infty ∇ \\nabla d \\mathrm{d} 箭头 定界符 其他符号","link":"/p/857a870e/"},{"title":"搭建 Hexo 其一: 安装 Hexo","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 官方中文文档 安装 安装依赖 Node.js (Should be at least nodejs 6.9) Git 安装 Git Windows：下载并安装 git. Mac：使用 Homebrew, MacPorts ：brew install git;或下载 安装程序 安装。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core 安装 Node.js Windows 推荐使用 安装程序 进行安装. 安装时, 请勾选Add to PATH选项. 或者使用 Git Bash 等程序执行 Linux 的相关命令. Linux 安装 Node.js 的最佳方式是使用 nvm。 cURL: 1curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh Wget: 1wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。 1nvm install stable 或者您也可以下载 安装程序 来安装。 安装 Hexo 所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1npm install -g hexo-cli 建站 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml 网站的 配置 信息，您可以在此配置大部分的参数。 package.json 应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 12345678910111213141516171819package.json{ &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: { &quot;version&quot;: &quot;&quot; }, &quot;dependencies&quot;: { &quot;hexo&quot;: &quot;^3.8.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;, &quot;hexo-server&quot;: &quot;^0.3.3&quot; }} scaffolds 模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes 主题 文件夹。Hexo 会根据主题来生成静态页面。","link":"/p/473e4e11/"},{"title":"搭建 Hexo 其二: 配置 Hexo","text":"配置 网站的 配置 信息存储在 _config.yml 中，您可以在此配置大部分的参数。 主要的网站参数如下: 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 en zh-cn timezone 网站时区 Hexo 默认使用您电脑的时区。时区列表。 description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。 author参数用于主题显示文章的作者。 网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的永久链接格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。 文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 相对地址 默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为example.com,您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。 分类 &amp; 标签 参数 描述 默认值 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 日期 / 时间格式 Hexo 使用 Moment.js 来解析和显示时间。 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 H:mm:ss 分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 扩展 参数 描述 theme 当前主题名称。值为false时禁用主题 deploy 部署部分的设置 插件的安装 hexo-deployer-git 用于使用 git 部署网站 安装: 1npm install --save hexo-deployer-git 配置文件中添加: _config.yml12345deploy: type: git repo: git@github.com:xxxxx/xxxxx.github.io.git # branch: gh-pages # message: [message] hexo-directory-category 将博文按文件夹自动添加分类, 可以实现多层文件夹嵌套分类. 安装: 1npm install --save hexo-directory-category 配置文件中添加: _config.yml1234# https://github.com/zthxxx/hexo-directory-categoryauto_dir_categorize: enable: true # options:true, false; default is true force: false # options:true, false; default is false hexo-abbrlink 为文章自动生成永久链接, 可以设置链接的长度和进制. 安装: 1npm install --save hexo-abbrlink 配置文件中添加: _config.yml123456# https://github.com/rozbo/hexo-abbrlinkpermalink: p/:abbrlink/permalink_defaults:abbrlink: alg: crc32 # alg：crc16 (default) and crc32 rep: hex # rep：dec (default) and hex config _config.yml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: CZCCsubtitle:description:keywords:author: Chenglanguage: entimezone:# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://czccc.github.ioroot: /permalink: :title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -updated# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: repo: # branch: gh-pages # message: [message]# https://github.com/zthxxx/hexo-directory-categoryauto_dir_categorize: enable: true # options:true, false; default is true force: false # options:true, false; default is false","link":"/p/623c3d8b/"},{"title":"搭建 Hexo 其三: icarus 主题","text":"A simple, delicate, and modern theme for the static site generator Hexo. icarus 是一个十分简洁高效的 Hexo 主题, 并且支持多种语言, 页面使用响应式布局, 并且使用多个小部件展示不同的内容, 设计得非常漂亮! 本博客便基于 icarus 主题, 并进行了一定的自定义. 官方 Github 地址 个人修改版地址 安装 icarus 推荐使用 git clone 安装: 在 Hexo 的文件夹下, 执行命令: 下面程序中使用的是我修改过的主题, 如果想使用官方主题, 请改一下 Git 仓库地址 1git clone https://github.com/czccc/hexo-theme-icarus.git themes/icarus 如果想要将 icarus 作为 submodule 来安装, 可以使用下面的命令: 1git submodule add https://github.com/czccc/hexo-theme-icarus.git themes/icarus 然后, 在站点配置文件中, 将 theme 改为 icarus : _config.yml1theme: icarus 然后执行一次 hexo g 操作, 会在 themes/icarus 生成一个 _config.yml 文件, 即为此主题的配置文件. 重新合并官方分支 首先, 在 Github 上 fork 了 icarus 仓库后, 那么 fork 得到的项目并不会跟着原仓库进行更新, 那么如果这时候还想要合并原仓库的程序, 以改善某些 bug, 并使用新的特性, 有下面两种方式. fetch -&gt; merge 首先, 跟上游仓库同步代码之前，必须配置过 remote，指向上游仓库 。 12345678git remote add ppoffice https://github.com/ppoffice/hexo-theme-icarus# 再次执行命令 git remote -v 检查是否成功。git remote -v# origin git@github.com:czccc/hexo-theme-icarus (fetch)# origin git@github.com:czccc/hexo-theme-icarus (push)# ppoffice https://github.com/ppoffice/hexo-theme-icarus (fetch)# ppoffice https://github.com/ppoffice/hexo-theme-icarus (push) 然后, 从上游仓库获取到分支，及相关的提交信息，它们将被保存在本地的 ppoffice/master 分支 12345678910git fetch ppoffice# remote: Counting objects: 75, done.# remote: Compressing objects: 100% (53/53), done.# remote: Total 62 (delta 27), reused 44 (delta 9)# Unpacking objects: 100% (62/62), done.# From https://github.com/ppoffice/hexo-theme-icarus# * [new branch] dev -&gt; ppoffice/dev# * [new branch] gh-pages -&gt; ppoffice/gh-pages# * [new branch] master -&gt; ppoffice/master# * [new branch] site -&gt; ppoffice/site 最后, 切换到本地的 master 分支, 把 ppoffice/master 分支合并到本地的 master 分支，本地的 master 分支便跟上游仓库保持同步了，并且没有丢失你本地的修改。 123456789101112git checkout master# Already on 'master'# Your branch is up to date with 'origin/master'.git merge ppoffice/master# Updating a422352..5fdff0f# Fast-forward# README | 9 -------# README.md | 7 ++++++# 2 files changed, 7 insertions(+), 9 deletions(-)# delete mode 100644 README# create mode 100644 README.md 提示：同步后的代码仅仅是保存在本地仓库，记得 push 到 Github 哟。 参考 如何同步 Github fork 出来的分支 https://github.com/selfteaching/the-craft-of-selfteaching/issues/67 修改主题配置 网站基本设置 _config.yml1234567# 图片文件可以存放至 themes/icarus/source/images/xxx# 网站 iconfavicon: /images/favicon.jpg# 网站左上角的主页图标logo: /images/fav.png 设置侧边栏滚动类型 true : 固定 false : 滚动 _config.yml1234567# Sidebar settings.# Note: 只有当侧边栏至少包含一个部件时, 才会显示此侧边栏sidebar: left: sticky: false right: sticky: false 改为两栏布局 可否将内容三栏格式改成两栏？ 将主题下的 _config.yml 复制一份, 改为 _config.post.yml, 再在里面重新排列 Widget 的布局, 将所有的 Widget 都调到左边, 并适当删去不需要的 Widget, 便可实现自动的双栏布局. 修改双栏布局宽带 在改成双栏布局后, 会导致文章详情页所占的总宽度变短. 为了解决这个问题, 可以通过更改样式文件. 具体的修改内容如下: layout/layout.jsx12345 'is-12': columnCount === 1,// 修改宽度为 8 9 9// 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2, 'is-8-tablet is-9-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 include/style/responsive.styl1234567891011121314/* 修改对应的布局 */+widescreen() .is-1-column .container, .is-2-column .container /* max-width: $desktop - 2 * $gap */ /* width: $desktop - 2 * $gap */ max-width: $widescreen - 2 * $gap width: $widescreen - 2 * $gap+fullhd() .is-2-column .container /* max-width: $widescreen - 2 * $gap */ /* width: $widescreen - 2 * $gap */ max-width: $fullhd - 2 * $gap width: $fullhd - 2 * $gap layout/common/widgets.jsx123456789function getColumnSizeClass(columnCount) { switch (columnCount) { case 2: // 修改为 4 3 3 // return 'is-4-tablet is-4-desktop is-4-widescreen'; return 'is-4-tablet is-3-desktop is-3-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } 固定目录卡片 在 icarus 3.0 中, 类似于 toc, tag 等小部件不在默认的主题文件家中, 而是集成到了 hexo-component-inferno 这个依赖模块中. 因此想要改动这些内容的话, 需要手动地将toc.jsx 文件复制到 layout/widget/toc.jsx 中. 具体内容参考 请教几个3.0版本修改的问题 因为在使用时并不想简单地将左右两栏固定, 而是想要实现对于不同的卡片, 设置不同的滚动方式. 比如, 对于文章内现实的目录卡片, 设置成固定, 并进入滚动条, 代码修改的内容如下: 加入了 column-left is-sticky 这两个 class 设置滚动条: style=&quot;max-height: calc(100vh - 5rem); overflow-y: auto;&quot; layout/widget/toc.jsx12345678910111213141516171819202122// 第 5 行const { tocObj: getTocObj, unescapeHTML } = require('hexo-util');const { Component } = require('inferno');const { cacheComponent } = require('hexo-component-inferno/lib/util/cache');// 第 112 行 render() { const toc = getToc(this.props.content); if (!Object.keys(toc).length) { return null; } // return &lt;div class=&quot;card widget&quot; id=&quot;toc&quot;&gt; return &lt;div class=&quot;card widget column-left is-sticky&quot; id=&quot;toc&quot;&gt; &lt;div class=&quot;card-content&quot;&gt; &lt;div class=&quot;menu&quot; style=&quot;max-height: calc(100vh - 5rem); overflow-y: auto;&quot;&gt; &lt;h3 class=&quot;menu-label&quot;&gt;{this.props.title}&lt;/h3&gt; {this.renderToc(toc)} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;; } 标题自动编号 在文章的样式文件中加入下面的内容, 便可以实现标题的自动编号. include/style/article.styl1234567.content {counter-reset:section}.content h1{counter-reset:sub-section}.content h2{counter-reset:composite}.content h3{counter-reset:detail}.content h1:before{content:counter(section) &quot;. &quot;;counter-increment:section;font-family:$family-sans-serif}.content h2:before{content:counter(section) &quot;.&quot; counter(sub-section) &quot;. &quot;;counter-increment:sub-section;font-family:$family-sans-serif}.content h3:before{content:counter(section) &quot;.&quot; counter(sub-section) &quot;.&quot; counter(composite) &quot;. &quot;;counter-increment:composite;font-family:$family-sans-serif} 添加鼠标悬浮阴影 为 card 加入一个 hover 的属性, 便可实现悬浮阴影. include/style/card.styl123456.card overflow: visible border-radius: $card-radius &amp;:hover box-shadow: 0 6px 15px rgba(0,0,0,0.15), 0 0 1px rgba(0,0,0,0.1) 加入末尾版权说明 layout/common/article.jsx123456789101112131415 {/* Content/Excerpt */} &lt;div class=&quot;content&quot; dangerouslySetInnerHTML={{ __html: index &amp;&amp; page.excerpt ? page.excerpt : page.content }}&gt;&lt;/div&gt;+ {!index &amp;&amp; page.layout !== 'page' ?+ &lt;ul class=&quot;post-copyright&quot;&gt;+ &lt;li&gt;&lt;strong&gt;本文标题：&lt;/strong&gt;&lt;a href={url_for(page.permalink)}&gt;{page.title}&lt;/a&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;本文作者：&lt;/strong&gt;&lt;a href={url_for('/')}&gt;{config.author}&lt;/a&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;本文链接：&lt;/strong&gt;&lt;a href={url_for(page.permalink)}&gt;{page.permalink}&lt;/a&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;发布时间：&lt;/strong&gt;{page.date.format(&quot;YYYY-MM-DD&quot;)}&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;版权声明：&lt;/strong&gt;本博客所有文章除特别声明外，均采用 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh&quot; rel=&quot;external nofollow&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt; 许可协议。转载请注明出处！&lt;/li&gt;+ &lt;/ul&gt; : null+ }+ &lt;br&gt;&lt;/br&gt; {/* Tags */} {!index &amp;&amp; page.tags &amp;&amp; page.tags.length ? &lt;div class=&quot;article-tags size-small is-uppercase mb-4&quot;&gt; &lt;span class=&quot;mr-2&quot;&gt;#&lt;/span&gt; 更改样式: include/style/article.styl12345678.post-copyright font-size: 1rem letter-spacing: 0.02rem word-break: break-all margin: 2.5rem 0 0 padding: 1rem 1rem border-left: 3px solid #FF1700 background-color: #F9F9F9 在元数据前命加入图标 此处更改较多且比较繁琐, 因此不再贴出代码, 详情请看 commit 记录 启用静态搜索 _config.yml12345# Search plugin settings# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Searchsearch: # Name of the search plugin type: insight 使用 valine 评论 Valine 诞生于2017年8月7日，是一款基于Leancloud的快速、简洁且高效的无后端评论系统。 理论上支持但不限于静态博客，目前已有Hexo、Jekyll、Typecho、Hugo、Ghost 等博客程序在使用Valine。 特性: 快速 安全 Emoji 😉 无后端实现 MarkDown 全语法支持 轻量易用(~15kb gzipped) 文章阅读量统计 v1.2.0+ 获取APP ID 和 APP Key 请先登录或注册 LeanCloud, 进入控制台后点击左下角创建应用 应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了 _config.yml12345678910# Comment plugin settings# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Commentcomment: # 评论插件名称 type: valine app_id: # (必填) LeanCloud application id app_key: # (必填) LeanCloud application key notify: false # (可选) 是否接收邮件通知 verify: false # (可选) 是否显示验证码 placeholder: ヾﾉ≧∀≦)o来啊，快活啊! # (可选) 评论框占位符 启用分享插件 使用简单的 sharejs 插件实现分享 使用 npm 进行安装 1npm install social-share.js 并且在 _config.yml 中修改: _config.yml12345# Share plugin settings# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Shareshare: # Share plugin name type: sharejs","link":"/p/bdc060a9/"},{"title":"Hexo 中 Latex 公式渲染问题","text":"问题分析 不难发现，上边既然有成功的渲染，就说明 MathJax 本身没有罢工。而且，仔细观察还会发现，第一个公式中最开始两个*中间的字体变成了斜体；第二个公式中最开始两个_也是同样的情况。审查元素发现，第一个公式中的斜体部分被渲染成了``标签： 1&lt;em&gt;})=\\frac{x-x^&lt;/em&gt; 这样来看答案就很清楚了：这个错误是由 Markdown 渲染器（默认的是 hexo-renderer-marked ）引起的。Markdown 本身并不支持 Latex，在渲染时正则匹配到两个_或*就会把下划线替换成了``，于是到了 MathJax 渲染公式时就彻底懵了。 解决办法也很简单：使用 hexo-renderer-kramed 替换 Hexo 默认的渲染器 hexo-renderer-marked。 替换默认渲染引擎 hexo-renderer-kramed 是 hexo-renderer-marked 的 Fork 修改版，仅针对 MathJax 渲染的语义冲突问题进行了修改，因此可以放心使用。在 Hexo 根目录下执行以下命令替换默认渲染引擎： 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 更换渲染引擎后，整行公式就可以正常显示了，然而行内公式还是会遇到标签语义冲突的问题。在 Markdown 语法中，用$$包括起来的内容表示整行公式，用$包括起来的内容表示行内公式。之所以行内公式的渲染依然存在问题，是因为 hexo-renderer-kramed 引擎同样存在语义冲突的问题。 解决语义冲突 在博客根目录下，找到node_modules/kramed/lib/rules/inline.js文件，在inline变量中做出如下修改： 12345678910111213141516171819var inline = { // escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_&gt;])/, 第 11 行, 将其修改为 escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/, autolink: /^&lt;([^ &gt;]+(@|:\\/)[^ &gt;]+)&gt;/, url: noop, html: /^&lt;!--[\\s\\S]*?--&gt;|^&lt;(\\w+(?!:\\/|[^\\w\\s@]*@)\\b)*?(?:&quot;[^&quot;]*&quot;|'[^']*'|[^'&quot;&gt;])*?&gt;([\\s\\S]*?)?&lt;\\/\\1&gt;|^&lt;(\\w+(?!:\\/|[^\\w\\s@]*@)\\b)(?:&quot;[^&quot;]*&quot;|'[^']*'|[^'&quot;&gt;])*?&gt;/, link: /^!?\\[(inside)\\]\\(href\\)/, reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/, nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/, reffn: /^!?\\[\\^(inside)\\]/, strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/, // em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 第 20 行，将其修改为 em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/, br: /^ {2,}\\n(?!\\s*$)/, del: noop, text: /^[\\s\\S]+?(?=[\\\\&lt;!\\[_*`$]| {2,}\\n|$)/, math: /^\\$\\$\\s*([\\s\\S]*?[^\\$])\\s*\\$\\$(?!\\$)/,}; 第 11 行的修改去掉了\\\\和{}，目的是在原基础上去掉对\\、{、}的转义 (escape)。 第 20 行的修改去掉了\\b_((?:__|[\\s\\S])+?)_\\b，目的是去掉对两个_之间内容的``标签转义。 也就是说，依然可以在 Hexo 中使用*表示斜体，但用_表示斜体就不会生效了。 另外在行内公式中，针对两个*的语义冲突依旧存在，目前来看没什么比较好的解决办法（摊手）。 hexo-renderer-marked 同样的，在查看 hexo-renderer-marked 中使用的 marked 程序后，可以定位到535行，进行如下修改： 123456789101112131415161718192021var inline = { escape: /^\\\\([!&quot;#$%&amp;'()*+,\\-./:;&lt;=&gt;?@\\[\\]\\\\^_`{|}~])/, autolink: /^&lt;(scheme:[^\\s\\x00-\\x1f&lt;&gt;]*|email)&gt;/, url: noop, tag: '^comment' + '|^&lt;/[a-zA-Z][\\\\w:-]*\\\\s*&gt;' // self-closing tag + '|^&lt;[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?&gt;' // open tag + '|^&lt;\\\\?[\\\\s\\\\S]*?\\\\?&gt;' // processing instruction, e.g. &lt;?php ?&gt; + '|^&lt;![a-zA-Z]+\\\\s[\\\\s\\\\S]*?&gt;' // declaration, e.g. &lt;!DOCTYPE html&gt; + '|^&lt;!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]&gt;', // CDATA section link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/, reflink: /^!?\\[(label)\\]\\[(?!\\s*\\])((?:\\\\[\\[\\]]?|[^\\[\\]\\\\])+)\\]/, nolink: /^!?\\[(?!\\s*\\])((?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]|[^\\[\\]])*)\\](?:\\[\\])?/, strong: /^__([^\\s_])__(?!_)|^\\*\\*([^\\s*])\\*\\*(?!\\*)|^__([^\\s][\\s\\S]*?[^\\s])__(?!_)|^\\*\\*([^\\s][\\s\\S]*?[^\\s])\\*\\*(?!\\*)/, // em: /^_([^\\s_])_(?!_)|^\\*([^\\s*&lt;\\[])\\*(?!\\*)|^_([^\\s&lt;][\\s\\S]*?[^\\s_])_(?!_|[^\\spunctuation])|^_([^\\s_&lt;][\\s\\S]*?[^\\s])_(?!_|[^\\spunctuation])|^\\*([^\\s&lt;&quot;][\\s\\S]*?[^\\s\\*])\\*(?!\\*|[^\\spunctuation])|^\\*([^\\s*&quot;&lt;\\[][\\s\\S]*?[^\\s])\\*(?!\\*)/, em: /^\\*([^\\s*&lt;\\[])\\*(?!\\*)|^\\*([^\\s&lt;&quot;][\\s\\S]*?[^\\s\\*])\\*(?!\\*|[^\\spunctuation])|^\\*([^\\s*&quot;&lt;\\[][\\s\\S]*?[^\\s])\\*(?!\\*)/, code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/, br: /^( {2,}|\\\\)\\n(?!\\s*$)/, del: noop, text: /^(`+|[^`])(?:[\\s\\S]*?(?:(?=[\\\\&lt;!\\[`*]|\\b_|$)|[^ ](?= {2,}\\n))|(?= {2,}\\n))/};","link":"/p/fcc15206/"},{"title":"Python-100-Day ① Python 基础","text":"Python 100 Days 的学习笔记 ① : Day 1 ~ Day 7 原项目地址 本文主要涉及: Python 基本 (变量, 程序结构, 函数参数) 基本函数 (print, input, 类型转换) 的使用 基本类型 (str, list, tuple, set, dict) 的使用 初识Python 确认Python的版本 在终端或命令行提示符中键入下面的命令。 1python --version 当然也可以先输入python进入交互式环境，再执行以下的代码检查Python的版本。 1234import sysprint(sys.version_info)print(sys.version) print 函数 函数参数表如下: 1print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) 参数的作用如下: value : 打印的数据, 可传入多个数据 sep : 多个数据之间的分隔符, 默认为空格 end : 打印结束后的分隔符, 默认为换行 file : 打印的输出位置, 默认为标准输出 flush : 是否强制刷新缓冲 input 函数 1input(prompt=None, /) 参数: prompt : 需要打印的提示文字 在 Python 3 中, input 函数默认接收到的是 string 类型, 返回值也为 string 类型 Python 命令行参数 (附加内容) Python 可以在命令行中输入相关参数从而执行不同的功能, 主要可以使用的参数有以下这些: 123456789101112131415usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...参数:-q : 在交互式解释器启动时, 不输出版本信息-V --version : 打印 Python 版本信息-VV : 打印更多版本信息 (包括版本时间, 系统)-d : 在解析是输出调试信息-h : 打印帮助信息后退出 (等同于 --help)-c cmd : 执行以字符串形式传入的程序 (用于执行简单的功能, 可以使用 ; 换行)-m mod : 作为脚本文件运行模块file : 从文件中读取程序- : 从 stdin 中读取程序arg ...: 给程序传递的参数 语言元素 变量命名 对于每个变量我们需要给它取一个名字，就如同我们每个人都有属于自己的响亮的名字一样。在Python中，变量命名需要遵循以下这些必须遵守硬性规则和强烈建议遵守的非硬性规则。 硬性规则： 变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头。 大小写敏感（大写的a和小写的A是两个不同的变量）。 不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突。 PEP 8要求： 用小写字母拼写，多个单词用下划线连接。 受保护的实例属性用单个下划线开头（后面会讲到）。 私有的实例属性用两个下划线开头（后面会讲到）。 类型转换函数 1234567891011121314151617int(x [,base ]) 将x转换为一个整数long(x [,base ]) 将x转换为一个长整数float(x ) 将x转换到一个浮点数complex(real [,imag ]) 创建一个复数str(x ) 将对象 x 转换为字符串repr(x ) 将对象 x 转换为表达式字符串eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象tuple(s ) 将序列 s 转换为一个元组list(s ) 将序列 s 转换为一个列表chr(x ) 将一个整数转换为一个字符unichr(x ) 将一个整数转换为Unicode字符ord(x ) 将一个字符转换为它的整数值hex(x ) 将一个整数转换为一个十六进制字符串oct(x ) 将一个整数转换为一个八进制字符串 分支结构 “Flat is better than nested.” 如果可以使用扁平化的结构就不要去用嵌套 循环结构 range 函数 12range(stop) -&gt; range objectrange(start, stop[, step]) -&gt; range object range(101)可以产生一个0到100的整数序列。 range(1, 100)可以产生一个1到99的整数序列。 range(1, 100, 2)可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。 函数与模块的使用 参数传递 Python 支持可变参数: 1234567891011121314# 在参数名前面的*表示args是一个可变参数# 即在调用add函数时可以传入0个或多个参数def add(*args): total = 0 for val in args: total += val return totalprint(add())print(add(1))print(add(1, 2))print(add(1, 2, 3))print(add(1, 3, 5, 7, 9)) Python 程序标准格式 为了解决变量作用域问题, 同时尽量避免全局变量的使用, 因此可以将 Python 程序按以下格式进行编写: 1234567def main(): # Todo: Add your code here passif __name__ == '__main__': main() 字符串和常用数据结构 字符串 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# 通过len函数计算字符串的长度len(str) # 13# 支持运算符+ * [:] in (not in) r/R %# 字符串内容格式 # HeLLo, wOrLD!str.title() # Hello, World! # 每个单词首字符大写str.capitalize() # Hello, world! # 仅首字母大写str.upper() # HELLO, WORLD! # 整体变大写str.swapcase() # hEllO, WoRld! # 翻转大小写str.expandtabs(tabsize=8) # 将 tab 变为空格, 个数由 tabsize 控制# 删除字符串 左/右/左右 空格str.lstrip()str.rstrip()str.strip()# 字符串填充# 将字符串以指定的宽度居中并填充指定的字符str.center(50, '*')# 将字符串以指定的宽度靠左/右放置并填充指定的字符str.ljust(50, '*')str.rjust(50, '*')# 字符串右对齐, 前面填充 0str.zfill(width)# 字符串判断str.isdigit() # 是否由数字构成str.isalpha() # 是否以字母构成str.isalnum() # 是否以数字和字母构成str.isnumeric() # 是否全是数字字符str.isascii() # 是否由ascii码构成str.isdecimal() # 是否为十进制数字str.islower() # 是否全为小写字母str.isupper() # 是否全为大写字母str.istitle() # 是否为首字母大写str.isidentifier() # 是否为合法的 Python 标识符str.isprintable() # 是否可打印str.isspace() # 是否为空格# 字符串查找# 所有查找函数都有默认的 beg=0, end=len(str)# 查找子串所在位置str.find('or') # 8str.find('shit') # -1str.rfind(str) # 从右边开始查找# 与 find 类似但找不到子串时会引发异常str.index('or') # 8str.index('shit') # ERRORstr.rindex('or') # 8# 检查字符串中子串出现的次数str.count(str)# 检查字符串是否以指定的字符串开头/结尾str.startswith('He') # Falsestr.startswith('hel') # Truestr.endswith('!') # True# 按行切片string.splitlines([keepends])# 按字串进行切片, 不超过 num 次str.split(str=&quot;&quot;, num=string.count(str))# 把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.str.replace(str1, str2, num=string.count(str1))# 有点像 find()和 split()的结合体# 从 str 出现的第一个位置起,把字符串 string 分成一个 3 元素的元组 (pre_str, str, post_str)# 如果 string 中不包含str 则 string_pre_str == string.str.partition(str)str.rpartition(str)str.decode(encoding='UTF-8', errors='strict') # 解码str.encode(encoding='UTF-8', errors='strict') # 编码 字符串格式化 1&quot;My name is %s and weight is %d kg!&quot; % ('Zara', 21) 符号 含义 %s 格式化字符串 %c 格式化字符及其ASCII码 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同 %e，用科学计数法格式化浮点数 %g %f 和 %e 的简写 %G %F 和 %E 的简写 %p 用十六进制数格式化变量的地址 Python 2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。参考菜鸟教程 基本语法是通过 {} 和 : 来代替以前的 % 。 format 函数可以接受不限个参数，位置可以不按顺序。 12345678&gt;&gt;&gt;&quot;{} {}&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 不设置指定位置，按默认顺序'hello world'&gt;&gt;&gt; &quot;{0} {1}&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置'hello world'&gt;&gt;&gt; &quot;{1} {0} {1}&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置'world hello world' 也可以设置参数： 12345678910111213print(&quot;网站名：{name}, 地址 {url}&quot;.format(name=&quot;菜鸟教程&quot;, url=&quot;www.runoob.com&quot;))# 通过字典设置参数site = {&quot;name&quot;: &quot;菜鸟教程&quot;, &quot;url&quot;: &quot;www.runoob.com&quot;}print(&quot;网站名：{name}, 地址 {url}&quot;.format(**site))# 通过列表索引设置参数my_list = ['菜鸟教程', 'www.runoob.com']print(&quot;网站名：{0[0]}, 地址 {0[1]}&quot;.format(my_list)) # &quot;0&quot; 是必须的# 访问对象my_value.value = 6print('value 为: {0.value}'.format(my_value)) # &quot;0&quot; 是可选的 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 -1 {:+.2f} -1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:0&gt;2d} 05 数字补零 (填充左边, 宽度为2) 5 {:x&lt;4d} 5xxx 数字补x (填充右边, 宽度为4) 10 {:x&lt;4d} 10xx 数字补x (填充右边, 宽度为4) 1000000 {:,} 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 13 {:10d} 13 右对齐 (默认, 宽度为10) 13 {:&lt;10d} 13 左对齐 (宽度为10) 13 {:^10d} 13 中间对齐 (宽度为10) 11 '{:b}' 1011 二进制 11 '{:d}' 11 十进制 11 '{:o}' 13 八进制 11 '{:x}' b 十六进制 11 '{:#x}' 0xb 加上 0x 11 '{:#X}' 0XB 加上 0X ^, &lt;, &gt; 分别是居中、左对齐、右对齐，后面带宽度， : 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。 + 表示在正数前显示 +，负数前显示 -； （空格）表示在正数前加空格 b、d、o、x 分别是二进制、十进制、八进制、十六进制。 此外我们可以使用大括号 {} 来转义大括号，如下实例： 1&quot;{} 对应的位置是 {{0}}&quot;.format(&quot;runoob&quot;) # runoob 对应的位置是 {0} 列表 12345678910111213141516171819202122232425262728len(list) # 计算长度cmp(list1, list2) # 比较元素max(list) # 返回列表元素最大值min(list) # 返回列表元素最小值# 运算符[1, 2, 3] + [4, 5, 6] # [1, 2, 3, 4, 5, 6]['Hi!'] * 4 # ['Hi!', 'Hi!', 'Hi!', 'Hi!']innot inlist.append(obj) # 在末尾添加list.insert(index, obj) # 在指定位置添加list.extend(seq) # 在末尾追加另一个序列中的多个值list.copy() # 返回本列表的复制list.pop(index=-1) # 删除指定位置的元素, 默认为最后一个, 并返回该元素的值list.remove(obj) # 删除第一个指定的元素list.clear() # 清空列表list.index(obj) # 查找元素list.count(obj) # 统计某个元素在列表中出现的次数list.reverse() # 翻转列表list.sort(cmp=None, key=None, reverse=False)# cmp -- 可选参数, 如果指定了该参数会使用该参数的方法进行排序。# key -- 主要是用来指定进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。# reverse -- 排序规则，reverse = True 降序， reverse = False 升序（默认）。 元组 任意无符号的对象，以逗号隔开，默认为元组 元组的元素不能修改和删除 可以使用 del 语句来删除整个元组 元组使用小括号，列表使用方括号 元组中只包含一个元素时，需要在元素后面添加逗号 元组在创建时间和占用的空间上面都优于列表 如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组 当然如果一个方法要返回多个值，使用元组也是不错的选择 12345678910111213len(list) # 计算长度cmp(list1, list2) # 比较元素max(list) # 返回列表元素最大值min(list) # 返回列表元素最小值# 运算符[1, 2, 3] + [4, 5, 6] # [1, 2, 3, 4, 5, 6]['Hi!'] * 4 # ['Hi!', 'Hi!', 'Hi!', 'Hi!']innot inlist.index(obj) # 查找元素list.count(obj) # 统计某个元素在元组中出现的次数 集合 集合（set）是一个无序的不重复元素序列 使用大括号 {} 或者 set() 函数创建集合 创建一个空集合必须用 set() 而不是 {}, 因为 {} 是用来创建一个空字典。 12345678910111213141516171819202122232425set.add(x) # 添加单个元素set.update(x) # 添加多个元素, x 可以是其他类型set.copy() # 返回一个拷贝set.pop() # 随机删除集合中的一个元素set.remove(x) # 移除元素, 不存在时报错set.discard(x) # 移除元素, 不存在时不报错set.clear() # 清空# update 表示会更改原集合的元素# 并set.union()set.update()# 交set.intersection()set.intersection_update()# 差set.difference()set.difference_update()# 异或set.symmetric_difference()set.symmetric_difference_update()set.isdisjoint() # 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 Falseset.issubset() # 判断指定集合是否为该方法参数集合的子集set.issuperset() # 判断该方法的参数集合是否为指定集合的子集 字典 字典是另一种可变容器模型，且可存储任意类型对象 字典的每个键值 key=&gt;value 对用冒号 : 分割 每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一 值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组, 而不能用列表 1234567891011121314151617181920str(dict) # 输出字典，以可打印的字符串表示dict[key] # 访问, 添加, 更新元素key in dict # 如果键在字典dict里返回true，否则返回falsedict.get(key, default=None) # 返回指定键的值，如果值不在字典中返回default值dict.setdefault(key, default=None) # 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为defaultdel dict[key] # 删除单个键值对del dict # 删除整个字典dict.clear() # 删除整个字典dict.popitem() # 随机返回并删除字典中的一对键和值(一般删除末尾对)dict.pop(key, default=None) # 删除键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值dict.keys() # 所有的键, 返回一个迭代器，可以使用 list() 来转换为列表dict.values() # 所有的值, 返回一个迭代器，可以使用 list() 来转换为列表dict.items() # 以列表返回可遍历的(键, 值) 元组数组dict.copy() # 返回一个字典的浅复制dict.fromkeys(seq, value) # 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值dict.update(dict2) # 把字典dict2的键/值对更新到dict里","link":"/p/6c2dba72/"},{"title":"Python-100-Day ③ 常用&#x2F;内置模块","text":"图形用户界面和游戏开发 tkinter 待补充 基本上使用tkinter来开发GUI应用需要以下5个步骤： 导入tkinter模块中我们需要的东西。 12import tkinterimport tkinter.messagebox 创建一个顶层窗口对象并用它来承载整个GUI应用。 12# 创建顶层窗口top = tkinter.Tk() 在顶层窗口对象上添加GUI组件。 123456789# 设置窗口大小top.geometry('240x160')# 设置窗口标题top.title('小游戏')# 创建标签对象并添加到顶层窗口label = tkinter.Label(top, text='Hello, world!', font='Arial -32', fg='red')label.pack(expand=1)# 创建一个装按钮的容器panel = tkinter.Frame(top) 通过代码将这些GUI组件的功能组织起来。 123456# 创建按钮对象 指定添加到哪个容器中 通过command参数绑定事件回调函数button1 = tkinter.Button(panel, text='修改', command=change_label_text)button1.pack(side='left')button2 = tkinter.Button(panel, text='退出', command=confirm_to_quit)button2.pack(side='right')panel.pack(side='bottom') 进入主事件循环(main loop)。 12# 开启主事件循环tkinter.mainloop() pygame TODO 文件和异常 打开文件 通过Python内置的open函数，可以指定文件名、操作模式、编码信息等来获得操作文件的对象，接下来就可以对文件进行读写操作了 12345678910open( file, # 文件名 mode='r', # 操作模式, 默认为 'rt' buffering=-1, # 缓存, 0为不缓存, 1为缓存一行 encoding=None, # 编码, 一般使用 utf8 errors=None, # 报错级别 newline=None, # 区分换行符 closefd=True, # 传入的file参数类型 opener=None,) 对于操作模式, 可以参考: 字符 作用 ‘r’ 读文件 (默认) ‘w’ 写文件, 首先会将文件截断 ‘x’ 新建文件, 然后以写模式打开 ‘a’ 写文件, 如果文件已存在, 则追加到文件末尾 ‘b’ 二进制模式 ‘t’ 文本模式 (默认) ‘+’ 更新文件 (可读可写) ‘U’ universal newline mode (deprecated) 使用一些模式的组合, 可以实现简单的功能: 默认模式为 'rt', 即以只读文本形式打开 使用 'w+b', 可以截断二进制文件 使用 'r+b', 不截断二进制文件 模式 'x' 包含 'w', 但会当文件已经存在时, 抛出 FileExistsError 异常 对于文本文件, 常用的打开模式如下: 123456789try: with open('test.txt', 'r', encoding='utf-8') as f: print(f.read())except FileNotFoundError: print('无法打开指定的文件!')except LookupError: print('指定了未知的编码!')except UnicodeDecodeError: print('读取文件时解码错误!') 在读取文件时, 可能会出现的异常有: 异常 含义 FileNotFoundError 文件不存在 FileExistsError 文件已经存在 ('x'模式) LookupError 制定了未知编码 UnicodeDecodeError 读取文件时解码错误 读取文本文件 打开一个文本文件后, 可以通过 read() 函数读取文件的内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 参数变量name # 文件名mode # 模式buffer # 缓存encoding # 文件编码格式errors # 报错级别newlines # 区分换行符line_buffering # 行缓存closed # 文件是否关闭write_through ## 函数close() # 关闭文件对象flush() # 清理写入缓存fileno() # 返回一个整型的文件描述符isatty() # 判断是否连接到一个终端设备truncate([size])# 无 size 时, 从当前位置截断, 删除后面内容# 有 size 时, 从开头偏移 size 处截断# 读取readable() # 判断文件是否为可读模式read([size]) # 读取文件内容, size未指定或为负则全部读取readline() # 读取一行readlines() # 以列表形式返回所有行# 文件指针tell() # 返回当前文件指针位置seekable() # 判断文件是否可以随机访问seek(offset, whence=0) # 设置文件指针位置# whence 可以接收相对位置的起点# 0 -- 开始处 (默认值); 此时 offset &gt;= 0# 1 -- 当前文件位置; 此时 offset 可正可负# 2 -- 结尾处; 此时 offset &lt; 0# 写入writable() # 文件是否可写write(str) # 将 str 写入文件, 返回写入的长度writelines(seq) # 将序列按序写入文件, 如需换行须在序列中自行加入# 重新配置文件模式reconfigure( *, encoding=None, errors=None, newline=None, line_buffering=None, write_through=None,) 通过以上这些函数, 可以实现对文本的多种读取方式: 123456789101112131415# 一次性读取整个文件内容with open('致橡树.txt', 'r', encoding='utf-8') as f: print(f.read())# 通过for-in循环逐行读取with open('致橡树.txt', mode='r') as f: for line in f: print(line, end='') time.sleep(0.5)print()# 读取文件按行读取到列表中with open('致橡树.txt') as f: lines = f.readlines()print(lines) 文本的写入也很简单, 使用 write() 函数即可, 不再赘述. JSON 处理 使用 json 模块, 可以实现JSON格式数据的处理. 1234567# JSON 文件 &lt;- -&gt; Python 对象 (常为 dict)dump(obj, fp) Python 对象 -&gt; JSON格式文件 fpload(fp) JSON格式文件 fp -&gt; Python 对象# JSON str &lt;- -&gt; Python 对象dumps(obj) Python 对象 -&gt; JSON格式字符串 strloads(str) JSON格式字符串 str -&gt; Python 对象","link":"/p/53e0edd6/"},{"title":"Python-100-Day ② Python 面向对象","text":"Python 100 Days 的学习笔记 ② : Day 8 ~ Day 9 原项目地址 本文主要涉及: 面向对象编程基本 (访问权限, 命名惯例, 调用方法) 面向对象高阶: @property装饰器 __slots__魔法 静态方法和类方法 类之间的关系 继承与多态 面向对象编程基础 在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的 如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头, 但事实上私有属性仍可以在外界访问 一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重 面向对象有三大支柱：封装、继承和多态 对封装的理解是“隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口” 在使用类的对象方法时, 一种方式是通过对象名调用方法, 另一种方式是通过给类发消息, 但是将需要使用的对象作为参数传给类的方法, 如下所示: 12345678910111213141516171819202122from math import sqrtclass Triangle(object): def __init__(self, a, b, c): self._a = a self._b = b self._c = c def perimeter(self): return self._a + self._b + self._ca, b, c = 3, 4, 5# 静态方法和类方法都是通过给类发消息来调用的t = Triangle(a, b, c)# 方法 1print(t.perimeter())# 方法 2print(Triangle.perimeter(t)) 面向对象进阶 @property装饰器 为了解决属性和方法的访问权限问题, 虽然可以将属性设置为私有, 但外界仍然可以直接访问, 同时无法检查属性的赋值是否符合要求. 一个就解决办法就是将属性设置成私有, 然后通过设置类装饰器实现对属性的访问和修改, 即为使用@property装饰器来包装属性的 getter（访问器）和 setter（修改器）方法, 类似于: 1234567891011121314151617181920212223242526272829303132333435363738class Person(object): def __init__(self, name, age): self._name = name self._age = age # 访问器 - getter方法 @property def name(self): return self._name # 访问器 - getter方法 @property def age(self): return self._age # 修改器 - setter方法 @age.setter def age(self, age): self._age = age def play(self): if self._age &lt;= 16: print('%s正在玩飞行棋.' % self._name) else: print('%s正在玩斗地主.' % self._name)def main(): person = Person('王大锤', 12) person.play() person.age = 22 person.play() # person.name = '白元芳' # AttributeError: can't set attributeif __name__ == '__main__': main() __slots__魔法 由于 Python 是动态语言, 因此在运行时可以给对象绑定新的属性和方法. 而 __slots__ 用于限制自定义类型的对象能够绑定的属性. 需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用. 123456789class Person(object): # 限定Person对象只能绑定_name, _age和_gender属性 __slots__ = ('_name', '_age', '_gender') def __init__(self, name, age): self._name = name self._age = age ...... 静态方法和类方法 大部分情况下, 在类中定义的方法都是对象方法 但写在类中的方法并不需要都是对象方法 比如在某些情况下, 还未创建好对象时, 便需要使用类中的方法, 那么这个方法是属于类的而并不属于类的对象的 可以使用静态方法来解决这类问题, 使用装饰器 @staticmethod 123456789101112131415161718192021222324252627282930313233343536373839from math import sqrtclass Triangle(object): def __init__(self, a, b, c): self._a = a self._b = b self._c = c @staticmethod def is_valid(a, b, c): return a + b &gt; c and b + c &gt; a and a + c &gt; b def perimeter(self): return self._a + self._b + self._c def area(self): half = self.perimeter() / 2 return sqrt(half * (half - self._a) * (half - self._b) * (half - self._c))def main(): a, b, c = 3, 4, 5 # 静态方法和类方法都是通过给类发消息来调用的 if Triangle.is_valid(a, b, c): t = Triangle(a, b, c) print(t.perimeter()) # 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数 # print(Triangle.perimeter(t)) print(t.area()) # print(Triangle.area(t)) else: print('无法构成三角形.')if __name__ == '__main__': main() 和静态方法比较类似，Python还可以在类中定义类方法，类方法可以在类中返回此类创建的对象. 类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445from time import time, localtime, sleepclass Clock(object): &quot;&quot;&quot;数字时钟&quot;&quot;&quot; def __init__(self, hour=0, minute=0, second=0): self._hour = hour self._minute = minute self._second = second @classmethod def now(cls): ctime = localtime(time()) return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec) def run(self): &quot;&quot;&quot;走字&quot;&quot;&quot; self._second += 1 if self._second == 60: self._second = 0 self._minute += 1 if self._minute == 60: self._minute = 0 self._hour += 1 if self._hour == 24: self._hour = 0 def show(self): &quot;&quot;&quot;显示时间&quot;&quot;&quot; return '%02d:%02d:%02d' % \\ (self._hour, self._minute, self._second)def main(): # 通过类方法创建对象并获取系统时间 clock = Clock.now() while True: print(clock.show()) sleep(1) clock.run()if __name__ == '__main__': main() 类之间的关系 简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。 is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。 has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。 use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。 继承与多态 子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。 12345678910111213141516171819202122232425262728293031323334353637from abc import ABCMeta, abstractmethodclass Pet(object, metaclass=ABCMeta): &quot;&quot;&quot;宠物&quot;&quot;&quot; def __init__(self, nickname): self._nickname = nickname @abstractmethod def make_voice(self): &quot;&quot;&quot;发出声音&quot;&quot;&quot; passclass Dog(Pet): &quot;&quot;&quot;狗&quot;&quot;&quot; def make_voice(self): print('%s: 汪汪汪...' % self._nickname)class Cat(Pet): &quot;&quot;&quot;猫&quot;&quot;&quot; def make_voice(self): print('%s: 喵...喵...' % self._nickname)def main(): pets = [Dog('旺财'), Cat('凯蒂'), Dog('大黄')] for pet in pets: pet.make_voice()if __name__ == '__main__': main() 在上面的代码中，我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过 abc 模块的 ABCMeta 元类和 abstractmethod 装饰器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，Dog和Cat两个子类分别对Pet类中的 make_voice 抽象方法进行了重写并给出了不同的实现版本，当我们在 main 函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。","link":"/p/24e7dd40/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"},{"name":"Raft","slug":"Raft","link":"/tags/Raft/"},{"name":"分布式系统","slug":"分布式系统","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"name":"Zeek","slug":"Zeek","link":"/tags/Zeek/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"bit-manipulation","slug":"bit-manipulation","link":"/tags/bit-manipulation/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Typora","slug":"Typora","link":"/tags/Typora/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"config","slug":"config","link":"/tags/config/"},{"name":"CLI","slug":"CLI","link":"/tags/CLI/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"CPP","slug":"CPP","link":"/tags/CPP/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Makefile","slug":"Makefile","link":"/tags/Makefile/"},{"name":"PyTorch","slug":"PyTorch","link":"/tags/PyTorch/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"机器学习","slug":"机器学习","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Code","slug":"Code","link":"/tags/Code/"},{"name":"Learn","slug":"Learn","link":"/tags/Learn/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"应用安装","slug":"应用安装","link":"/tags/%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Manjaro","slug":"Manjaro","link":"/tags/Manjaro/"},{"name":"Arch","slug":"Arch","link":"/tags/Arch/"},{"name":"系统配置","slug":"系统配置","link":"/tags/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"WSL","slug":"WSL","link":"/tags/WSL/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"PowerShell","slug":"PowerShell","link":"/tags/PowerShell/"},{"name":"NJU","slug":"NJU","link":"/tags/NJU/"},{"name":"课程总结","slug":"课程总结","link":"/tags/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"ICS","slug":"ICS","link":"/tags/ICS/"},{"name":"西瓜书","slug":"西瓜书","link":"/tags/%E8%A5%BF%E7%93%9C%E4%B9%A6/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/tags/Machine-Learning/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"MapReduce","slug":"MapReduce","link":"/tags/MapReduce/"},{"name":"大数据","slug":"大数据","link":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"latex","slug":"latex","link":"/tags/latex/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Python-100-Days","slug":"Python-100-Days","link":"/tags/Python-100-Days/"}],"categories":[{"name":"Rust","slug":"Rust","link":"/categories/Rust/"},{"name":"Raft","slug":"Raft","link":"/categories/Raft/"},{"name":"Courses","slug":"Courses","link":"/categories/Courses/"},{"name":"Zeek","slug":"Zeek","link":"/categories/Zeek/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Typora","slug":"Typora","link":"/categories/Typora/"},{"name":"Vim","slug":"Vim","link":"/categories/Vim/"},{"name":"CLI","slug":"CLI","link":"/categories/CLI/"},{"name":"C-CPP","slug":"C-CPP","link":"/categories/C-CPP/"},{"name":"PyTorch","slug":"PyTorch","link":"/categories/PyTorch/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"SQL","slug":"SQL","link":"/categories/SQL/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"CPP","slug":"CPP","link":"/categories/CPP/"},{"name":"NJU","slug":"NJU","link":"/categories/NJU/"},{"name":"Array","slug":"LeetCode/Array","link":"/categories/LeetCode/Array/"},{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Python-100-Day","slug":"Python/Python-100-Day","link":"/categories/Python/Python-100-Day/"},{"name":"Code","slug":"Code","link":"/categories/Code/"},{"name":"C-CPP","slug":"Code/C-CPP","link":"/categories/Code/C-CPP/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","link":"/categories/Algorithm/LeetCode/"}]}