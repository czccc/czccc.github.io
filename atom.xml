<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CZCC</title>
  
  
  <link href="http://blog.czccc.cc/atom.xml" rel="self"/>
  
  <link href="http://blog.czccc.cc/"/>
  <updated>2022-08-06T13:07:33.625Z</updated>
  <id>http://blog.czccc.cc/</id>
  
  <author>
    <name>Cheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>code-snippets</title>
    <link href="http://blog.czccc.cc/p/caf566a4/"/>
    <id>http://blog.czccc.cc/p/caf566a4/</id>
    <published>2022-04-22T12:08:09.000Z</published>
    <updated>2022-08-06T13:07:33.625Z</updated>
    
    <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="Banner">Banner</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;message message-immersive is-primary&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;message-body&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-globe-asia mr-2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>This article is also available in </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% post_path zh-CN/FAQ %&#125;&quot;</span>&gt;</span>简体中文<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-globe-asia mr-2"></i>This article is also available in <a href="">简体中文</a>.</div></article><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;message is-primary&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-size:inherit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;message-body&quot;</span>&gt;</span></span><br><span class="line">I can&#x27;t generate my site. / I met some errors when I generate my site.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><article class="message is-primary" style="font-size:inherit"><div class="message-body">I can't generate my site. / I met some errors when I generate my site.</div></article>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>tinykv</title>
    <link href="http://blog.czccc.cc/p/ae54ec2/"/>
    <id>http://blog.czccc.cc/p/ae54ec2/</id>
    <published>2022-04-22T11:46:03.000Z</published>
    <updated>2022-08-06T13:07:33.625Z</updated>
    
    <content type="html"><![CDATA[<hr><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="Courses" scheme="http://blog.czccc.cc/categories/Courses/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式 raft 算法总结</title>
    <link href="http://blog.czccc.cc/p/23fbe6c4/"/>
    <id>http://blog.czccc.cc/p/23fbe6c4/</id>
    <published>2021-02-05T12:31:01.000Z</published>
    <updated>2022-08-06T13:07:33.625Z</updated>
    
    <content type="html"><![CDATA[<hr><p>Raft 是一个分布式共识算法，相较于之前普遍使用的 Paxos 算法，Raft 更侧重于算法的简洁和易于理解，并具备支持工业级应用所需的性能。</p><p>Raft 有几个区别于其他算法的特性：</p><ul><li>Strong Leader：日志只能从 Leader 发送给 Follower，并覆盖掉 Follower 处与 Leader 不一致的日志。</li><li>Leader Election：Raft 使用随机的延时进行 Leader 的选举，这避免了一些冲突，并使得算法变得更简单。</li><li>Membership changes：Raft 使用 <em>joint consensus</em> 进行在前后两组节点之间进行无缝转变，节点变化的过程对用户而言是透明的。</li></ul><span id="more"></span><h1>状态机模型</h1><p>Raft 的状态机模型如下所示：</p><p><img src="https://i.loli.net/2021/02/05/l7twf4Kuck63RCB.png" alt=""></p><p>简单的说，一个 Client 的请求过程分为如下四步：</p><ol><li>Client 向 Server Leader 发送一个请求</li><li>Leader 按共识协议将此请求作为一个 Log 存储在一个序列中，并开始在多个节点中进行复制</li><li>如果对此请求达成共识，便将其应用到状态机中</li><li>从状态机中返回相应的结果给 Client</li></ol><blockquote><p>Client 的请求可能并不会被按时处理 (Leader 离线、网络延时、一直未达成共识等)，对 Client 而言，一个比较合理的操作是超时重试。<br>但是，Raft 协议本身并不负责处理由于 Client 超时重试而带来的重复日志，这一部分逻辑需要交由上层实体来控制。</p></blockquote><h1>Raft 算法综述</h1><p>Raft 算法需要实现的，就是上述步骤中的第 2 步，也即，Raft 算法需要对传入的 Log 日志在不同的节点间尝试达成共识，如果能达成共识，则将此 Log 应用到状态机中，如果无法达成共识，则废弃此 Log。</p><p>Raft 算法主要可以分为如下几个部分：</p><ul><li>Leader election：也即实现中所使用的 Request vote，主要用于发送选举请求，处理选举结果。这一步往往出现在节点刚初始化时或者长时间未接收到来自于 Leader 的消息。</li><li>Log replication：也即实现中所使用的 Append entries，主要用于 Leader 向 Follower 发送日志项，维护 Follower 的心跳时间以免超时重新进行选举等。</li><li>Log compaction：也即实现中所使用的 Install snapshot，主要用于压缩日志项，从而减少开销，如果 Follower 的日志落后太多，为了减少网络开销以及快速进行同步，Leader 会向 Follower 直接发送状态机的快照副本，未在快照中的数据项再通过 Log replication 进行同步。</li></ul><h2 id="基本概念">基本概念</h2><ol><li>任期 <code>term</code>：</li></ol><h2 id="数据状态">数据状态</h2><p>对于一个 Raft 节点而言，需要维护自身的一些状态，这些状态在论文的 Figure 2 中，主要分了三类：</p><p><img src="https://i.loli.net/2021/02/05/ns8AFmJ9SQvwMby.png" alt="image-20210205212929749"></p><ol><li>在所有节点上都需要使用的可持久化状态，此类状态每次在更改之后就需要保存到持久化存储中，并在节点重启后载入对应的状态：<ul><li><code>currentTerm</code>：节点当前的 <code>term</code>，初始时为 0，只增不减，每次收到 RPC 请求时，如果 RPC 中的 <code>term</code> 比 <code>currentTerm</code> 大，便更新 <code>currentTerm = term</code></li><li><code>voteFor</code>：节点在 Leader 选举中所投的 Candidate ID，如果未投票则为 <code>null</code></li><li><code>log[]</code>：节点的日志序列，每个日志都包含一个 <code>command</code>，以及 <code>command</code> 对应的 <code>term</code></li></ul></li><li>在所有节点上都需要使用的临时状态，此类状态不必持久化，在每次节点重启后重新初始化即可：<ul><li><code>commitIndex</code>：已知的日志序列中可提交的日志 Index 的最大值。初始值为 0， 只增不减</li><li><code>lastApplied</code>：已应用到状态机的日志 Index。初始值为 0，随 <code>commitIndex</code> 递增</li></ul></li><li>只在 Leader 节点上使用的临时状态，此类状态不必持久化，并只有选举成为 Leader 后进行初始化即可：<ul><li><code>nextIndex[]</code>：对于每个节点，存储需要向其发送的日志项的下一个日志的 Index。初始时为 Leader 的最大的 Log Index + 1</li><li><code>matchIndex[]</code>：对于每个节点，保存已知的复制成功的 Log Index 的最大值。初始时为 0，随着日志复制过程递增</li></ul></li><li>（Figure 13 增加了快照功能之后）增加两个在所有节点上都需要使用的可持久化状态，状态同第一类一样需要持久化保存和载入：<ul><li><code>lastIncludedIndex</code>：节点所保存的快照中最后一个日志项的 Index，同时说明 所有 <code>index &lt;= lastIncludedIndex</code> 的日志项已经被废弃</li><li><code>lastIncludedTerm</code>：节点所保存的快照中最后一个日志项的 Term</li></ul></li></ol><h2 id="Leader-Election">Leader Election</h2><p>Raft 使用 Strong Leader 作为共识协议的发起点，因此需要进行选举过程。选举过程的发起需要条件，也就是如果一个 Follower 在设定的时间间隔内一直无法收到 Leader 的消息（心跳），则可以认为之前的 Leader 已经下线或者出现故障， Follower 便会将自身的 <code>currentTerm += 1</code> ，并转变为 Candidate，向所有的节点发送 <code>RequestVote</code> 的 RPC 请求。</p><p><img src="https://i.loli.net/2021/02/05/ns8AFmJ9SQvwMby.png" alt="image-20210205212951453"></p><p>RPC 请求中所包含的参数为：</p><ul><li><code>term</code>：Candidate 的 <code>currentTerm</code></li><li><code>candidateId</code>：Candidate 的身份</li><li><code>lastLogIndex</code>： Candidate 最后一条日志的 Index</li><li><code>lastLogTerm</code>：Candidate 最后一条日志的 term</li></ul><p>同样的，作为此 RPC的接收方，需要对其进行处理并回复，处理的结果如下：</p><ul><li><code>term</code>：最新的 <code>term</code>，也即为 Candidate 发送的 RPC 中的 <code>term</code> 与节点自身 <code>currentTerm</code> 中的最大值。</li><li><code>voteGranted</code>：是否给此 RPC 请求投票，投票时为 <code>true</code></li></ul><p>具体的处理逻辑如下：</p><ol><li>如果 RPC 中的 <code>term</code> 大于节点的 <code>currentTerm</code>，可知当前的 <code>currentTerm</code> 任期已经结束，因此节点首先更新自身的 <code>currentTerm = term</code>，将身份改为 <code>Follower</code>，并清除 <code>voteFor</code></li><li>如果 RPC 中的 <code>term</code> 小于节点的 <code>currentTerm</code>，不投票，并返回更新的 <code>currentTerm</code></li><li>此时，节点的 <code>currentTerm</code> 一定等于 RPC 中的 <code>term</code>，是否投票从以下两方面考虑：<ol><li>RPC中的最新日志信息：只有当RPC中的日志信息比节点的日志信息<strong>更新</strong>时，才会投票。这个“更新”的意思为：RPC中的 <code>lastLogTerm</code> 大于节点最新日志的 <code>term</code>，或者RPC中的 <code>lastLogTerm</code> 等于节点最新日志的 <code>term</code>，但RPC中的 <code>lastLogIndex</code> 大于节点最新日志的 <code>index</code>。这一点保证了 Follower 只会给知道的信息比它多的节点投票，从而保证了日志记录的完整性</li><li>是否在当前任期已经投票：只有在当前任期内此节点未投票或已经给此RPC的id投票时才会确定投票。也即为先到先得。</li></ol></li></ol><p>Candidate 需要收集所有的 RPC 回复，并累计所得票数，只有所得的票数超过总数的一半（majority）时，节点才可以成为新一任的 Leader。</p><p>安全性保证：对比 <code>commitIndex</code> 的算法逻辑，Leader 只有在超过一半的节点都确认了一个Log的时候，才会将其提交，也就是说：所有提交的日志一定会出现的超过一半以上的节点中。而在选举过程中，如果一个节点不包含这条已经提交的日志，那么它无论无何都无法获得超过一半的选票，也即无法成为 Leader。这保证了所有提交过的日志不会被覆盖，保证了所有节点中应用到状态机的日志序列的一致性。相反地，未提交的日志都有一定的可能会被丢弃。</p><h2 id="Log-Replication">Log Replication</h2><p>Raft 算法需要实现日志在不同节点间的同步，以及保证所有提交的日志都是一致的，不存在乱序和差错。因此，Raft 节点需要定期与其他节点进行交互，这个交互是通过 RPC 请求完成的，也就是下面将要说的 AppendEntries。在实际使用中，Leader 需要定期发送此 RPC，目的有两个，一是将新增的 Log 数据复制到 Follower 中，另一个是为了保证 Leader 的存活，毕竟如果 Follower 长时间收不到 Leader 的消息，就会主动发起选举。</p><p><img src="https://i.loli.net/2021/02/05/QhKEmDJW45sNxka.png" alt="image-20210205213035071"></p><p>AppendEntries RPC所使用的参数如下：</p><ul><li><code>term</code>：Leader 当前的任期</li><li><code>leaderId</code>：Leader 的身份</li><li><code>prevLogIndex</code>：在 <code>entries[]</code> 中所包含日志项的前一个日志的 index</li><li><code>prevLogTerm</code>：在 <code>entries[]</code> 中所包含日志项的前一个日志的 term</li><li><code>entries[]</code>：当前 RPC 中所包含的日志项（可以一次发送多个日志以提高效率）。可以为空，表示没有最新的日志项需要发送，只更新 Follower 的心跳。</li><li><code>leaderCommit</code>：Leader 当前所提交的日志的 Index，Follower 收到此数据之后便可更新自身的 <code>comitIndex</code>，并向自己的状态机应用相关的日志</li></ul><p>RPC 的结果所包含的字段如下：</p><ul><li><code>term</code>：最新的 <code>term</code>，也即为 Candidate 发送的 RPC 中的 <code>term</code> 与节点自身 <code>currentTerm</code> 中的最大值。</li><li><code>success</code>：此次日志复制是否成功，在有冲突时返回 <code>false</code></li></ul><p>作为 RPC 请求的接收方，处理的逻辑如下：</p><ol><li>如果 RPC 中的 <code>term</code> 大于节点的 <code>currentTerm</code>，可知当前的 <code>currentTerm</code> 任期已经结束，因此节点首先更新自身的 <code>currentTerm = term</code>，将身份改为 <code>Follower</code></li><li>如果 RPC 中的 <code>term</code> 小于节点的 <code>currentTerm</code>，说明此 RPC 来自旧的 Leader，不复制日志，返回更新的 <code>currentTerm</code></li><li>此时，节点的 <code>currentTerm</code> 一定等于 RPC 中的 <code>term</code>，节点先更新自身的心跳计时，之后考虑日志复制（如果不包含日志则直接返回成功）：<ol><li>**由 Raft 的日志性质，一条日志可以由 index 和 term 唯一确定。**这是由于在每一个 term 内，最多只会产生一个 Leader，因此在相同任期内，日志总是由 Leader 首先接收并复制到 Follower 中，那么 Leader 中日志序列的顺序便是当前 term 中所有日志的顺序。因此，如果两个日志的 term 不同，那么这两条日志一定不是同一个日志；如果两个日志 term 相同，但 index 不同，同样也不是同一条日志。只有 index 和 term 都相同的日志，才能说明此条日志是从相同的 Leader 处复制得到，也就是同一条日志。</li><li>由于日志复制顺序总是从前向后，只有前面的日志都复制成功后，才会复制下一条日志，因此如果在某条日志处确认了其 index 和 term 都和 RPC 中的一致，那么只需要考虑此条日志之后的日志进行复制，再次之前的日志可以确定都已经与 Leader 处的一致。</li><li>Leader 在 RPC 中会附上 <code>prevLogIndex</code> 和 <code>prevLogTerm</code>，作为一个日志的锚点，如果 Follower 处存在相同 index 和 term 的日志，便可以进行之后的日志复制，Follower 便可以将 RPC 中的 <code>entries[]</code> 批量添加到此锚点日志的后面，并在 RPC 中确认复制成功（<code>success = true</code>）。最后，Follower 根据 Leader 的<code>leaderCommit</code>，更新自己本地的 <code>commitIndex</code>，并提交相关的日志项。</li><li>如果 <code>prevLogIndex</code> 和 <code>prevLogTerm</code> 无法对应到 Follower 的日志，说明尚未找到同步点，返回失败（<code>success = false</code>）</li></ol></li></ol><p>在 Leader 处，当接收到了 Follower 的 RPC 的回复后，在此，我们假设此 Follower 的 ID 为 <code>i</code>：</p><ol><li>如果 reply 中的 term 更大，则变为 Follower</li><li>如果 <code>success == true</code>：说明复制成功，Leader 需要维护 Follower 的状态，也就是 <code>nextIndex</code> 和 <code>matchIndex</code>：<ol><li>在这里令发送的日志项的最后一个日志的 index 为 <code>upper_log_index</code></li><li>更新 <code>nextIndex[i]</code> 为已经发送的日志中的最大的 index + 1。即 <code>nextIndex[i] = upper_log_index + 1</code>。</li><li>更新 <code>matchIndex[i]</code> 为已经发送的日志中的最大的 index，即 <code>matchIndex[i] = upper_log_index</code>。</li><li>根据 <code>matchIndex</code> 进行判断，如果存在超过一半的节点的 <code>matchIndx[i] &gt; N</code>，则可以更新 Leader 的 <code>commitIndex</code>，并应用相关日志到状态机。</li></ol></li><li>如果 <code>success == false</code>：说明复制失败，也就是没有找到同步点：<ol><li>递减 <code>nextIndex[i]</code>，后退一条日志继续尝试同步 。即 <code>nextIndex[i] -= 1</code>。</li></ol></li></ol><p>一些讨论：</p><ol><li>初始时，<code>nextIndex</code> 均初始化为 最大的 Log 的 <code>index + 1</code>，因此在第一次发送 <code>AppendEntries</code> RPC 时，<code>prevLogIndex</code> 等于 <code>nextIndex[i] - 1</code>，也即为最大的 Log index，因此此时 <code>entries</code> 为空，即不包含日志数据。</li><li>日志的复制过程是从后向前，逐渐尝试进行同步的。对于不同的节点，每次的 RPC 参数会不一样（根据 <code>nextIndex</code> 确定）。</li><li>如何快速找到日志中不一致的地方？这是 Raft 中所使用的一种优化。如果按照原协议，每次日志复制不成功就仅仅将 <code>nextIndex</code> 减一，如果日志项比较多，可能会需要很长时间才能完成同步。在这里介绍一个比较常用的回滚算法，加快同步的速度：<ol><li>在 <code>AppendEntries</code> RPC 的回复中新增两个字段：<code>conflictIndex</code> 和 <code>conflictTerm</code>，其中，<code>conflictTerm</code> 为 Follower 处与 Leader 发送的 <code>prevLogIndex</code> 所冲突的日志项的 <code>term</code>，<code>conflictIndex</code> 为 Follower 处日志的 <code>term</code> 等于 <code>conflictTerm</code> 的第一条日志的 <code>index</code></li><li>Leader 接收到这个回复后，检查自己是否包含 <code>conflictIndex</code> 和 <code>conflictTerm</code> 的此条日志，如果包含此条日志，则可以确定冲突的日志在此之后，因此将 <code>nextIndex[i]</code> 更新为 Leader 处的 <code>conflictTerm</code> 的最后一条日志的 index；如果不包含，则冲突的日志在此之前，则将 <code>nextIndex[i]</code> 更新为 Leader 处的 <code>conflictTerm</code> 的第一条日志的 index。</li><li>再次补充：为什么将 <code>nextIndex[i]</code> 更新为 Leader 处的 <code>conflictTerm</code> 的最后一条日志的 index？首先，如果 Leader 包含 <code>conflictIndex</code> 和 <code>conflictTerm</code> 的此条日志，同时说明 Follower 也有此条日志，因此日志复制失败的原因一定是因为这个 term 下，Follower 处的日志条目不全，否则冲突的位置不会发生在此 term 内。因此将 <code>nextIndex</code> 更新到这个 term 的最后一条日志的 index，之后再次尝试进行同步。</li><li>这样的方式可以保证一次跳过一个任期，而不仅仅是一条日志，因此大大加快了同步的速度。</li></ol></li></ol><h2 id="Log-Compaction">Log Compaction</h2><p>随着 Raft 节点日志的不断增加，过多的日志会影响节点的性能开销，因此对日志数据进行压缩是很有必要的。在实现了 Leader Election 和 Log replicate 之后，节点已经实现了基本的 Raft 算法所需的内容，而日志压缩功能则是更进一步，补充之前的协议中缺失的部分内容。</p><p>首先，需要明确的是，为什么可以进行日志压缩？回想一下之前所提到的内容，Raft 协议主要关心的并不是全部日志，由于日志顺序的一致性，Raft 协议只需要关注于最新的日志（或最新一部分的日志），而对于陈旧的日志是不会再使用的。比如说，我们选取一个日志作为锚点，那么只要能将此锚点日志对应起来，便可以保证日志的一致性，因此可以丢弃此锚点日志之前的数据，取而代之保存相应的状态机的快照副本。从而，在进行日志复制时，如果需要复制的日志位于此锚点日志之后，那么继续像之前一样传递日志数据；如果位于锚点日志之前，那么首先向其发送快照副本，再发送快照副本之后的日志数据，同样能保证日志的一致性。</p><p>其次，什么时候需要创建快照副本？由于创建快照的目的是为了压缩日志，因此可以设置一些阈值，比如已提交但未压缩的日志文件超过一定的大小，或者简单的通过日志数目来衡量是否应该压缩日志。快照的创建是一个本地命令，也就是说不同的节点处可能会存在不同的快照（但均为相同的日志序列，只不过快照所压缩的日志长度有所不同）。</p><p>如何确定快照所包含的日志序列？由日志的一致性，可以通过保存快照中最后一条日志的 index 和 term 实现。因此需要向节点添加两个额外的状态，<code>lastIncludedIndex</code> 和 <code>lastIncludedTerm</code>，并且同样需要持久化。</p><p>创建快照后，由于之前的日志被丢弃，因此日志的索引范围也将发生变化。简单地说，创建快照之前，index 为 <code>i</code> 的日志在 log 中的 <code>i - 1</code> 处（index 从 1 开始，而 log 从 0 开始索引），创建快照后，index 为 <code>i</code> 的日志在 log 中的 <code>i - 1 - lastIncludedIndex</code> 处，而对于 <code>index &lt;= lastIncludedIndex</code> 的日志不再存在，只能通过复制完整的快照文件。</p><p>在进行日志同步时，如果需要 <code>index &lt;= lastIncludedIndex</code> 的日志，将不再通过 <code>AppendEntries</code> RPC 发送日志数据，取而代之我们使用第三种 RPC 命令 <code>InstallSnapshot</code> ，用于发送快照副本文件。</p><p><img src="https://i.loli.net/2021/02/06/72VZH14OdU6rWyB.png" alt="image-20210206174215087"></p><p><code>InstallSnapshot</code> RPC 所需的参数如下：</p><ol><li><code>term</code>：Leader 的当前任期</li><li><code>leaderId</code>： Leader 的身份</li><li><code>lastIncludedIndex</code>：快照所包含的最后一条日志的 index</li><li><code>lastIncludedTerm</code>：快照所包含的最后一条日志的 term</li><li><code>offset</code>：快照文件可能会比较大，需要分片发送，<code>offset</code> 标识当前的偏移位置</li><li><code>data[]</code>：此次发送的快照数据</li><li><code>done</code>：是否已经发送完毕，如果后面不再有数据，则发送 <code>true</code></li></ol><p>RPC 的回复只包含 <code>term</code> 一项，用于表示是否成功收到此 RPC。</p><p>对于 RPC 请求的处理过程如下：</p><ol><li>如果 RPC 中的 <code>term</code> 大于节点的 <code>currentTerm</code>，可知当前的 <code>currentTerm</code> 任期已经结束，因此节点首先更新自身的 <code>currentTerm = term</code>，将身份改为 <code>Follower</code></li><li>如果 RPC 中的 <code>term</code> 小于节点的 <code>currentTerm</code>，说明此 RPC 来自旧的 Leader，不复制快照，返回更新的 <code>currentTerm</code></li><li>如果当前没有快照文件，则首先新建一个空文件</li><li>将此 RPC 中的快照数据 <code>data</code> 复制到指定的 <code>offset</code> 处，并逐渐等待更新的快照数据，直至 <code>done</code> 为 <code>true</code></li><li>丢弃快照文件中所包含的全部日志</li><li>如果节点当前的日志中存在与 <code>lastIncludedIndex</code> 和 <code>lastIncludedTerm</code> 相同的日志，则保留此日志之后的日志；如果不存在，则丢弃全部日志</li><li>通过快照文件重置节点的状态机</li></ol><p>一些讨论：</p><ol><li>快照中能否包含未提交的日志？不能，因为快照是通过状态机创建的，而应用到状态机中的所有日志都必须是已经提交的日志。</li><li>节点在收到快照后，如何将其应用到状态机？可以设置一个单独的命令，在提交日志时标识当前提交的是日志还是快照，如果是日志，则应用到状态机；如果是快照，则重置状态机</li></ol><h1>Membership Changes</h1><p>在实际的使用中，Raft 节点的成员配置可能会发生改变，比如增加或减少节点数等。尽管这个步骤可以使用离线更新来实现，但是在离线过程中，会形成一个无法提供服务的窗口。并且离线手动更新难以保证安全性，因此 Raft 协议提供了可以在线更新成员配置的内容。</p><p>为了确保安全性，直接在两个配置中进行转变是不行的，因为这有可能导致在同一个 term 下选举出了两个 Leader。因此我们必须将这个步骤拆分为两个阶段。比如第一步中先停止先前的配置文件并暂停服务，第二步载入更新的配置并恢复。</p><p>在 Raft 中，集群首先进入一个临时的配置状态，称之为 joint<br>consensus；一旦 joint<br>consensus 被提交到日志，整个系统便过渡到最终的阶段，并可以使用更新的配置。</p><h1>参考资料</h1><p><a target="_blank" rel="noopener" href="http://nil.csail.mit.edu/6.824/2018/notes/l-raft2.txt">http://nil.csail.mit.edu/6.824/2018/notes/l-raft2.txt</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;Raft 是一个分布式共识算法，相较于之前普遍使用的 Paxos 算法，Raft 更侧重于算法的简洁和易于理解，并具备支持工业级应用所需的性能。&lt;/p&gt;
&lt;p&gt;Raft 有几个区别于其他算法的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Strong Leader：日志只能从 Leader 发送给 Follower，并覆盖掉 Follower 处与 Leader 不一致的日志。&lt;/li&gt;
&lt;li&gt;Leader Election：Raft 使用随机的延时进行 Leader 的选举，这避免了一些冲突，并使得算法变得更简单。&lt;/li&gt;
&lt;li&gt;Membership changes：Raft 使用 &lt;em&gt;joint consensus&lt;/em&gt; 进行在前后两组节点之间进行无缝转变，节点变化的过程对用户而言是透明的。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Raft" scheme="http://blog.czccc.cc/categories/Raft/"/>
    
    
    <category term="Raft" scheme="http://blog.czccc.cc/tags/Raft/"/>
    
    <category term="分布式系统" scheme="http://blog.czccc.cc/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的智能指针</title>
    <link href="http://blog.czccc.cc/p/2633d759/"/>
    <id>http://blog.czccc.cc/p/2633d759/</id>
    <published>2021-01-29T13:44:58.000Z</published>
    <updated>2022-08-06T13:07:33.619Z</updated>
    
    <content type="html"><![CDATA[<hr><p>在 C++ 中，内存安全和内存泄露是最容易出现的问题，而对于前者，内存安全问题，很大程度上是由于指针的使用不当，比如直接访问未初始化的指针、通过指针访问以及被释放掉的对象等。为了解决这类问题，在 C++11 中，新增了一些现代化的指针工具，旨在替换原始的指针，实现更加智能化的内存数据管理，这些指针也叫智能指针（smart pointer）。</p><p>C++11 中新增的智能指针对象如下：</p><table><thead><tr><th style="text-align:center">指针类别</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><code>unique_ptr</code></td><td style="text-align:center">拥有独有对象所有权语义的智能指针</td></tr><tr><td style="text-align:center"><code>shared_ptr</code></td><td style="text-align:center">拥有共享对象所有权语义的智能指针</td></tr><tr><td style="text-align:center"><code>weak_ptr</code></td><td style="text-align:center">到 std::shared_ptr 所管理对象的弱引用</td></tr></tbody></table><span id="more"></span><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903993055920141">https://juejin.cn/post/6844903993055920141</a></p><h1>特点</h1><ul><li>这三个指针都定义在 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/header/memory"><code>memory</code></a> 头文件下，使用时需要 <code>#include &lt;memory&gt;</code>，并处于 <code>std</code> 中</li><li>智能指针会自动进行析构操作，当独占指针结束作用域，或共享指针引用计数为0时，会自动释放指针的对象</li></ul><h1><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory/unique_ptr"><code>unique_ptr</code></a></h1>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;在 C++ 中，内存安全和内存泄露是最容易出现的问题，而对于前者，内存安全问题，很大程度上是由于指针的使用不当，比如直接访问未初始化的指针、通过指针访问以及被释放掉的对象等。为了解决这类问题，在 C++11 中，新增了一些现代化的指针工具，旨在替换原始的指针，实现更加智能化的内存数据管理，这些指针也叫智能指针（smart pointer）。&lt;/p&gt;
&lt;p&gt;C++11 中新增的智能指针对象如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;指针类别&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;unique_ptr&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;拥有独有对象所有权语义的智能指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;shared_ptr&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;拥有共享对象所有权语义的智能指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;weak_ptr&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;到 std::shared_ptr 所管理对象的弱引用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</summary>
    
    
    
    <category term="Code" scheme="http://blog.czccc.cc/categories/Code/"/>
    
    <category term="C-CPP" scheme="http://blog.czccc.cc/categories/Code/C-CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>在 LeetCode 上做脑筋急转弯</title>
    <link href="http://blog.czccc.cc/p/7c7bac08/"/>
    <id>http://blog.czccc.cc/p/7c7bac08/</id>
    <published>2020-11-14T08:20:56.000Z</published>
    <updated>2022-08-06T13:07:33.619Z</updated>
    
    <content type="html"><![CDATA[<hr><p>这篇文章主要包含以下内容：</p><ul><li><a href="#292-nim-%E6%B8%B8%E6%88%8F">#292 - Nim 游戏</a></li><li><a href="#319-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3">#319 - 灯泡开关</a></li><li><a href="#521-%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97-%E2%85%B0">#521 - 最长特殊序列 Ⅰ</a></li><li><a href="#777-%E5%9C%A8lr%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6">#777 - 在LR字符串中交换相邻字符</a></li><li><a href="#1033-%E7%A7%BB%E5%8A%A8%E7%9F%B3%E5%AD%90%E7%9B%B4%E5%88%B0%E8%BF%9E%E7%BB%AD">#1033 - 移动石子直到连续</a></li><li><a href="#1227-%E9%A3%9E%E6%9C%BA%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D%E6%A6%82%E7%8E%87">#1227 - 飞机座位分配概率</a></li><li><a href="#1503-%E6%89%80%E6%9C%89%E8%9A%82%E8%9A%81%E6%8E%89%E4%B8%8B%E6%9D%A5%E5%89%8D%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%88%BB">#1503 - 所有蚂蚁掉下来前的最后一刻</a></li></ul><span id="more"></span><h1>#292 - <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/nim-game/">Nim 游戏</a></h1><blockquote><p>你和你的朋友，两个人一起玩 Nim 游戏：</p><ul><li>桌子上有一堆石头。</li><li>你们轮流进行自己的回合，你作为先手。</li><li>每一回合，轮到的人拿掉 1 - 3 块石头。</li><li>拿掉最后一块石头的人就是获胜者。</li></ul><p>假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 <code>n</code> 的情况下赢得游戏。如果可以赢，返回 <code>true</code>；否则，返回 <code>false</code> 。</p></blockquote><p>由于每个人最多只能拿 <code>3</code> 块石头，那么如果桌上还剩 <code>4</code> 块的话，一个人是一定不能一次拿完的。那么只要在一个人拿 <code>x</code> 块石头之后，另一个人继续拿 <code>4 - x</code> 块，就能保证一开始拿的那个人一定不可能赢。</p><p>因此，因为你作为先手，如果桌上的石头一开始就是 <code>4</code> 的倍数，那么你就是一开始拿的人，也就是说你会输；如果不是 <code>4</code> 的倍数，你就可以拿 <code>n % 4</code> 块，那么你的对手就不可能赢，因此你会获得胜利。</p><p>所以胜利与否只取决于桌上原始的石头数。解法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canWinNim</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span></span><br></pre></td></tr></table></figure><h1>#319 - <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bulb-switcher/">灯泡开关</a></h1><blockquote><p>初始时有 n 个灯泡关闭。</p><p>第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。</p><p>第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。</p><p>找出 n 轮后有多少个亮着的灯泡。</p></blockquote><p>首先，初始时每个灯泡都是灭的。</p><p>那么，什么时候灯泡会转变一次状态呢？由题意，对于第 <code>i</code> 轮，如果 <code>k % i == 0</code>，也就是 <code>k</code> 是 <code>i</code> 的倍数，此时灯泡 <code>k</code> 会转变一次状态。另一方面，在第 <code>k / i</code> 轮，灯泡 <code>k</code> 同样会转变一次状态。因此，如果 <code>i != k / i</code>，那么灯泡会转变两次，最终还是灭的；而只有 <code>i == k / i</code>，也就是 <code>k == i * i</code>，即 <code>k</code> 是个平方数，此时灯泡 <code>k</code> 只会转变一次，因此最后的状态是亮的。</p><p>举个例子，比如 <code>12</code>，由于 <code>12 = 1 * 12 = 2 * 6 = 3 * 4</code>，因此会分别在第 <code>1, 2, 3, 4, 6, 12</code> 轮转换六次状态，最终还是灭的；而对于 <code>16</code>，由于 <code>16 = 1 * 16 = 2 * 8 = 4 * 4</code>，由于在 <code>4</code> 处只变了一次，最终在第 <code>1, 2, 4, 8, 16</code> 轮转换五次，最终是亮的。</p><p>因此，亮着的灯泡的个数就等同于 <code>[1, n]</code> 内的平方数的个数。解法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bulbSwitch</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> floor(sqrt(n))</span><br></pre></td></tr></table></figure><h1>#521 - <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/">最长特殊序列 Ⅰ</a></h1><blockquote><p>给你两个字符串，请你从这两个字符串中找出最长的特殊序列。</p><p>「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。</p><p>子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。</p><p>输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLUSlength</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> a == b:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">len</span>(a), <span class="built_in">len</span>(b))</span><br></pre></td></tr></table></figure><h1>#777 - <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-adjacent-in-lr-string/">在LR字符串中交换相邻字符</a></h1><blockquote><p>在一个由 ‘L’ , ‘R’ 和 ‘X’ 三个字符组成的字符串（例如&quot;RXXLRXRXL&quot;）中进行移动操作。一次移动操作指用一个&quot;LX&quot;替换一个&quot;XL&quot;，或者用一个&quot;XR&quot;替换一个&quot;RX&quot;。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。</p></blockquote><h1>#1033 - <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/moving-stones-until-consecutive/">移动石子直到连续</a></h1><blockquote><p>三枚石子放置在数轴上，位置分别为 a，b，c。</p><p>每一回合，我们假设这三枚石子当前分别位于位置 x, y, z 且 x &lt; y &lt; z。从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x &lt; k &lt; z 且 k != y。</p><p>当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。</p><p>要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves]</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numMovesStones</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span>, c: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        a, b, c = <span class="built_in">sorted</span>([a, b, c])</span><br><span class="line">        <span class="keyword">if</span> a + <span class="number">1</span> == b <span class="keyword">and</span> b + <span class="number">1</span> == c:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> b - a  &lt;= <span class="number">2</span> <span class="keyword">or</span> c - b &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>, c - a - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">2</span>, c - a - <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h1>#1227 - <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/airplane-seat-assignment-probability/">飞机座位分配概率</a></h1><blockquote><p>有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。</p><p>剩下的乘客将会：</p><p>如果他们自己的座位还空着，就坐到自己的座位上，</p><p>当他们自己的座位被占用时，随机选择其他座位<br>第 n 位乘客坐在自己的座位上的概率是多少？</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nthPersonGetsNthSeat</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0.5</span></span><br></pre></td></tr></table></figure><h1>#1503 - <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/">所有蚂蚁掉下来前的最后一刻</a></h1><blockquote><p>有一块木板，长度为 <code>n</code> 个 <strong>单位</strong> 。一些蚂蚁在木板上移动，每只蚂蚁都以 <strong>每秒一个单位</strong> 的速度移动。其中，一部分蚂蚁向 <strong>左</strong> 移动，其他蚂蚁向 <strong>右</strong> 移动。</p><p>当两只向 <strong>不同</strong> 方向移动的蚂蚁在某个点相遇时，它们会同时改变移动方向并继续移动。假设更改方向不会花费任何额外时间。</p><p>而当蚂蚁在某一时刻 <code>t</code> 到达木板的一端时，它立即从木板上掉下来。</p><p>给你一个整数 <code>n</code> 和两个整数数组 <code>left</code> 以及 <code>right</code> 。两个数组分别标识向左或者向右移动的蚂蚁在 <code>t = 0</code> 时的位置。请你返回最后一只蚂蚁从木板上掉下来的时刻。</p></blockquote><p>题目写的花里胡哨的，但是想想看，两只蚂蚁碰面的时候，究竟发生了什么？</p><p><strong>改变移动方向并继续移动</strong>，这是不是等同于他们<strong>穿过了彼此，然后继续移动</strong>？</p><p>所以就不用考虑碰不碰面的问题，就当每只蚂蚁都是独立的，而现在要求的就是行走最远的蚂蚁走了多久。</p><p>因此答案就是：</p><ol><li>向左走的蚂蚁要走到 <code>0</code> 的位置，走的最远的路程就是他们所在的位置的最大值，也就是 <code>max(left)</code></li><li>向右走的蚂蚁要走到 <code>n</code> 的位置，走的最远的路程就是 <code>n</code> 减去他们所在的位置的最小值，也就是 <code>n - max(right)</code></li><li>最终的结果就是上面两个的最大值。</li></ol><p>解答如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLastMoment</span>(<span class="params">self, n: <span class="built_in">int</span>, left: <span class="type">List</span>[<span class="built_in">int</span>], right: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(left))</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, n - <span class="built_in">min</span>(right))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;这篇文章主要包含以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#292-nim-%E6%B8%B8%E6%88%8F&quot;&gt;#292 - Nim 游戏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#319-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3&quot;&gt;#319 - 灯泡开关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#521-%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97-%E2%85%B0&quot;&gt;#521 - 最长特殊序列 Ⅰ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#777-%E5%9C%A8lr%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6&quot;&gt;#777 - 在LR字符串中交换相邻字符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#1033-%E7%A7%BB%E5%8A%A8%E7%9F%B3%E5%AD%90%E7%9B%B4%E5%88%B0%E8%BF%9E%E7%BB%AD&quot;&gt;#1033 - 移动石子直到连续&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#1227-%E9%A3%9E%E6%9C%BA%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D%E6%A6%82%E7%8E%87&quot;&gt;#1227 - 飞机座位分配概率&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#1503-%E6%89%80%E6%9C%89%E8%9A%82%E8%9A%81%E6%8E%89%E4%B8%8B%E6%9D%A5%E5%89%8D%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%88%BB&quot;&gt;#1503 - 所有蚂蚁掉下来前的最后一刻&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.czccc.cc/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://blog.czccc.cc/tags/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://blog.czccc.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Zeek 的安装与使用</title>
    <link href="http://blog.czccc.cc/p/b8bdff8e/"/>
    <id>http://blog.czccc.cc/p/b8bdff8e/</id>
    <published>2020-11-11T07:15:35.000Z</published>
    <updated>2022-08-06T13:07:33.625Z</updated>
    
    <content type="html"><![CDATA[<hr><h1>Zeek</h1><p><a target="_blank" rel="noopener" href="https://docs.zeek.org/en/current/install/install.html">Zeek 官方文档</a></p><span id="more"></span><h2 id="依赖安装">依赖安装</h2><p>Zeek 需要下列的依赖才能进行运行：</p><blockquote><ul><li>Libpcap (<a target="_blank" rel="noopener" href="http://www.tcpdump.org/">http://www.tcpdump.org</a>)</li><li>OpenSSL libraries (<a target="_blank" rel="noopener" href="http://www.openssl.org/">http://www.openssl.org</a>)</li><li>BIND8 library</li><li>Libz</li><li>Bash (for ZeekControl)</li><li>Python 2.6 or greater (for ZeekControl)</li></ul></blockquote><p>如果想要从源码编译 <code>zeek</code>，下面这些附加的依赖也需要安装：</p><blockquote><ul><li>CMake 3.0 or greater (<a target="_blank" rel="noopener" href="http://www.cmake.org/">http://www.cmake.org</a>)</li><li>Make</li><li>C/C++ compiler with C++17 support (GCC 7+ or Clang 4+)</li><li>SWIG (<a target="_blank" rel="noopener" href="http://www.swig.org/">http://www.swig.org</a>)</li><li>Bison 2.5 or greater (<a target="_blank" rel="noopener" href="https://www.gnu.org/software/bison/">https://www.gnu.org/software/bison/</a>)</li><li>Flex (lexical analyzer generator) (<a target="_blank" rel="noopener" href="https://github.com/westes/flex">https://github.com/westes/flex</a>)</li><li>Libpcap headers (<a target="_blank" rel="noopener" href="http://www.tcpdump.org/">http://www.tcpdump.org</a>)</li><li>OpenSSL headers (<a target="_blank" rel="noopener" href="http://www.openssl.org/">http://www.openssl.org</a>)</li><li>zlib headers (<a target="_blank" rel="noopener" href="https://zlib.net/">https://zlib.net/</a>)</li><li>Python (<a target="_blank" rel="noopener" href="https://www.python.org/">https://www.python.org/</a>)</li></ul></blockquote><p>可以通过以下的命令来安装这些依赖：</p><ul><li><p>基于 RPM/RedHat 的 Linux 发行版:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install cmake make gcc gcc-c++ flex bison libpcap-devel openssl-devel python-devel swig zlib-devel</span><br></pre></td></tr></table></figure><p>在 RHEL/CentOS 6/7, 可以通过 <code>devtoolset</code> 来安装最新的 <code>gcc</code> 版本。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install cmake3 devtoolset-7</span><br><span class="line">scl <span class="built_in">enable</span> devtoolset-7 bash</span><br></pre></td></tr></table></figure></li><li><p>基于 DEB/Debian 的 Linux 发行版:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cmake make gcc g++ flex bison libpcap-dev libssl-dev python-dev swig zlib1g-dev</span><br></pre></td></tr></table></figure><p>如果你的系统中安装的是 <code>Python 2.7</code>， 你还需要安装 <code>python-ipaddress</code>。</p></li></ul><h2 id="安装-Zeek">安装 Zeek</h2><h3 id="从源码安装">从源码安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/zeek/zeek</span><br><span class="line"><span class="built_in">cd</span> zeek</span><br><span class="line">./configure --prefix=/opt/zeek --with-pcap=/opt/PF_RING</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"><span class="built_in">export</span> PATH=/opt/zeek/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>检查 zeek 是否正确使用了 PF_RING:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldd /opt/zeek/bin/zeek | grep pcap</span><br><span class="line">    libpcap.so.1 =&gt; /opt/pf_ring/lib/libpcap.so.1 (0x00007fa371e33000)</span><br></pre></td></tr></table></figure><h3 id="从二进制文件安装">从二进制文件安装</h3><p>从这个<a target="_blank" rel="noopener" href="https://zeek.org/get-zeek">下载页面</a>可以下载各个版本的 <code>zeek</code> 程序.</p><h3 id="使用-Docker-安装">使用 Docker 安装</h3><p>请查看这个 <a target="_blank" rel="noopener" href="https://github.com/zeek/zeek-docker">Github</a> 仓库</p><h2 id="启动-zeek">启动 zeek</h2><h3 id="直接启动">直接启动</h3><p>假设配置文件为 <code>hello.zeek</code>:</p><p>捕获网卡<code>p1p2</code>的流量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/zeek/bin/zeek hello.zeek -C -i p1p2</span><br></pre></td></tr></table></figure><p>从<code>test.pcap</code>输入流量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/zeek/bin/zeek hello.zeek -C -r test.pcap</span><br></pre></td></tr></table></figure><h3 id="使用-zeekctl">使用 <code>zeekctl</code></h3><p>修改以下文件:</p><ul><li><code>$PREFIX/etc/node.cfg</code>, 修改单机或集群设置</li><li><code>$PREFIX/etc/networks.cfg</code>, 修改本地网络的定义</li><li><code>$PREFIX/etc/zeekctl.cfg</code>, 修改部分配置</li></ul><p>主要的改动在 <code>$PREFIX/etc/node.cfg</code>:</p><ol><li>单机启动 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zeek]</span><br><span class="line">type=standalone</span><br><span class="line">host=localhost</span><br><span class="line">interface=p1p2</span><br></pre></td></tr></table></figure></li><li>集群配置(流量分配有问题, 暂时不用) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[logger]</span><br><span class="line">type=logger</span><br><span class="line">host=localhost</span><br><span class="line"></span><br><span class="line">[manager]</span><br><span class="line">type=manager</span><br><span class="line">host=localhost</span><br><span class="line"></span><br><span class="line">[proxy-1]</span><br><span class="line">type=proxy</span><br><span class="line">host=localhost</span><br><span class="line"></span><br><span class="line">[worker-1]</span><br><span class="line">type=worker</span><br><span class="line">host=localhost</span><br><span class="line">interface=p1p2</span><br><span class="line">lb_method=pf_ring</span><br><span class="line">lb_procs=4</span><br><span class="line">pin_cpus=4,5,6,7</span><br><span class="line">env_vars=PCAP_PF_RING_CLUSTER_ID=99</span><br></pre></td></tr></table></figure></li></ol><p>之后启动 ZeekControl :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/zeek/bin/zeekctl</span><br></pre></td></tr></table></figure><p>使用 <code>deploy</code> 部署 zeek:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ZeekControl] &gt; deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1&gt;Zeek&lt;/h1&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://docs.zeek.org/en/current/install/install.html&quot;&gt;Zeek 官方文档&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Zeek" scheme="http://blog.czccc.cc/categories/Zeek/"/>
    
    
    <category term="Zeek" scheme="http://blog.czccc.cc/tags/Zeek/"/>
    
  </entry>
  
  <entry>
    <title>Zeek 简介</title>
    <link href="http://blog.czccc.cc/p/682f53b3/"/>
    <id>http://blog.czccc.cc/p/682f53b3/</id>
    <published>2020-11-10T11:05:48.000Z</published>
    <updated>2022-08-06T13:07:33.625Z</updated>
    
    <content type="html"><![CDATA[<hr><p>zeek 是一个被动的开源网络流量分析器，可深入检查网络连接上的所有流量以查找可疑活动的迹象。因其可扩展性强、可开箱即用等特点，被称为 “流量分析里的瑞士军刀”。</p><p>不同于 Snort 等基于流量签名检测的入侵检测系统（IDS），zeek 是基于网络连接来分析可疑行为的。具体地说，Zeek 会对每个网络中传输的数据包，从中提取出发送端的 IP 和端口以及接收端的 IP 和端口，从而通过四元组定义一个网络连接，并且将具有相同四元组的数据包收集在一起，再通过对应的 TCP、UDP 协议解析，对数据包进行排序重组，最后将其中携带的应用层数据交由应用层协议解析器，从而提取出数据包中所包含的所有内容，包括但不限于：应用层协议字段、传输的文件内容、协议记录等。</p><p>但是，了解Zeek的关键在于认识到，即使该系统具有开箱即用的强大功能，但从根本上来说，它还是一个可完全自定义和扩展的流量分析平台：Zeek为用户提供了特定于域的 Turing-完整的脚本语言用于表达任意分析任务。从概念上讲，您可以将Zeek视为 “特定于网络流量的 Python”：就像Python一样，该系统具有大量的预构建功能（“标准库”），但您不仅限于系统附带的功能，但可以通过编写自己的代码使Zeek以新颖的方式使用。实际上，Zeek的所有默认分析（包括所有日志记录）都是此类脚本的结果。没有硬编码到系统核心中的特定分析。</p><span id="more"></span><h2 id="特征">特征</h2><p>Zeek通过其脚本语言支持广泛的分析。即使没有进一步的自定义，它也具有强大的功能集。</p><ul><li><p>部署方式</p><blockquote><ul><li>在标准UNIX风格的系统（包括Linux，FreeBSD和MacOS）上的商用硬件上运行。</li><li>通过网络分接头或监视端口进行完全被动的流量分析。</li><li>用于捕获数据包的标准libpcap接口。</li><li>实时和离线分析。</li><li>集群支持大规模部署。</li><li>统一管理框架，可用于独立和群集设置。</li><li>在BSD许可下开源。</li></ul></blockquote></li><li><p>分析</p><blockquote><ul><li>全面记录活动，以进行离线分析和取证。</li><li>与应用程序层协议无关的端口分析。</li><li>支持许多应用程序层协议（包括DNS，FTP，HTTP，IRC，SMTP，SSH，SSL）。</li><li>分析通过应用层协议交换的文件内容，包括用于指纹识别的MD5 / SHA1计算。</li><li>全面的IPv6支持。</li><li>隧道检测和分析（包括Ayiya，Teredo，GTPv1）。Zeek将隧道解封装，然后继续分析其内容，就好像没有适当的隧道一样。</li><li>在协议分析过程中进行全面的健全性检查。</li><li>支持IDS样式的模式匹配。</li></ul></blockquote></li><li><p>脚本语言</p><blockquote><ul><li>图灵完备的语言，用于表达任意分析任务。</li><li>基于事件的编程模型。</li><li>特定于域的数据类型，例如IP地址（透明地处理IPv4和IPv6），端口号和计时器。</li><li>广泛支持随着时间的推移跟踪和管理网络状态。</li></ul></blockquote></li><li><p>界面</p><blockquote><ul><li>默认输出为结构良好的ASCII日志。</li><li>ElasticSearch和DataSeries的备用后端。正在准备其他数据库接口。</li><li>外部输入实时集成到分析中。正在准备实时数据库输入。</li><li>外部C库，用于与外部程序交换Zeek事件。带有Perl，Python和Ruby绑定。</li><li>能够从脚本语言内部触发任意外部进程。</li></ul></blockquote></li></ul><h2 id="历史">历史</h2><p><img src="https://s3.ax1x.com/2020/11/11/Bv8XFJ.png" alt="Bv8XFJ.png"></p><h2 id="Architecture">Architecture</h2><p>下图说明了Zeek群集的主要组件。</p><p><img src="https://docs.zeek.org/en/current/_images/deployment.png" alt=""></p><p>有关Zeek流程的连接方式，它们如何运行以及如何相互通信的更多特定信息，请参阅 <a target="_blank" rel="noopener" href="https://docs.zeek.org/en/current/frameworks/broker.html#brokercomm-framework">Broker Framework文档</a>。</p><h3 id="Tap">Tap</h3><p>Tap 是一种机制，用于拆分数据包流，以使副本可用于流量检查。示例包括交换机上的监视端口和光纤网络上的光分路器。</p><h3 id="Frontend">Frontend</h3><p>Frontend 是一种离散的硬件设备或主机技术，可将流量分成许多流或流。Zeek二进制文件不执行此工作。有多种方法可以完成此任务。</p><h3 id="Manager">Manager</h3><p>Manager 是一个Zeek流程，它使用 Zeek 通信协议从群集中其余节点接收日志消息和通知（请注意，如果使用单独的 Logger  节点，那么 Logger 将接收所有日志，而不是 Manager）。</p><h3 id="Logger">Logger</h3><p>Logger 是一个可选的Zeek进程，它使用Zeek通信协议从群集中其余节点接收日志消息。让 Logger 代替 Manager 接收日志的目的是为了减轻管理员的负担。如果不需要 Logger，则 Manager 将改为接收日志。</p><h3 id="Proxy">Proxy</h3><p>代理是Zeek进程，可用于卸载数据存储或任何任意工作负载。一个群集可能包含多个代理节点。Zeek随附的默认脚本使用的代理最少，因此仅使用一个代理就足够了，但是自定义使用它们来分区数据或工作负载提供了更大的群集可扩展性，而不仅仅是在单个集中式Manager节点上执行类似任务。</p><p>充当代理的Zeek进程在CPU或内存上的使用并不十分困难，并且用户经常在与管理器相同的物理主机上运行代理进程。</p><h3 id="Worker">Worker</h3><p>工作进程是Zeek进程，用于嗅探网络流量并对重组后的流量进行协议分析。活动集群的大部分工作都在工作程序上进行，因此，工作程序通常代表集群中正在运行的大部分Zeek进程。由于所有协议解析和大多数分析都将在此处进行，因此建议您使用负担得起的最快内存和CPU核心速度。对工作器中的磁盘没有特殊要求，因为几乎所有日志记录都是在远程对管理器进行的，并且通常很少写入磁盘。</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;zeek 是一个被动的开源网络流量分析器，可深入检查网络连接上的所有流量以查找可疑活动的迹象。因其可扩展性强、可开箱即用等特点，被称为 “流量分析里的瑞士军刀”。&lt;/p&gt;
&lt;p&gt;不同于 Snort 等基于流量签名检测的入侵检测系统（IDS），zeek 是基于网络连接来分析可疑行为的。具体地说，Zeek 会对每个网络中传输的数据包，从中提取出发送端的 IP 和端口以及接收端的 IP 和端口，从而通过四元组定义一个网络连接，并且将具有相同四元组的数据包收集在一起，再通过对应的 TCP、UDP 协议解析，对数据包进行排序重组，最后将其中携带的应用层数据交由应用层协议解析器，从而提取出数据包中所包含的所有内容，包括但不限于：应用层协议字段、传输的文件内容、协议记录等。&lt;/p&gt;
&lt;p&gt;但是，了解Zeek的关键在于认识到，即使该系统具有开箱即用的强大功能，但从根本上来说，它还是一个可完全自定义和扩展的流量分析平台：Zeek为用户提供了特定于域的 Turing-完整的脚本语言用于表达任意分析任务。从概念上讲，您可以将Zeek视为 “特定于网络流量的 Python”：就像Python一样，该系统具有大量的预构建功能（“标准库”），但您不仅限于系统附带的功能，但可以通过编写自己的代码使Zeek以新颖的方式使用。实际上，Zeek的所有默认分析（包括所有日志记录）都是此类脚本的结果。没有硬编码到系统核心中的特定分析。&lt;/p&gt;</summary>
    
    
    
    <category term="Zeek" scheme="http://blog.czccc.cc/categories/Zeek/"/>
    
    
    <category term="Zeek" scheme="http://blog.czccc.cc/tags/Zeek/"/>
    
  </entry>
  
  <entry>
    <title>位运算算法合集</title>
    <link href="http://blog.czccc.cc/p/cdd10903/"/>
    <id>http://blog.czccc.cc/p/cdd10903/</id>
    <published>2020-10-30T03:49:58.000Z</published>
    <updated>2022-08-06T13:07:33.619Z</updated>
    
    <content type="html"><![CDATA[<hr><span id="more"></span><h1>基本操作</h1><h2 id="左移">左移 <code>&lt;&lt;</code></h2><p>左移运算符实现将数字的所有二进制位向左移动一位，最高位移出数据，最低位补 <code>0</code>。一般也称为<strong>逻辑左移</strong>。</p><p>如果 <code>n</code> 为32位二进制数据，则左移相当于：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>&lt;</mo><mo>&lt;</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><msup><mn>2</mn><mi>i</mi></msup><mo stretchy="false">)</mo><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><msup><mn>2</mn><mn>32</mn></msup><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><msup><mn>2</mn><mn>31</mn></msup><mo stretchy="false">)</mo><mo>∗</mo><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">(n &lt;&lt; i) = (n * 2^i) \mod 2^{32} = (n \mod 2^{31}) * 2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0747em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span></p><h2 id="右移">右移 <code>&gt;&gt;</code></h2><p>右移运算符实现将数字的所有二进制位向右移动一位，最低位移出数据，最高位补 <code>0</code> 或 <strong>符号位</strong>。根据最高位的不同，可以分为两种，一种为<strong>逻辑右移</strong>，最高位全部补 <code>0</code>，一种为<strong>算术右移</strong>，最高位补符号位，也即正数补 <code>0</code>，负数补 <code>1</code>。</p><p>一般情况下，编程语言中对右移运算符的实现为：若操作数为无符号数，则使用逻辑右移；若为有符号数，则使用算术右移。</p><p>如果 <code>n</code> 为32位二进制数据，则右移相当于：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>&gt;</mo><mo>&gt;</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">%</mi><msup><mn>2</mn><mi>i</mi></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">(n &gt;&gt; i) = (n - (n \% 2^i)) / 2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0747em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord">%</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mclose">))</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span></p><h2 id="与">与 <code>&amp;</code></h2><table><thead><tr><th style="text-align:center"><code>x</code></th><th style="text-align:center"><code>y</code></th><th style="text-align:center"><code>z = x &amp; y</code></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table><ul><li>如果固定 <code>x = 0</code>，则输出 <code>z = 0</code>。使用此性质可以实现对特定的位进行<strong>置 <code>0</code></strong>。</li><li>如果固定 <code>x = 1</code>，则输出 <code>z = y</code>。使用此性质可以实现对特定的位进行<strong>取数</strong>。</li><li>如果 <code>n</code> 为32位 bit 数据，则通过 <code>(n &gt;&gt; i) &amp; 1</code> 可以得到第 <code>i</code> 位的数字。（下标从 <code>0</code> 开始）</li></ul><h2 id="或">或 <code>|</code></h2><p>|  <code>x</code>  |  <code>y</code>  | <code>z = x | y</code> |<br>| :—: | :—: | :---------: |<br>|   0   |   0   |      0      |<br>|   0   |   1   |      1      |<br>|   1   |   0   |      1      |<br>|   1   |   1   |      1      |</p><ul><li>如果固定 <code>x = 0</code>，则输出 <code>z = y</code>。使用此性质可以实现对特定的位进行<strong>取数</strong>。</li><li>如果固定 <code>x = 1</code>，则输出 <code>z = 1</code>。使用此性质可以实现对特定的位进行<strong>置 <code>1</code></strong>。</li></ul><h2 id="非">非 <code>~</code></h2><table><thead><tr><th style="text-align:center"><code>x</code></th><th style="text-align:center"><code>~ x</code></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><ul><li>非门可用于求操作数的补码，根据补码定义，数 <code>n</code> 的补码为：<code>(~ n) + 1</code></li></ul><h2 id="异或">异或 <code>^</code></h2><table><thead><tr><th style="text-align:center"><code>x</code></th><th style="text-align:center"><code>y</code></th><th style="text-align:center"><code>z = x ^ y</code></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><ul><li>如果固定 <code>x = 0</code>，则输出 <code>z = y</code>。使用此性质可以实现对特定的位进行<strong>取数</strong>。</li><li>如果固定 <code>x = 1</code>，则输出 <code>z = ~ y</code>。等同于非运算符。</li><li><code>x ^ x = 0</code></li><li><code>x ^ y = z</code> 可以得到：<code>x ^ z = y</code>， <code>y ^ z = x</code></li></ul><h2 id="同或">同或 <code>~^</code></h2><table><thead><tr><th style="text-align:center"><code>x</code></th><th style="text-align:center"><code>y</code></th><th style="text-align:center"><code>z = ~ (x ^ y)</code></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table><ul><li>用得较少，性质与异或相似。</li></ul><h1>基本操作</h1><p>在这里，我们假设所有的数字都是 32 位无符号数，用 <code>x, y, z, n</code> 表示，在需要有符号数处会进行说明。</p><p>使用 <code>i, j, k</code> 来表示数据的特定位，其中 <code>0 &lt;= i, j, k &lt; 32</code>。</p><p>同时，我们使用 <code>a, b, c</code> 来表示单个 bit 数据，也就是 <code>0 / 1</code>。</p><h2 id="生成-2-的-i-次幂">生成 <code>2</code> 的 <code>i</code> 次幂</h2><ul><li>左移：<code>1 &lt;&lt; i</code></li></ul><h2 id="取第-i-位数字">取第 <code>i</code> 位数字</h2><ul><li><strong>右移 + 与门</strong>：<code>(n &gt;&gt; i) &amp; 1</code></li><li>与门 + 右移：<code>(n &amp; (1 &lt;&lt; i)) &gt;&gt; i</code></li><li>右移 + 取余 + 或门：<code>((n &gt;&gt; i) % 2) | 0</code></li></ul><h2 id="对第-i-位置-0">对第 <code>i</code> 位置 <code>0</code></h2><ul><li>左移 + 非门 + 与门：<code>n &amp; (~ (1 &lt;&lt; i))</code></li></ul><h2 id="对第-i-位置-1">对第 <code>i</code> 位置 <code>1</code></h2><ul><li>左移 + 或门：<code>n | (1 &lt;&lt; i)</code></li></ul><h2 id="清除最后的-1">清除最后的 <code>1</code></h2><ul><li>减法 + 与门：<code>n &amp; (n - 1)</code></li></ul><h1>#136 - <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/description/">只出现一次的数字</a></h1><blockquote><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p></blockquote><p>对于这道题，最简单的办法就是使用一个哈希表，统计所有元素出现的次数，最后返回只出现一次的那个元素。但是这样的方法需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的空间，并不是一个很优秀的算法。</p><p>那么，如果使用位运算来做这个题，该怎么办呢？</p><p>首先，我们想要保留的是只出现一次的数字，也就是说出现两次的数字都需要消除掉，而这样的要求可以通过<strong>异或</strong>来实现：</p><ul><li>由于 <code>x ^ x = 0</code>，因此可以保证任何出现两次的数字都会相互抵消，只剩下 <code>0</code></li><li>由于 <code>x ^ 0 = x</code>，因此可以保证只出现一次的数字可以保留在结果之中</li></ul><p>有了这样的思路，程序的编写就很简单了。首先，我们初始化一个变量 <code>ans = 0</code>，接着遍历整个数组，将 <code>ans</code> 与每个数字都进行异或，最终遍历完成之后 <code>ans</code> 中的数字便是本题想要得到的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        ans ^= x</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="其他变体">其他变体</h2><h1>#137 - <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number-ii/description/">只出现一次的数字 II</a></h1><blockquote><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p></blockquote><p>与上面那道题比起来，本题只修改了一处，即是重复的数字每个出现三次。由于异或运算对于出现奇数次的数字都会保留下来，因此无法再像上面那道题一样对所有元素进行一遍异或求解。</p><p>但是，考虑到空间复杂度，我们仍然希望能够使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的空间，因此还是使用异或运算进行求解。</p><p>如果，对于一个元素，我们能够区分出它<strong>是否是第三次出现</strong>，从而在其第三次出现时，我们不将其加入到异或结果中，那么本题就和上面一道题是一致的。也就是说，我们的异或运算中，只包含出现一次的数字，和出现三次数字的前两次，因此最终的异或结果就是只出现一次的数字。</p><p>那么，现在的问题就是，如何在异或中区分出现第一次和第三次出现的数字。或者说，如何使第三次出现的元素不会加入到异或结果中。</p><p>假设我们的异或结果为 <code>ans</code>，其中数字 <code>x</code> 出现了 3 次。在与 <code>x</code> 完成两次异或后，此时 <code>ans = 0</code>，如果我们可以知道 <code>x</code> 是出现过两次的数字，那么在第三次时，可以通过 <code>ans = ~x &amp; (ans ^ x) = ~x &amp; x = 0</code>，使得第三个 <code>x</code> 对异或结果不产生任何影响。</p><p>那么怎么去判断 <code>x</code> 是出现过两次的数字呢？在这里我们使用另外一个变量 <code>t</code>，在每个 <code>x</code> 出现时，我们令：</p><ul><li><code>ans = ~t &amp; (ans ^ x)</code></li><li><code>t = ~ans &amp; (t ^ x)</code></li></ul><p>那么，我们可以来看一下运算的结果：</p><ul><li>初始时：<code>ans = 0, t = 0</code></li><li>第一次出现 <code>x</code>： <code>ans = x, t = 0 </code>，<code>ans</code> 保留了出现一次的 <code>x</code></li><li>第二次出现 <code>x</code>： <code>ans = 0, t = x </code>，<code>ans</code> 中重复出现的数字抵消，<code>t</code> 中保存了重复出现的数字</li><li>第三次出现 <code>x</code>： <code>ans = 0, t = 0 </code>，回到初始值。</li></ul><p>因此，在这样的算法下，<code>ans</code> 中只会保存出现一次的数字，而当数字重复出现时，均会被抵消。</p><p>具体的算法如下，在算法中，为了更有意义地命名，将 <code>ans</code> 写为 <code>seen_once</code>，将 <code>t</code> 写为 <code>seen_twice</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        seen_once = seen_twice = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            seen_once = ~seen_twice &amp; (seen_once ^ x)</span><br><span class="line">            seen_twice = ~seen_once &amp; (seen_twice ^ x)</span><br><span class="line">        <span class="keyword">return</span> seen_once</span><br></pre></td></tr></table></figure><h2 id="扩展：出现-n-次时如何求解">扩展：出现 n 次时如何求解</h2><p>让我们顺势思考下面的问题：</p><blockquote><p>如果有一个数字只出现 1 次，其余的数字均出现 n 次，该如何求解？</p></blockquote><h3 id="问题分析-2">问题分析</h3><p>我们可以对 <code>n</code> 做一个归纳：（显然 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n &gt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ）</p><ol><li>当 <code>n = 2</code> 或 <code>n = 3</code> 时，上面的算法已经给出答案</li><li>当 <code>n</code> 为偶数时，均可使用 <code>n = 2</code> 地算法来解决，因为异或运算对于偶数次的运算结果是一致的</li><li>当 <code>n</code> 为奇数的时候呢？看起来没有一个简单的办法。</li></ol><p>我们先来回顾一下 <code>n = 3</code> 时，列个表格看一下三次重复出现的数字产生了哪些变化：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><code>seen_once</code></th><th style="text-align:center"><code>seen_twice</code></th></tr></thead><tbody><tr><td style="text-align:center">初始值</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">0</td><td style="text-align:center">x</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><p>那么，如果 <code>n = 5</code> 呢，我们应该想要的也是一个类似于上面的表格：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">c</th><th style="text-align:center">d</th></tr></thead><tbody><tr><td style="text-align:center">初始值</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">0</td><td style="text-align:center">x</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">x</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">x</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><p>从而，我们可以写出下面的迭代算法：</p><ul><li><code>a = ~b &amp; ~c &amp; ~d &amp; (a ^ x)</code></li><li><code>b = ~a &amp; ~c &amp; ~d &amp; (b ^ x)</code></li><li><code>c = ~a &amp; ~b &amp; ~d &amp; (c ^ x)</code></li><li><code>d = ~a &amp; ~b &amp; ~c &amp; (d ^ x)</code></li></ul><p>为什么可以这样写呢？首先，从算法上来看，每个变量都是其他所有变量的 <code>&amp;</code> 并且再 <code>&amp;</code> 上它与 <code>x</code> 的异或。</p><p>那么，什么时候当前变量会进行改变呢？很明显，就是当其他的变量都是 <code>0</code>，自身也是 <code>0</code> 的时候，这个变量会变成 <code>x</code>；而当其他的变量都是 <code>0</code>，自身是 <code>x</code> 的时候，这个变量会变成 <code>0</code>。</p><ol><li>首先来看第一轮，由于初始值全是 <code>0</code>，因此 <code>a</code> 在第一步变为 <code>x</code>，而由于 <code>a = x</code>，因此第一轮中其他变量均不会发生变化，最后的结果为 <code>a = x, b = 0, c = 0, d = 0</code></li><li>接着是第二轮，当 <code>a</code> 再次进行迭代时，由于其他变量全为 <code>0</code>，而 <code>a = x</code>，因此 <code>a</code> 会变成 <code>0</code>；此时轮到 <code>b</code>，显然此时所有变量都为 <code>0</code>，因此在 <code>b</code> 运算结束后，<code>b</code> 会变成 <code>x</code>；同时剩余的 <code>c</code> 和 <code>d</code> 均不满足变化的条件，因此仍然为 <code>0</code>。最后的结果为 <code>a = 0, b = x, c = 0, d = 0</code></li><li>第三轮的变化也是类似的，<code>b</code> 从 <code>x</code> 变为 <code>0</code>，然后给了 <code>c</code> 一个机会从 <code>0</code> 变为 <code>x</code>，最后的结果为 <code>a = 0, b = 0, c = x, d = 0</code></li><li>第四轮同样，最后的结果为 <code>a = 0, b = 0, c = 0, d = x</code></li><li>到了第五轮，最终 <code>d</code> 由 <code>x</code> 变为了 <code>0</code>，运算结束，最后的结果为 <code>a = 0, b = 0, c = 0, d = 0</code>，再次回到初始值，可以进行下一次运算。</li></ol><p>从算法的过程中可以看出，这样的运算本质上是数字 <code>x</code> 在相邻变量中的传递过程，最终将其清零回归初始状态。而这个算法事实上不仅仅适用于 <code>n</code> 为奇数，<code>n</code> 为偶数也同样适用，只不过偶数的情况下有更适合的算法。</p><h3 id="算法归纳">算法归纳</h3><p>最后，我们可以归纳出这样的算法：</p><p>对于问题：<strong>如果有一个数字只出现 1 次，其余的数字均出现 n 次，该如何求解？</strong></p><blockquote><ol><li>首先，初始化 <code>n - 1</code> 个变量，均为 <code>0</code>，依次命名为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_1, ... x_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></li><li>对于每个在数组中出现的数字 <code>t</code>：<ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mtext> </mtext><msub><mi>x</mi><mn>2</mn></msub><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">&amp;</mi><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>⊕</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x_1 = ~x_2 \&amp; ... \&amp; x_{n-1} \&amp; (x_1 \oplus t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace nobreak"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">&amp;...&amp;</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.1056em;"></span><span class="mord">...</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mtext> </mtext><msub><mi>x</mi><mn>1</mn></msub><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">&amp;</mi><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>⊕</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x_{n-1} = ~x_1 \&amp; ... \&amp; x_{n-2} \&amp; (x_{n-1} \oplus t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace nobreak"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">&amp;...&amp;</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></li></ol></li><li>返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ol></blockquote><h3 id="再次扩展">再次扩展</h3><p>最后，如果将问题再次扩展：<strong>如果有一个数字只出现 <code>m</code> 次，其余的数字均出现 <code>n</code> 次，该如何求解？</strong> 其中 <code>m &lt; n</code></p><p>其实观察上面的表格就可以看出，如果是要求出现 <code>m</code> 次的数字，只需要最后返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">x_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 就可以实现。</p><h3 id="程序语言编写算法">程序语言编写算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 有一个数字只出现 m 次，其余的数字均出现 n 次</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums，m, n</span>):</span><br><span class="line">        seen = [<span class="number">0</span>] * (n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:  <span class="comment"># 对于每个数字</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(seen)):  <span class="comment"># 对于每个变量</span></span><br><span class="line">                seen[i] ^= t            <span class="comment"># 先计算异或的值</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(seen)):</span><br><span class="line">                    <span class="keyword">if</span> i != j:          <span class="comment"># 对于所有其他变量</span></span><br><span class="line">                        seen[i] &amp;= ~seen[j]    <span class="comment"># 进行与运算</span></span><br><span class="line">        <span class="keyword">return</span> seen[m - <span class="number">1</span>]<span class="comment"># 返回第 m 个变量</span></span><br></pre></td></tr></table></figure><h1>#260 - <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number-iii/description/">只出现一次的数字 III</a></h1><blockquote><p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p></blockquote><p>这个问题稍微简单一点，首先，如果我们对所有元素进行依次异或遍历，假设只出现一次的元素为 <code>x</code> 和 <code>y</code>，那么遍历的结果为 <code>bitmask = x ^ y</code>，由于 <code>x != y</code>，那么 <code>bitmask != 0</code>。</p><p>如果我们按位查看 <code>bitmask</code>，那么一定有一位不为 <code>0</code>，并且在这一位上，<code>x</code> 和 <code>y</code> 一定一个为 <code>1</code>，一个为 <code>0</code>。</p><p>因此我们可以找到这一位，在这里有个技巧是 <code>diff = bitmask &amp; (-bitmask)</code>，可以直接得到 <code>bitmask</code> 中最后一个 <code>1</code> 的掩码。</p><p>接着再次进行遍历，在这次遍历中，如果元素与 <code>diff</code> 相与为 <code>1</code>，说明该元素在对应位置上为 <code>1</code>，便将其进入到异或中，否则就略过。这样可以保证这一次的异或结果中只包含 <code>x</code> 和 <code>y</code> 其中的一个，最后返回 <code>[x, bitmask^x]</code> 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        bitmask = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            bitmask ^= num</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># rightmost 1-bit diff between x and y</span></span><br><span class="line">        diff = bitmask &amp; (-bitmask)</span><br><span class="line">        </span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># bitmask which will contain only x</span></span><br><span class="line">            <span class="keyword">if</span> num &amp; diff:</span><br><span class="line">                x ^= num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [x, bitmask^x]</span><br></pre></td></tr></table></figure><h1>#191 - <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-1-bits/description/">位1的个数</a></h1><p>本题可以利用之前提到的，<code>n &amp;= n - 1</code> 将数字最后一位 <code>1</code> 清除。</p><p>反复进行此操作，直至 <code>n == 0</code>，记录操作的次数，即为所求答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingWeight</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n &amp;= n - <span class="number">1</span></span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1>#231 - <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/power-of-two/description/">2的幂</a></h1><p>如果一个数字是 <code>2</code> 的幂，那么在二进制表示形式上，它一定只有一位为 <code>1</code>，因此如果使用 <code>n &amp; (n - 1)</code>，那么结果一定为 <code>0</code>。为了消除数字 <code>0</code> 的影响，加上 <code>n &gt; 0</code> 条件即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfTwo</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span></span><br></pre></td></tr></table></figure><h1>#342 - 4的幂</h1><p>如果一个数字是 <code>4</code> 的幂，那么首先它一定是 <code>2</code> 的幂，因此先加上判定条件：<code>num &gt; 0 and (num &amp; (num - 1)) == 0</code>。通过这个条件的数字中有且只有一位 <code>1</code>。</p><p>同时，数字是 <code>4</code> 的幂可以表示为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>=</mo><msup><mn>4</mn><mi>n</mi></msup><mo>=</mo><msup><mn>2</mn><mrow><mn>2</mn><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">num = 4^n = 2^{2n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>，因此，从二进制表示上来看，<code>1</code> 所在的位一定是奇数位，比如：<code>1 = 0000 0001</code>， <code>4 = 0000 0100</code>， <code>16 = 0001 0000</code>，……</p><p>因此我们可以再使用一个掩码：<code>0x55555555 = b'0101 0101 ... 0101</code>，来判断数字 <code>1</code> 是否出现在奇数位。如果 <code>num &amp; 0x55555555 &gt; 0</code>，说明出现在奇数位，则数字为 <code>4</code> 的幂；否则不是。</p><p>同样，我们也可以使用另外一个掩码：<code>0xAAAAAAAA = b'1010 1010 ... 1010</code>，判定条件相应变为：<code>num &amp; 0xAAAAAAAA == 0</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfFour</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> num &gt; <span class="number">0</span> <span class="keyword">and</span> \</span><br><span class="line">            (num &amp; (num - <span class="number">1</span>)) == <span class="number">0</span> <span class="keyword">and</span> \</span><br><span class="line">            (num &amp; <span class="number">0x55555555</span>) &gt; <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/description/">数字范围按位与</a></h1><h1><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-bits/description/">颠倒二进制位</a></h1>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.czccc.cc/categories/Algorithm/"/>
    
    
    <category term="bit-manipulation" scheme="http://blog.czccc.cc/tags/bit-manipulation/"/>
    
    <category term="位运算" scheme="http://blog.czccc.cc/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Gas station problem</title>
    <link href="http://blog.czccc.cc/p/c954d77a/"/>
    <id>http://blog.czccc.cc/p/c954d77a/</id>
    <published>2020-10-21T05:08:52.000Z</published>
    <updated>2022-08-06T13:07:33.619Z</updated>
    
    <content type="html"><![CDATA[<hr><h1>问题说明</h1><p>这是一道来自于 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gas-station/">LeetCode No.134</a> 的问题, 问题的定义如下：</p><p>在一条环路上有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个加油站，其中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个加油站有汽油 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>a</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">gas[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 升。</p><p>你有一辆油箱容量无限的的汽车，从第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个加油站开往第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个加油站需要消耗汽油 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">cost[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">cos</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回<strong>出发时加油站的编号</strong>，否则返回 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</p><p><strong>说明</strong>:</p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><p><strong>示例 1</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">gas  = [1, 2, 3, 4, 5]</span><br><span class="line">cost = [3, 4, 5, 1, 2]</span><br><span class="line"></span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">gas  = [2,3,4]</span><br><span class="line">cost = [3,4,3]</span><br><span class="line"></span><br><span class="line">输出: -1</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure><span id="more"></span><h1>编写测试程序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TEST ONLY</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SolutionTest</span>(unittest.TestCase):</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setUpClass</span>(<span class="params">cls</span>):</span><br><span class="line">        cls._func = Solution().canCompleteCircuit</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_1</span>(<span class="params">self</span>):</span><br><span class="line">        args = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">        ans = <span class="number">3</span></span><br><span class="line">        cur_ans = self._func(*args)</span><br><span class="line">        self.assertEqual(cur_ans, ans)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_2</span>(<span class="params">self</span>):</span><br><span class="line">        args = [[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        cur_ans = self._func(*args)</span><br><span class="line">        self.assertEqual(cur_ans, ans)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    unittest.main(verbosity=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h1>解法 1 - 暴力求解</h1><p>首先，先尝试暴力法。简单地说，既然问题最终的结果是出发点的索引，那么对于每一个加油站，都将其作为出发点进行尝试，如果能够实现返程，那么此加油站即为答案。如果所有加油站都不能实现返程，那么便返回 <code>-1</code> 作为结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canCompleteCircuit</span>(<span class="params">self, gas, cost</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type gas: List[int]</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(gas)</span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 对于每一个加油站， 都将其作为起点</span></span><br><span class="line">            curr_tank = <span class="number">0</span>       <span class="comment"># 初始时汽油量为 0</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> curr_tank &gt;= <span class="number">0</span>:</span><br><span class="line">                curr_station = (start + i) % n</span><br><span class="line">                curr_tank += gas[curr_station] - cost[curr_station]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == n <span class="keyword">and</span> curr_tank &gt;= <span class="number">0</span>:   <span class="comment"># 跑完 n 个站 且汽油量足够</span></span><br><span class="line">                <span class="keyword">return</span> start                <span class="comment"># 得到索引</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>很明显，这种解法的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，这样的算法效率自然不能够满足要求。</p><h1>解法 2 - 贪心策略</h1><p>现在的问题是，对于这个问题，能否有一种一次遍历的方式求解呢，也就是说算法的时间复杂度需要控制在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 。</p><p>答案当然是有的，下面我们来慢慢分析。</p><h2 id="问题分析">问题分析</h2><h3 id="能否跑完全程">能否跑完全程</h3><p>首先，对于这个问题，至少可以明确的一点是，如果 <code>gas</code> 的元素之和小于 <code>cost</code> 的元素之和，那么肯定不存在这样的行驶路线。</p><p>也就是说如果总的汽油量都填补不了总的消耗量，那么无论如何也跑不完全程。在这种情况下算法一定会返回 <code>-1</code>。</p><blockquote><p><strong>推论 1</strong>： 若 <code>sum(gas) &lt; sum(cost)</code>，则结果为 <code>-1</code></p></blockquote><p>但是当 <code>sum(gas) &gt;= sum(cost)</code> 时，该怎么确定呢？</p><p>为了再次简化问题，我们将 <code>gas</code> 和 <code>cost</code> 进行合并， 得到 <code>res</code>，其中： <code>res[i] = gas[i] - cost[i]</code></p><p>也即：<code>res</code> 表示的是经过每个站所需要的净汽油量，正负皆可。则有：</p><blockquote><p><strong>推论 2</strong>： 若 <code>sum(res) &lt; 0</code>，则结果为 <code>-1</code></p></blockquote><h3 id="能否作为起点">能否作为起点</h3><p>另外，由于出发时汽油量为 0，因此，如果在某个站，使 <code>gas[i] &lt; cost[i]</code>，也即 <code>res[i] &lt; 0</code>，则此点一定不是起点。</p><blockquote><p><strong>推论 3</strong>： 若 <code>res[i] &lt; 0</code>，则结果不为 <code>i</code></p></blockquote><p>同时，如果连续的加油站的净汽油量都大于 0，那么最终的答案只可能在这一串加油站的第一个位置（由于答案唯一），我们也有</p><blockquote><p>若 <code>res[i-1] &gt; 0, res[i] &gt; 0</code>，由于答案唯一，则结果不为 <code>i</code></p></blockquote><h3 id="如何选择起点">如何选择起点</h3><p>我们先来看一个 <code>sum(res) == 0</code> 的例子：</p><p><img src="https://s1.ax1x.com/2020/10/21/BC4vRI.png" alt=""></p><p>图中曲线表示的是 res 数组的前缀和，也可以认为是车内剩余的汽油量</p><h1>参考链接</h1>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1&gt;问题说明&lt;/h1&gt;
&lt;p&gt;这是一道来自于 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://leetcode-cn.com/problems/gas-station/&quot;&gt;LeetCode No.134&lt;/a&gt; 的问题, 问题的定义如下：&lt;/p&gt;
&lt;p&gt;在一条环路上有 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;N&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.6833em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.10903em;&quot;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 个加油站，其中第 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.6595em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 个加油站有汽油 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;gas[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 升。&lt;/p&gt;
&lt;p&gt;你有一辆油箱容量无限的的汽车，从第 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.6595em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 个加油站开往第 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;i+1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.7429em;vertical-align:-0.0833em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mbin&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mspace&quot; style=&quot;margin-right:0.2222em;&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.6444em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 个加油站需要消耗汽油 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;cost[i]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;cos&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;mopen&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mord mathnormal&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mclose&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 升。你从其中的一个加油站出发，开始时油箱为空。&lt;/p&gt;
&lt;p&gt;如果你可以绕环路行驶一周，则返回&lt;strong&gt;出发时加油站的编号&lt;/strong&gt;，否则返回 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;-1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.7278em;vertical-align:-0.0833em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;−&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果题目有解，该答案即为唯一答案。&lt;/li&gt;
&lt;li&gt;输入数组均为非空数组，且长度相同。&lt;/li&gt;
&lt;li&gt;输入数组中的元素均为非负数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1&lt;/strong&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gas  = [1, 2, 3, 4, 5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cost = [3, 4, 5, 1, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，3 可为起始索引。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2&lt;/strong&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gas  = [2,3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cost = [3,4,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，无论怎样，你都不可能绕环路行驶一周。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.czccc.cc/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://blog.czccc.cc/tags/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://blog.czccc.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Typora 快捷键</title>
    <link href="http://blog.czccc.cc/p/e402bc62/"/>
    <id>http://blog.czccc.cc/p/e402bc62/</id>
    <published>2020-09-01T14:29:29.000Z</published>
    <updated>2022-08-06T13:07:33.624Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>原文地址：<a target="_blank" rel="noopener" href="https://support.typora.io/Shortcut-Keys/">https://support.typora.io/Shortcut-Keys/</a></p></blockquote><span id="more"></span><h1>Shortcut Keys</h1><p>January 5, 2019 by <a target="_blank" rel="noopener" href="http://typora.io">typora.io</a></p><h2 id="TOC">TOC</h2><ul><li><a href="#summary">Summary</a></li><li><a href="#frequently-used-shortcut-keys">Frequently Used Shortcut Keys</a><ul><li><a href="#autocomplete">Autocomplete</a></li><li><a href="#file">File</a></li><li><a href="#edit">Edit</a></li><li><a href="#paragraph">Paragraph</a></li><li><a href="#format">Format</a></li><li><a href="#view">View</a></li></ul></li><li><a href="change-shortcut-keys">Change Shortcut Keys</a><ul><li><a href="#macos">macOS</a></li><li><a href="#windows-linux">Windows / Linux</a></li><li><a href="#q-shortcut-keys-does-not-work-on-ubuntu">Q: Shortcut keys does not work on Ubuntu</a></li></ul></li></ul><h2 id="Summary">Summary</h2><p>You can use shortcut keys to quickly insert or modify styles or do other operations supported by Typora.</p><p>You can find shortcut keys in the right side of each menu items from menu bar.</p><h2 id="Frequently-Used-Shortcut-Keys">Frequently Used Shortcut Keys</h2><h3 id="Autocomplete">Autocomplete</h3><p>On macOS, you can press <code>Esc</code> key to open inline preview for inline math, auto-complete for emoji, etc.</p><h3 id="File">File</h3><table><thead><tr><th style="text-align:left">Function</th><th style="text-align:left">Hotkey (Windows/Linux)</th><th>Hotkey (macOS)</th></tr></thead><tbody><tr><td style="text-align:left">New</td><td style="text-align:left">Ctrl + N</td><td>Command + N</td></tr><tr><td style="text-align:left">New Window</td><td style="text-align:left">Ctrl + Shift + N</td><td>Command +Shift + N</td></tr><tr><td style="text-align:left">New Tab</td><td style="text-align:left"><em>(Not Supported)</em></td><td>Command + T</td></tr><tr><td style="text-align:left">Open</td><td style="text-align:left">Ctrl + O</td><td>Command + O</td></tr><tr><td style="text-align:left">Open Quickly</td><td style="text-align:left">Ctrl + P</td><td>Command + Shift + O</td></tr><tr><td style="text-align:left">Reopen Closed File</td><td style="text-align:left">Ctrl + Shift + T</td><td>Command + Shift + T</td></tr><tr><td style="text-align:left">Save</td><td style="text-align:left">Ctrl + S</td><td>Command + S</td></tr><tr><td style="text-align:left">Save As / Duplicate</td><td style="text-align:left">Ctrl + Shift + S</td><td>Command + Shift + S</td></tr><tr><td style="text-align:left">Preference</td><td style="text-align:left">Ctrl + ,</td><td>Command + ,</td></tr><tr><td style="text-align:left">Close</td><td style="text-align:left">Ctrl + W</td><td>Command + W</td></tr></tbody></table><h3 id="Edit">Edit</h3><table><thead><tr><th style="text-align:left">Function</th><th style="text-align:left">Hotkey (Windows/Linux)</th><th>Hotkey (macOS)</th></tr></thead><tbody><tr><td style="text-align:left">New Paragraph</td><td style="text-align:left">Enter</td><td>Enter</td></tr><tr><td style="text-align:left">New Line</td><td style="text-align:left">Shift + Enter</td><td>Shift + Enter</td></tr><tr><td style="text-align:left">Cut</td><td style="text-align:left">Ctrl + X</td><td>Command + X</td></tr><tr><td style="text-align:left">Copy</td><td style="text-align:left">Ctrl + C</td><td>Command + C</td></tr><tr><td style="text-align:left">Paste</td><td style="text-align:left">Ctrl + V</td><td>Command + V</td></tr><tr><td style="text-align:left">Copy As Markdown</td><td style="text-align:left">Ctrl + Shift + C</td><td>Command + Shift + C</td></tr><tr><td style="text-align:left">Paste As Plain Text</td><td style="text-align:left">Ctrl + Shift + V</td><td>Command + Shift + V</td></tr><tr><td style="text-align:left">Select All</td><td style="text-align:left">Ctrl + A</td><td>Command + A</td></tr><tr><td style="text-align:left">Select Line/Sentence Select Row (in table)</td><td style="text-align:left">Ctrl + L</td><td>Command + L</td></tr><tr><td style="text-align:left">Delete Row (in table)</td><td style="text-align:left">Ctrl + Shift + Backspace</td><td>Command + Shift + Backspace</td></tr><tr><td style="text-align:left">Select Style Scope Select Cell (in table)</td><td style="text-align:left">Ctrl + E</td><td>Command + E</td></tr><tr><td style="text-align:left">Select Word</td><td style="text-align:left">Ctrl + D</td><td>Command + D</td></tr><tr><td style="text-align:left">Delete Word</td><td style="text-align:left">Ctrl + Shift + D</td><td>Command + Shift + D</td></tr><tr><td style="text-align:left">Jump to Top</td><td style="text-align:left">Ctrl + Home</td><td>Command + ↑</td></tr><tr><td style="text-align:left">Jump to Selection</td><td style="text-align:left">Ctrl + J</td><td>Command + J</td></tr><tr><td style="text-align:left">Jump to Buttom</td><td style="text-align:left">Ctrl + End</td><td>Command + ↓</td></tr><tr><td style="text-align:left">Find</td><td style="text-align:left">Ctrl + F</td><td>Command + F</td></tr><tr><td style="text-align:left">Find Next</td><td style="text-align:left">F3 / Enter</td><td>Command + G / Enter</td></tr><tr><td style="text-align:left">Find Previous</td><td style="text-align:left">Shift + F3 / Shift + Enter</td><td>Command + Shift + G / Shift + Enter</td></tr><tr><td style="text-align:left">Replace</td><td style="text-align:left">Ctrl + H</td><td>Command + H</td></tr></tbody></table><h3 id="Paragraph">Paragraph</h3><table><thead><tr><th style="text-align:left">Function</th><th style="text-align:left">Hotkey (Windows/Linux)</th><th>Hotkey (macOS)</th></tr></thead><tbody><tr><td style="text-align:left">Heading 1 to 6</td><td style="text-align:left">Ctrl + 1/2/3/4/5/6</td><td>Command + 1/2/3/4/5/6</td></tr><tr><td style="text-align:left">Paragraph</td><td style="text-align:left">Ctrl + 0</td><td>Command + 0</td></tr><tr><td style="text-align:left">Increase Heading Level</td><td style="text-align:left">Ctrl + =</td><td>Command + =</td></tr><tr><td style="text-align:left">Decrease Heading Level</td><td style="text-align:left">Ctrl + -</td><td>Command + -</td></tr><tr><td style="text-align:left">Table</td><td style="text-align:left">Ctrl + T</td><td>Command + Option + T</td></tr><tr><td style="text-align:left">Code Fences</td><td style="text-align:left">Ctrl + Shift + K</td><td>Command + Option + C</td></tr><tr><td style="text-align:left">Math Block</td><td style="text-align:left">Ctrl + Shift + M</td><td>Command + Option + B</td></tr><tr><td style="text-align:left">Quote</td><td style="text-align:left">Ctrl + Shift + Q</td><td>Command + Option + Q</td></tr><tr><td style="text-align:left">Ordered List</td><td style="text-align:left">Ctrl + Shift + [</td><td>Command + Option + O</td></tr><tr><td style="text-align:left">Unordered List</td><td style="text-align:left">Ctrl + Shift + ]</td><td>Command + Option + U</td></tr><tr><td style="text-align:left">Indent</td><td style="text-align:left">Ctrl + [ / Tab</td><td>Command + [ / Tab</td></tr><tr><td style="text-align:left">Outdent</td><td style="text-align:left">Ctrl + ] / Shift + Tab</td><td>Command + ] / Shift + Tab</td></tr></tbody></table><h3 id="Format">Format</h3><table><thead><tr><th style="text-align:left">Function</th><th style="text-align:left">Hotkey (Windows/Linux)</th><th>Hotkey (macOS)</th></tr></thead><tbody><tr><td style="text-align:left">Strong</td><td style="text-align:left">Ctrl + B</td><td>Command + B</td></tr><tr><td style="text-align:left">Emphasis</td><td style="text-align:left">Ctrl + I</td><td>Command + I</td></tr><tr><td style="text-align:left">Underline</td><td style="text-align:left">Ctrl + U</td><td>Command + U</td></tr><tr><td style="text-align:left">Code</td><td style="text-align:left">Ctrl + Shift + `</td><td>Command + Shift + `</td></tr><tr><td style="text-align:left">Strike</td><td style="text-align:left">Alt + Shift + 5</td><td>Control + Shift + `</td></tr><tr><td style="text-align:left">Hyperlink</td><td style="text-align:left">Ctrl + K</td><td>Command + K</td></tr><tr><td style="text-align:left">Image</td><td style="text-align:left">Ctrl + Shift + I</td><td>Command + Control + I</td></tr><tr><td style="text-align:left">Clear Format</td><td style="text-align:left">Ctrl + \</td><td>Command + \</td></tr></tbody></table><h3 id="View">View</h3><table><thead><tr><th style="text-align:left">Function</th><th style="text-align:left">Hotkey (Windows/Linux)</th><th>Hotkey (macOS)</th></tr></thead><tbody><tr><td style="text-align:left">Toggle Sidebar</td><td style="text-align:left">Ctrl + Shift + L</td><td>Command + Shift + L</td></tr><tr><td style="text-align:left">Outline</td><td style="text-align:left">Ctrl + Shift + 1</td><td>Command + Control + 1</td></tr><tr><td style="text-align:left">Articles</td><td style="text-align:left">Ctrl + Shift + 2</td><td>Command + Control + 2</td></tr><tr><td style="text-align:left">File Tree</td><td style="text-align:left">Ctrl + Shift + 3</td><td>Command + Control + 3</td></tr><tr><td style="text-align:left">Source Code Mode</td><td style="text-align:left">Ctrl + /</td><td>Command + /</td></tr><tr><td style="text-align:left">Focus Mode</td><td style="text-align:left">F8</td><td>F8</td></tr><tr><td style="text-align:left">Typewriter Mode</td><td style="text-align:left">F9</td><td>F9</td></tr><tr><td style="text-align:left">Toggler Fullscreen</td><td style="text-align:left">F11</td><td>Command + Option + F</td></tr><tr><td style="text-align:left">Actual Size</td><td style="text-align:left">Ctrl + Shift + 0</td><td><em>(Not Supported)</em></td></tr><tr><td style="text-align:left">Zoom In</td><td style="text-align:left">Ctrl + Shift + =</td><td><em>(Not Supported)</em></td></tr><tr><td style="text-align:left">Zoom Out</td><td style="text-align:left">Ctrl + Shift + -</td><td><em>(Not Supported)</em></td></tr><tr><td style="text-align:left">Switch Between Opened Documents</td><td style="text-align:left">Ctrl + Tab</td><td>Command + `</td></tr><tr><td style="text-align:left">Toggle DevTools</td><td style="text-align:left">Ctrl + Shift + I</td><td>-</td></tr></tbody></table><h2 id="Change-Shortcut-Keys">Change Shortcut Keys</h2><p>Users can set or reassign shortcut keys for commands in Typora’s menu bar. This article will shows how to do this.</p><h3 id="macOS">macOS</h3><p>We use macOS’s system feature to customize Typora’s key binding on macOS.</p><ol><li><p>Open <code>System Preference</code> → <code>Keyboard</code>, select tab <code>Shortcuts</code>. Select <code>App Shortcuts</code> in its left panel.</p><p><img src="https://support.typora.io/media/custom-key-binding/Snip20160814_1.png" alt="Snip20160814_1"></p></li><li><p>Click the “+” button, a dialog sheet would pop up. Select “Typora.app” from field <code>Application</code>, then enter the exact name of the menu command you want to add, and then type the shortcut key combination you want to assign.</p><p>For example, assume you want to add/change the shortcut key to pin Typora’s window, you can fill the dialog box as follows:</p><p><img src="https://support.typora.io/media/custom-key-binding/Snip20160814_5.png" alt="Snip20160814_5"></p><p>Then <code>Command+Shift+P</code> will be the shortcut key for menu command “always On Top”</p></li></ol><h3 id="Windows-Linux">Windows / Linux</h3><blockquote><p>Tip: This requires a version of Typora ≥ v0.9.16.</p></blockquote><ol><li><p>Open <code>Menu</code> → <code>Preference</code> in Typora, then click “Open Advanced Settings”.</p><p><img src="https://support.typora.io/media/custom-key-binding/sshot-1.png" alt="sshot-1"></p></li><li><p>Open and edit <code>conf.user.json</code> from opened “File Explore”. If there’s no such file, create one.</p></li><li><p>Set or add JSON object which represents a key binding, for example:</p><p><img src="https://support.typora.io/media/custom-key-binding/Snip20160814_7.png" alt="Snip20160814_7"></p></li><li><p>Restart Typora, and the new key binding will be applied.</p><p><img src="https://support.typora.io/media/custom-key-binding/sshot-2.png" alt="sshot-2"></p></li></ol><p>You can set or change shortcut keys for menu items in the menu bar in native window style.</p><h3 id="Q-Shortcut-keys-does-not-work-on-Ubuntu">Q: Shortcut keys does not work on Ubuntu</h3><p>For solutions to this problem please see:</p><ul><li><a target="_blank" rel="noopener" href="https://help.ubuntu.com/community/KeyboardShortcuts">https://help.ubuntu.com/community/KeyboardShortcuts</a> and</li><li><a target="_blank" rel="noopener" href="https://askubuntu.com/questions/208310/ctrl-a-doesnt-work-in-browsers">https://askubuntu.com/questions/208310/ctrl-a-doesnt-work-in-browsers</a>.</li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://support.typora.io/Shortcut-Keys/&quot;&gt;https://support.typora.io/Shortcut-Keys/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Typora" scheme="http://blog.czccc.cc/categories/Typora/"/>
    
    
    <category term="Typora" scheme="http://blog.czccc.cc/tags/Typora/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配算法</title>
    <link href="http://blog.czccc.cc/p/7458611/"/>
    <id>http://blog.czccc.cc/p/7458611/</id>
    <published>2020-08-28T05:32:00.000Z</published>
    <updated>2022-08-06T13:07:33.619Z</updated>
    
    <content type="html"><![CDATA[<hr><p>字符串匹配算法是一个经常使用的算法。具体地说，字符串匹配的任务是：给定一个待搜索的字符串（往往较长，通常称为 <code>haystack</code>），以及一个想要搜索的字符串（往往较短，通常称为 <code>needle</code>），查找 <code>needle</code> 在 <code>haystack</code> 中出现的第一个位置（从 <strong>0</strong> 开始）。如果不存在，则返回 <strong>-1</strong>。</p><p>特别的，当 <code>needle</code> 为空字符串时，应该返回什么值呢？在 C 语言的 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/strstr/811469">strstr()</a> 以及 Java 的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)">indexOf()</a> 定义中，此情况下的返回值为<strong>0</strong>。</p><span id="more"></span><h1>问题定义</h1><p>实现 <code>strStr()</code> 函数。</p><p>给定一个 <code>haystack</code> 字符串和一个 <code>needle</code> 字符串，在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置 (从 0 开始)。如果不存在，则返回  -1。</p><p>记：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 为 <code>haystack</code> 字符串的长度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 为 <code>needle</code> 字符串的长度。</p><h1>Brute force - 暴力法</h1><h2 id="子串逐一比较">子串逐一比较</h2><p>Brute force 方法，也成为暴力法，思路是直接对 <code>haystack</code> 中每个长度等于 <code>needle</code> 的子字符串进行比较，若其内容与 <code>needle</code> 相同，则搜索成功，返回首个字符的索引。如果遍历到字符串结尾仍然未找到结果，则搜索失败，返回 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    L, n = <span class="built_in">len</span>(needle), <span class="built_in">len</span>(haystack)</span><br><span class="line">    <span class="comment"># 当 L == 0 时，会使 haystack[start: start + L] 也为空</span></span><br><span class="line">    <span class="comment"># 因此不必对 L == 0 额外进行判断</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(n - L + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> haystack[start: start + L] == needle:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mi>L</mi><mo stretchy="false">)</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((N - L)L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span>。内循环中比较字符串的复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>，总共需要比较 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(N - L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span> 次。</p></li><li><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p></li></ul><h2 id="双指针">双指针</h2><p>在初始的 Brute force 方法中，由于会将 <code>haystack</code> 所有长度为 L 的子串都与 <code>needle</code> 字符串比较，实际上是不需要这么做的。</p><p>首先，只有子串的第一个字符跟 needle 字符串第一个字符相同的时候才需要比较。</p><p>其次，可以一个字符一个字符比较，一旦不匹配了就立刻终止。</p><p>因此，可以对其进行改进，使用两个指针，算法流程为：</p><ul><li><p>移动 <code>pn</code> 指针，直到 <code>pn</code> 所指向位置的字符与 <code>needle</code> 字符串第一个字符相等。</p></li><li><p>通过 <code>pn</code>，<code>pL</code>，<code>curr_len</code> 计算匹配长度。</p></li><li><p>如果完全匹配（即 <code>curr_len == L</code>），返回匹配子串的起始坐标（即 <code>pn - L</code>）。</p></li><li><p>如果不完全匹配，回溯。使 <code>pn = pn - curr_len + 1</code>， <code>pL = 0</code>， <code>curr_len = 0</code>。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    L, n = <span class="built_in">len</span>(needle), <span class="built_in">len</span>(haystack)</span><br><span class="line">    <span class="keyword">if</span> L == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    pn = <span class="number">0</span><span class="comment"># 子串头指针</span></span><br><span class="line">    <span class="keyword">while</span> pn &lt; n - L + <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 待匹配指针</span></span><br><span class="line">        pL = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 计算最长的匹配长度</span></span><br><span class="line">        <span class="keyword">while</span> pL &lt; L <span class="keyword">and</span> haystack[pn + pL] == needle[pL]:</span><br><span class="line">            pL += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果匹配了 needle 的全部字符，则返回当前子串头指针位置</span></span><br><span class="line">        <span class="keyword">if</span> pL == L:</span><br><span class="line">            <span class="keyword">return</span> pn</span><br><span class="line">        <span class="comment"># 否则，头指针后移，继续查找</span></span><br><span class="line">        pn += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：最坏时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mi>L</mi><mo stretchy="false">)</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O((N - L)L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span>，最优时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li></ul><h1>Knuth–Morris–Pratt</h1><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p><p>KMP 算法，是在字符串匹配算法中比较经典的一个算法，它以三个发明者 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">Knuth-Morris-Pratt</a> 的名称命名，起头的那个 K 就是著名科学家 Donald Knuth。</p><p>首先，让我们回顾一下上面的暴力法，暴力法的效率问题主要体现在，当出现位置不匹配时，它会同时回退 <code>haystack</code> 和 <code>needle</code> 的位置，具体地说，<code>haystack</code> 的搜索位置从 <code>pn + pL</code> 回退到 <code>pn</code>，<code>needle</code> 的搜索位置从 <code>pL</code> 回退到 <code>0</code>，这种回退机制导致了算法往往会进行很多不必要的操作。</p><p>比如，如果 <code>haystack</code> 为 <code>aaacaaadaaa</code>，而 <code>needle</code> 为 <code>aaaa</code>，算法在第一次会对 <code>aaac</code> 和 <code>aaaa</code> 进行比较，然后第二次对 <code>aaca</code> 和 <code>aaaa</code> 进行比较…这就导致了一个问题，由于 <code>needle</code> 中根本就没有 <code>c</code> 这个字符，所有这几次比较注定是失败的。这也就是暴力法效率差的主要原因。</p><p>那么，在 KMP 中，如何利用已知的比较信息，从而不要把“<code>haystack</code> 中的搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。</p><p>想要做到这一点，需要针对于 <code>needle</code>，产生一个<strong>部分匹配表</strong>，例如，当 <code>needle</code> 为 <code>ABCDABD</code> 时，部分匹配表如下：</p><table><thead><tr><th>搜索词</th><th>A</th><th>B</th><th>C</th><th>D</th><th>A</th><th>B</th><th>D</th></tr></thead><tbody><tr><td>部分匹配值</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td></tr></tbody></table><blockquote><p>对于这张表的介绍，以及如何使用，<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html"><strong>这篇文章</strong></a>已经写的非常清楚，本文中不再赘述</p></blockquote><h2 id="计算部分匹配表">计算部分匹配表</h2><p>首先，要了解两个概念：“前缀” 和 “后缀”。 “前缀” 指除了最后一个字符以外，一个字符串的全部头部组合；“后缀” 指除了第一个字符以外，一个字符串的全部尾部组合。</p><p>“部分匹配值” 就是 “前缀” 和 “后缀” 的最长的共有元素的长度。以 “ABCDABD” 为例：</p><table><thead><tr><th>子串</th><th>前缀集</th><th style="text-align:left">后缀集</th><th>共有元素</th><th>部分匹配值</th></tr></thead><tbody><tr><td>A</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span></td><td>0</td></tr><tr><td>AB</td><td>A</td><td style="text-align:left">B</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span></td><td>0</td></tr><tr><td>ABC</td><td>A, AB</td><td style="text-align:left">BC, C</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span></td><td>0</td></tr><tr><td>ABCD</td><td>A, AB, ABC</td><td style="text-align:left">BCD, CD, D</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span></td><td>0</td></tr><tr><td>ABCDA</td><td>A, AB, ABC, ABCD</td><td style="text-align:left">BCDA, CDA, DA, A</td><td>A</td><td>1</td></tr><tr><td>ABCDAB</td><td>A, AB, ABC, ABCD, ABCDA</td><td style="text-align:left">BCDAB, CDAB, DAB, AB, B</td><td>AB</td><td>2</td></tr><tr><td>ABCDABD</td><td>A, AB, ABC, ABCD, ABCDA, ABCDAB</td><td style="text-align:left">BCDABD, CDABD, DABD, ABD, BD, D</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span></td><td>0</td></tr></tbody></table><p>“部分匹配” 的实质是，有时候，字符串头部和尾部会有重复。比如，“ABCDAB” 之中有两个 “AB”，那么它的 “部分匹配值” 就是 2（“AB” 的长度）。搜索词移动的时候，第一个 “AB” 向后移动 4 位（字符串长度 - 部分匹配值），就可以来到第二个 “AB” 的位置。</p><h1>Sunday</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-strstr/solution/python3-sundayjie-fa-9996-by-tes/">https://leetcode-cn.com/problems/implement-strstr/solution/python3-sundayjie-fa-9996-by-tes/</a></p><h1>Horspool</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cobbliu/archive/2012/05/29/2524244.html">https://www.cnblogs.com/cobbliu/archive/2012/05/29/2524244.html</a></p><h1>Boyer-Moore</h1><p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html">https://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html</a></p><h1>Rabin Karp</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode/">https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode/</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;字符串匹配算法是一个经常使用的算法。具体地说，字符串匹配的任务是：给定一个待搜索的字符串（往往较长，通常称为 &lt;code&gt;haystack&lt;/code&gt;），以及一个想要搜索的字符串（往往较短，通常称为 &lt;code&gt;needle&lt;/code&gt;），查找 &lt;code&gt;needle&lt;/code&gt; 在 &lt;code&gt;haystack&lt;/code&gt; 中出现的第一个位置（从 &lt;strong&gt;0&lt;/strong&gt; 开始）。如果不存在，则返回 &lt;strong&gt;-1&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;特别的，当 &lt;code&gt;needle&lt;/code&gt; 为空字符串时，应该返回什么值呢？在 C 语言的 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://baike.baidu.com/item/strstr/811469&quot;&gt;strstr()&lt;/a&gt; 以及 Java 的 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)&quot;&gt;indexOf()&lt;/a&gt; 定义中，此情况下的返回值为&lt;strong&gt;0&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://blog.czccc.cc/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://blog.czccc.cc/tags/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://blog.czccc.cc/tags/LeetCode/"/>
    
    <category term="String" scheme="http://blog.czccc.cc/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 中的数学算法</title>
    <link href="http://blog.czccc.cc/p/ffac41da/"/>
    <id>http://blog.czccc.cc/p/ffac41da/</id>
    <published>2020-08-27T06:52:58.000Z</published>
    <updated>2022-08-06T13:07:33.619Z</updated>
    
    <content type="html"><![CDATA[<hr><span id="more"></span><h1>50. Pow(x, n)</h1><p>实现 <code>pow(x, n)</code> ，即计算 x 的 n 次幂函数。</p><p>示例:</p><ul><li><p>输入: <code>2.00000, 10</code><br>输出: <code>1024.00000</code></p></li><li><p>输入: <code>2.10000, 3</code><br>输出: <code>9.26100   </code></p></li><li><p>输入: <code>2.00000, -2</code><br>输出: <code>0.25000</code></p><ul><li>解释:  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>4</mn><mo>=</mo><mn>0.25</mn></mrow><annotation encoding="application/x-tex">2^{-2} = (1/2)^2 = 1/4 = 0.25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1/2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.25</span></span></span></span></li></ul></li></ul><p>说明: <code>-100.0 &lt; x &lt; 100.0</code>. <code>n</code> 是 32 位有符号整数，其数值范围是 [<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>] 。</p><p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/powx-n">https://leetcode-cn.com/problems/powx-n</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://blog.czccc.cc/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://blog.czccc.cc/tags/LeetCode/"/>
    
    <category term="Math" scheme="http://blog.czccc.cc/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>SQL 必知必会 - 数据更新/存储/事务</title>
    <link href="http://blog.czccc.cc/p/3b57f622/"/>
    <id>http://blog.czccc.cc/p/3b57f622/</id>
    <published>2020-08-12T06:25:37.000Z</published>
    <updated>2022-08-06T13:07:33.622Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>SQL 必知必会 - 全书目录</p><ol><li>第 01 - 10 章：<a href="/p/57d19b2c">SQL 必知必会 - 单表查询/过滤/汇总</a></li><li>第 11 - 24 章：<a href="/p/4c50c6b4">SQL 必知必会 - 多表查询/联结/组合</a></li><li>第 15 - 24 章：<a href="/p/3b57f622">SQL 必知必会 - 数据更新/存储/事务</a></li></ol></blockquote><span id="more"></span><h1>插入数据 - <code>INSERT</code></h1><ul><li><code>INSERT</code> 用来将行插入（或添加）到数据库表<ul><li>在某些 SQL 实现中，跟在 <code>INSERT</code> 之后的 <code>INTO</code> 关键字是可选的</li></ul></li><li>插入完整的行<ul><li>不要使用没有明确给出列的 <code>INSERT</code> 语句</li><li><code>VALUES</code> 的数目都必须正确</li></ul></li><li>插入行的一部分<ul><li>可以在 <code>INSERT</code> 操作中省略某些列<ul><li>该列定义为允许 <code>NULL</code> 值（无值或空值）</li><li>在表定义中给出默认值。这表示如果不给出值，将使用默认值</li></ul></li></ul></li><li>插入某些查询的结果：<code>INSERT SELECT</code><ul><li><code>INSERT SELECT</code> 中 <code>SELECT</code> 语句可以包含 <code>WHERE</code> 子句，以过滤插入的数据</li></ul></li><li><code>INSERT</code> 通常只插入一行。要插入多行，必须执行多个 <code>INSERT</code> 语句。<code>INSERT SELECT</code> 是个例外，它可以用一条 <code>INSERT</code> 插入多行，不管 <code>SELECT</code> 语句返回多少行，都将被 <code>INSERT</code> 插入</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入完整的行, 必须给每一列提供一个值</span></span><br><span class="line"><span class="comment">-- 高度依赖于表中列的定义次序，还依赖于其容易获得的次序信息</span></span><br><span class="line"><span class="comment">-- 这种语法很简单，但并不安全，应该尽量避免使用</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers</span><br><span class="line"><span class="keyword">VALUES</span>( <span class="string">&#x27;1000000006&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Toy Land&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;123 Any Street&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;New York&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NY&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;11111&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;USA&#x27;</span>,</span><br><span class="line">        <span class="keyword">NULL</span>,</span><br><span class="line">        <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更安全（不过更烦琐）的方法</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_id,</span><br><span class="line">                      cust_name,</span><br><span class="line">                      cust_address,</span><br><span class="line">                      cust_city,</span><br><span class="line">                      cust_state,</span><br><span class="line">                      cust_zip,</span><br><span class="line">                      cust_country,</span><br><span class="line">                      cust_contact,</span><br><span class="line">                      cust_email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;1000000006&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Toy Land&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;123 Any Street&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;New York&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;NY&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;11111&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;USA&#x27;</span>,</span><br><span class="line">       <span class="keyword">NULL</span>,</span><br><span class="line">       <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入部分行</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_id,</span><br><span class="line">                      cust_name,</span><br><span class="line">                      cust_address,</span><br><span class="line">                      cust_city,</span><br><span class="line">                      cust_state,</span><br><span class="line">                      cust_zip,</span><br><span class="line">                      cust_country)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;1000000006&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;Toy Land&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;123 Any Street&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;New York&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;NY&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;11111&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;USA&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入检索出的数据</span></span><br><span class="line"><span class="comment">-- INSERT SELECT</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers(cust_id,</span><br><span class="line">                      cust_contact,</span><br><span class="line">                      cust_email,</span><br><span class="line">                      cust_name,</span><br><span class="line">                      cust_address,</span><br><span class="line">                      cust_city,</span><br><span class="line">                      cust_state,</span><br><span class="line">                      cust_zip,</span><br><span class="line">                      cust_country)</span><br><span class="line"><span class="keyword">SELECT</span>  cust_id,</span><br><span class="line">        cust_contact,</span><br><span class="line">        cust_email,</span><br><span class="line">        cust_name,</span><br><span class="line">        cust_address,</span><br><span class="line">        cust_city,</span><br><span class="line">        cust_state,</span><br><span class="line">        cust_zip,</span><br><span class="line">        cust_country</span><br><span class="line"><span class="keyword">FROM</span> CustNew;</span><br></pre></td></tr></table></figure><ul><li>从一个表复制到另一个表：使用 <code>SELECT INTO</code> 语句<ul><li>任何 <code>SELECT</code> 选项和子句都可以使用，包括 <code>WHERE</code> 和 <code>GROUP BY</code></li><li>可利用联结从多个表插入数据</li><li>不管从多少个表中检索数据，数据都只能插入到一个表中</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个名为 CustCopy 的新表, 并把 Customers 表的整个内容复制到新表中</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">INTO</span> CustCopy</span><br><span class="line"><span class="keyword">FROM</span> Customers;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MariaDB、MySQL、Oracle、PostgreSQL 和 SQLite 使用的语法</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> CustCopy <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Customers;</span><br></pre></td></tr></table></figure><h1>更新和删除数据 - <code>UPDATE/DELETE</code></h1><h2 id="更新数据">更新数据</h2><ul><li>更新数据：<code>UPDATE</code> 语句，不要省略 <code>WHERE</code> 子句，否则将会更新所有行</li><li>基本的 <code>UPDATE</code> 语句<ul><li>要更新的表</li><li>列名和它们的新值</li><li>确定要更新哪些行的过滤条件</li></ul></li><li><code>UPDATE</code> 语句中可以使用子查询，使得能用 <code>SELECT</code> 语句检索出的数据更新列数据</li><li>要删除某个列的值，可设置它为 <code>NULL</code>（假如表定义允许 <code>NULL</code> 值）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Customers</span><br><span class="line"><span class="keyword">SET</span> cust_contact <span class="operator">=</span> <span class="string">&#x27;Sam Roberts&#x27;</span>,</span><br><span class="line">cust_email <span class="operator">=</span> <span class="string">&#x27;kim@thetoystore.com&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="operator">=</span> <span class="string">&#x27;1000000005&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> Customers</span><br><span class="line"><span class="keyword">SET</span> cust_email <span class="operator">=</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="operator">=</span> <span class="string">&#x27;1000000005&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="删除数据">删除数据</h2><ul><li>删除数据：<code>DELETE</code> 语句，不要省略 <code>WHERE</code> 子句，否则将会删除所有行</li><li><code>DELETE</code> 不需要列名或通配符</li><li><code>DELETE</code> 删除整行而不是删除列</li><li><code>DELETE</code> 不删除表本身</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从 Customers 表中删除一行</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="operator">=</span> <span class="string">&#x27;1000000006&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>更新和删除的指导原则</strong><ul><li>除非确实打算更新和删除每一行，否则绝对不要使用不带 <code>WHERE</code> 子句的 <code>UPDATE</code> 或 <code>DELETE</code> 语句</li><li>保证每个表都有主键（如果忘记这个内容，请参阅第 12 课），尽可能像 <code>WHERE</code> 子句那样使用它（可以指定各主键、多个值或值的范围）</li><li>在 <code>UPDATE</code> 或 <code>DELETE</code> 语句使用 <code>WHERE</code> 子句前，应该先用 <code>SELECT</code> 进行测试，保证它过滤的是正确的记录，以防编写的WHERE 子句不正确。</li><li>使用强制实施引用完整性的数据库（关于这个内容，请参阅第 12 课），这样 DBMS 将不允许删除其数据与其他表相关联的行。</li><li>有的 DBMS 允许数据库管理员施加约束，防止执行不带 <code>WHERE</code> 子句的 <code>UPDATE</code> 或 <code>DELETE</code> 语句。如果所采用的 DBMS 支持这个特性，应该使用它。</li></ul></li></ul><h1>创建和操纵表 - <code>CREATE/ALTER</code></h1><h2 id="创建表">创建表</h2><ul><li>SQL 不仅用于表数据操纵，还用来执行数据库和表的所有操作，包括表本身的创建和处理。</li><li>用程序创建表，可以使用 SQL 的 <code>CREATE TABLE</code> 语句</li><li>在不同的 SQL 实现中，<code>CREATE TABLE</code> 语句的语法可能有所不同</li><li>在创建新的表时，指定的表名必须不存在，否则会出错。</li><li>利用CREATE TABLE 创建表，必须给出下列信息：<ul><li>新表的名字，在关键字CREATE TABLE 之后给出；</li><li>表列的名字和定义，用逗号分隔；</li><li>有的DBMS 还要求指定表的位置。</li></ul></li><li>每个表列要么是 <code>NULL</code> 列，要么是 <code>NOT NULL</code> 列，这种状态在创建时由表的定义规定。<code>NULL</code> 为默认设置</li><li>SQL 允许指定默认值，在插入行时如果不给出值，DBMS 将自动采用默认值。</li><li>默认值在 <code>CREATE TABLE</code> 语句的列定义中用关键字 <code>DEFAULT</code> 指定。</li><li>默认值经常用于日期或时间戳列。<ul><li>通过指定引用系统日期的函数或变量， 将系统日期用作默认日期</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Products</span><br><span class="line">(</span><br><span class="line">prod_id <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">vend_id <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">prod_name <span class="type">CHAR</span>(<span class="number">254</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">prod_price <span class="type">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span><span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">prod_desc <span class="type">VARCHAR</span>(<span class="number">1000</span>) <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="更新、删除表">更新、删除表</h2><ul><li>更新表定义，可以使用 <code>ALTER TABLE</code> 语句。<ul><li>理想情况下，不要在表中包含数据时对其进行更新。应该在表的设计过程中充分考虑未来可能的需求，避免今后对表的结构做大改动。</li><li>所有的DBMS 都允许给现有的表增加列，不过对所增加列的数据类型（以及 <code>NULL</code> 和 <code>DEFAULT</code> 的使用）有所限制。</li><li>许多DBMS 不允许删除或更改表中的列。</li><li>多数DBMS 允许重新命名表中的列。</li><li>许多DBMS 限制对已经填有数据的列进行更改，对未填有数据的列几乎没有限制。</li></ul></li><li>使用 <code>ALTER TABLE</code> 更改表结构，必须给出下面的信息：<ul><li>在 <code>ALTER TABLE</code> 之后给出要更改的表名（该表必须存在，否则将<br>出错）；</li><li>列出要做哪些更改。</li></ul></li><li>复杂的表结构更改一般需要手动删除过程，它涉及以下步骤：<br>1. 用新的列布局创建一个新表；<br>2. 使用 <code>INSERT SELECT</code> 语句（关于这条语句的详细介绍，请参阅第 15<br>课）从旧表复制数据到新表。有必要的话，可以使用转换函数和计算字段；<br>3. 检验包含所需数据的新表；<br>4. 重命名旧表（如果确定，可以删除它）；<br>5. 用旧表原来的名字重命名新表；<br>6. 根据需要，重新创建触发器、存储过程、索引和外键。</li><li>删除表：使用 <code>DROP TABLE</code> 语句</li><li>重命名表：<ul><li>DB2、MariaDB、MySQL、Oracle 和 PostgreSQL 用户使用 <code>RENAME</code><br>语句</li><li>SQL Server 用户使用 <code>sp_rename</code> 存储过程</li><li>SQLite 用户使用 <code>ALTER  TABLE</code> 语句</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给 Vendors 表增加一个名为 vend_phone 的列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Vendors</span><br><span class="line"><span class="keyword">ADD</span> vend_phone <span class="type">CHAR</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Vendors</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> vend_phone;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> CustCopy;</span><br></pre></td></tr></table></figure><h1>使用视图 - <code>CREATE VIEW</code></h1><ul><li>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</li><li>视图的一些常见应用：<ul><li>重用 SQL 语句，简化复杂的 SQL 操作</li><li>使用表的一部分而不是整个表</li><li>保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据</li></ul></li><li>视图创建和使用的一些最常见的规则和限制<ul><li>与表一样，视图必须唯一命名</li><li>创建视图，必须具有足够的访问权限</li><li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。所允许的嵌套层数在不同的 DBMS 中有所不同</li><li>许多 DBMS 禁止在视图查询中使用 <code>ORDER BY</code> 子句</li><li>有些 DBMS 要求对返回的所有列进行命名，如果列是计算字段，则需要使用别名</li><li>视图不能索引，也不能有关联的触发器或默认值</li><li>有些 DBMS 把视图作为只读的查询，这表示可以从视图检索数据，但不能将数据写回底层表</li><li>有些 DBMS 允许创建这样的视图，它不能进行导致行不再属于视图的插入或更新</li></ul></li><li>创建视图：<code>CREATE VIEW</code> 语句</li><li>删除视图：可以使用 <code>DROP</code> 语句，其语法为 <code>DROP VIEW viewname</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检索订购了某种产品的顾客</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> Customers, Orders, OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> Customers.cust_id <span class="operator">=</span> Orders.cust_id</span><br><span class="line">  <span class="keyword">AND</span> OrderItems.order_num <span class="operator">=</span> Orders.order_num</span><br><span class="line">  <span class="keyword">AND</span> prod_id <span class="operator">=</span> <span class="string">&#x27;RGAN01&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> ProductCustomers <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, prod_id</span><br><span class="line"><span class="keyword">FROM</span> Customers, Orders, OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> Customers.cust_id <span class="operator">=</span> Orders.cust_id</span><br><span class="line">  <span class="keyword">AND</span> OrderItems.order_num <span class="operator">=</span> Orders.order_num;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 包装成一个名为 ProductCustomers 的虚拟表</span></span><br><span class="line"><span class="comment">-- ProductCustomers 是一个视图</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> ProductCustomers</span><br><span class="line"><span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;RGAN01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重新格式化检索出的数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> VendorLocations <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> RTRIM(vend_name) <span class="operator">+</span> <span class="string">&#x27; (&#x27;</span> <span class="operator">+</span> RTRIM(vend_country) <span class="operator">+</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"><span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> Vendors;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用视图过滤不想要的数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> CustomerEMailList <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name, cust_email</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用视图与计算字段</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> OrderItemsExpanded <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num,</span><br><span class="line">       prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">   item_price,</span><br><span class="line">       quantity<span class="operator">*</span>item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> OrderItems;</span><br></pre></td></tr></table></figure><h1>使用存储过程 - <code>EXECUTE</code></h1><ul><li>存储过程就是为以后使用而保存的一条或多条 SQL 语句。可将其视为批文件，虽然它们的作用不仅限于批处理</li><li>为什么要使用存储过程：简单、安全、高性能<ul><li>通过把处理封装在一个易用的单元中，可以简化复杂的操作</li><li>由于不要求反复建立一系列处理步骤，因而保证了数据的一致性</li><li>简化对变动的管理</li><li>因为存储过程通常以编译过的形式存储，所以 DBMS 处理命令所需的工作量少，提高了性能</li><li>存在一些只能用在单个请求中的 SQL 元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码</li></ul></li><li>执行存储过程：<code>EXECUTE</code></li><li>创建存储过程：<code>CREATE</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> AddNewProduct( <span class="string">&#x27;JTS01&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;Stuffed Eiffel Tower&#x27;</span>,</span><br><span class="line">   <span class="number">6.49</span>,</span><br><span class="line">   <span class="string">&#x27;Plush stuffed toy&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对邮件发送清单中具有邮件地址的顾客进行计数</span></span><br><span class="line"><span class="comment">-- Oracle 版本</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> MailingListCount (</span><br><span class="line">ListCount <span class="keyword">OUT</span> <span class="type">INTEGER</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">IS</span></span><br><span class="line">v_rows <span class="type">INTEGER</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> v_rows</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> cust_email <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line">ListCount :<span class="operator">=</span> v_rows;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用 Oracle 例子</span></span><br><span class="line">var ReturnValue NUMBER</span><br><span class="line"><span class="keyword">EXEC</span> MailingListCount(:ReturnValue);</span><br><span class="line"><span class="keyword">SELECT</span> ReturnValue;</span><br></pre></td></tr></table></figure><h1>管理事务处理 - <code>COMMIT/ROLLBACK</code></h1><ul><li><p>使用事务处理（transaction processing），通过确保成批的SQL 操作要么完全执行，要么完全不执行，来维护数据库的完整性</p></li><li><p>可以保证一组操作不会中途停止，它们要么完全执行，要么完全不执行（除非明确指示）</p></li><li><p>如果没有错误发生，整组语句提交给（写到）数据库表；如果发生错误，则进行回退（撤销），将数据库恢复到某个已知且安全的状态</p></li><li><p>关于事务处理需要知道的几个术语：</p><ul><li>事务（transaction）指一组SQL 语句</li><li>回退（rollback）指撤销指定SQL 语句的过程</li><li>提交（commit）指将未存储的SQL 语句结果写入数据库表</li><li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），可以对它发布回退（与回退整个事务处理不同）。</li></ul></li><li><p>事务处理用来管理 <code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句</p></li><li><p>管理事务的关键在于将SQL 语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退。</p><ul><li><p>有的DBMS 要求明确标识事务处理块的开始和结束：</p><ul><li>SQL Server：<code>BEGIN TRANSACTION</code>   <code>COMMIT TRANSACTION</code></li></ul></li></ul></li><li><p>多数实现没有明确标识事<br>务处理在何处结束。事务一直存在，直到被中断</p><ul><li>MariaDB 和 MySQL：<code>START TRANSACTION</code></li><li>Oracle：<code>SET TRANSACTION</code><ul><li>PostgreSQL：<code>BEGIN</code></li></ul></li><li>通常，<code>COMMIT</code> 用于<br>保存更改，<code>ROLLBACK</code> 用于撤销</li></ul></li><li><p>要支持回退部分事务，必须在事务处理块中的合适位置放置占位符。在 SQL 中，这些占位符称为<strong>保留点</strong></p><ul><li>MariaDB、MySQL 和 Oracle：<code>SAVEPOINT</code></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 执行 DELETE 操作，然后用 ROLLBACK 语句撤销</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Orders;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 COMMIT 语句进行明确的提交</span></span><br><span class="line"><span class="comment">-- SQL Server</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION</span><br><span class="line"><span class="keyword">DELETE</span> OrderItems <span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">12345</span></span><br><span class="line"><span class="keyword">DELETE</span> Orders <span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">12345</span></span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION</span><br><span class="line"><span class="comment">-- Oracle</span></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION</span><br><span class="line"><span class="keyword">DELETE</span> OrderItems <span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">12345</span>;</span><br><span class="line"><span class="keyword">DELETE</span> Orders <span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">12345</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建保留点</span></span><br><span class="line"><span class="comment">-- MariaDB、MySQL 和 Oracle</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> delete1;</span><br><span class="line"><span class="comment">-- SQL Server</span></span><br><span class="line">SAVE TRANSACTION delete1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回退到本例给出的保留点</span></span><br><span class="line"><span class="comment">-- MariaDB、MySQL 和 Oracle</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1;</span><br><span class="line"><span class="comment">-- SQL Server</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> TRANSACTION delete1;</span><br></pre></td></tr></table></figure><h1>使用游标 - <code>CURSOR</code></h1><ul><li>结果集（result set）：SQL 查询所检索出的结果</li><li>游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条SELECT 语句，而是被该语句检索出来的结果集，应用程序可以根据需要滚动或浏览其中的数据</li><li>常见的一些选项和特性：<ul><li>能够标记游标为只读，使数据能读取，但不能更新和删除</li><li>能控制可以执行的定向操作（向前、向后、第一、最后、绝对位置、相对位置等）</li><li>能标记某些列为可编辑的，某些列为不可编辑的</li><li>规定范围，使游标对创建它的特定请求（如存储过程）或对所有请求可访问</li><li>指示DBMS 对检索出的数据（而不是指出表中活动数据）进行复制，使数据在游标打开和访问期间不变化</li></ul></li><li>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改</li><li>创建游标：使用 <code>DECLARE</code> 语句创建游标，并定义相应的 <code>SELECT</code> 语句，但不进行查询</li><li>使用游标：使用 <code>OPEN CURSOR</code> 语句打开游标，并执行查询</li><li>访问游标：使用 <code>FETCH</code> 语句访问游标数据，指出要检索哪些行，从何处检索它们以及将它们放于何处、</li><li>关闭游标：使用 <code>CLOSE</code> 语句关闭游标</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建游标, 找出空缺的电子邮件地址</span></span><br><span class="line"><span class="comment">-- DB2、MariaDB、MySQL 和 SQL Server</span></span><br><span class="line"><span class="keyword">DECLARE</span> CustCursor <span class="keyword">CURSOR</span></span><br><span class="line"><span class="keyword">FOR</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="comment">-- Oracle 和PostgreSQL</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">CURSOR</span> CustCursor</span><br><span class="line"><span class="keyword">IS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_email <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 打开游标, 此时开始执行查询</span></span><br><span class="line"><span class="keyword">OPEN</span> <span class="keyword">CURSOR</span> CustCursor</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 访问游标，检索第一行</span></span><br><span class="line"><span class="comment">-- Oracle</span></span><br><span class="line"><span class="keyword">DECLARE</span> TYPE CustCursor <span class="keyword">IS</span> <span class="keyword">REF</span> <span class="keyword">CURSOR</span></span><br><span class="line"><span class="keyword">RETURN</span> Customers<span class="operator">%</span>ROWTYPE;</span><br><span class="line"><span class="keyword">DECLARE</span> CustRecord Customers<span class="operator">%</span>ROWTYPE</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">OPEN</span> CustCursor;</span><br><span class="line"><span class="keyword">FETCH</span> CustCursor <span class="keyword">INTO</span> CustRecord;</span><br><span class="line"><span class="keyword">CLOSE</span> CustCursor;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭游标</span></span><br><span class="line"><span class="comment">-- DB2、Oracle 和 PostgreSQL</span></span><br><span class="line"><span class="keyword">CLOSE</span> CustCursor</span><br><span class="line"><span class="comment">-- Microsoft SQL Server</span></span><br><span class="line"><span class="keyword">CLOSE</span> CustCursor</span><br><span class="line"><span class="keyword">DEALLOCATE</span> <span class="keyword">CURSOR</span> CustCursor</span><br></pre></td></tr></table></figure><h1>高级SQL 特性</h1><h2 id="约束">约束</h2><ul><li>管理如何插入或处理数据库数据的规则</li><li>主键：一种特殊的约束，用来保证一列（或一组列）中的值是唯一的，而且永不改动<ul><li>主键值唯一且不为 <code>NULL</code>，从不修改和更新，不能重用</li><li>定义主键的方法：<code>PRIMARY KEY</code></li></ul></li><li>外键：是表中的一列，其值必须列在另一表的主键中<ul><li>定义外键的方法：<code>REFERENCES</code></li><li>在定义外键后，DBMS 不允许删除在另一个表中具有关联行的行</li><li>级联删除：从一个表中删除行时删除所有相关的数据</li></ul></li><li>唯一约束：用来保证一列（或一组列）中的数据是唯一的<ul><li>类似于主键，但存在以下重要区别：<ul><li>表可包含多个唯一约束，但每个表只允许一个主键</li><li>唯一约束列可包含 <code>NULL</code> 值</li><li>唯一约束列可修改或更新</li><li>唯一约束列的值可重复使用</li><li>与主键不一样，唯一约束不能用来定义外键</li></ul></li><li>使用 <code>UNIQUE</code> 关键字定义，也可以用单独的 <code>CONSTRAINT</code> 定义</li></ul></li><li>检查约束：保证一列（或一组列）中的数据满足一组指定的条件<ul><li>检查最小或最大值、指定范围、只允许特定的值</li><li>使用 <code>CHECK</code> 关键词定义</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给表的 vend_id 列定义添加关键字 PRIMARY KEY，使其成为主键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Vendors</span><br><span class="line">(</span><br><span class="line">    vend_id <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    vend_name <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    vend_address <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">    vend_country <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 使用的是 CONSTRAINT 语法</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Vendors</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> <span class="keyword">PRIMARY</span> KEY (vend_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- cust_id 中的任何值都必须是 Customers 表的 cust_id 中的值</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">    order_num <span class="type">INTEGER</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    order_date DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    cust_id <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">REFERENCES</span></span><br><span class="line">    ➥Customers(cust_id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 在 ALTER TABLE 语句中用 CONSTRAINT 语法来完成</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span></span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (cust_id) <span class="keyword">REFERENCES</span> Customers (cust_id)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> OrderItems</span><br><span class="line">(</span><br><span class="line">    order_num <span class="type">INTEGER</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    order_item <span class="type">INTEGER</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    prod_id <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    quantity <span class="type">INTEGER</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">CHECK</span> (quantity <span class="operator">&gt;</span> <span class="number">0</span>),</span><br><span class="line">    item_price MONEY <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 使用 CONSTRAINT 语法</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Customers</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> <span class="keyword">CHECK</span> (gender <span class="keyword">LIKE</span> <span class="string">&#x27;[MF]&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="索引-2">索引</h2><ul><li>索引用来排序数据以加快搜索和排序操作的速度<ul><li>主键数据总是排序的，按主键检索特定行总是一种快速有效的操作</li><li>搜索其他列中的值通常效率不高，解决方法是使用索引</li><li>可以在一个或多个列上定义索引，使 DBMS 保存其内容的一个排过序的列表</li></ul></li><li>索引改善检索操作的性能，但降低了数据插入、修改和删除的性能</li><li>索引用 <code>CREATE INDEX</code> 语句创建，必须唯一命名</li><li>可能要占用大量的存储空间，并非所有数据都适合做索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX prod_name_ind</span><br><span class="line"><span class="keyword">ON</span> Products (prod_name);</span><br></pre></td></tr></table></figure><h2 id="触发器">触发器</h2><ul><li>触发器（<code>TRIGGER</code>）是特殊的存储过程，它在特定的数据库活动发生时自动执行</li><li>触发器可以与特定表上的 <code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 操作相关联</li><li>触发器内的代码具有以下数据的访问权：<ul><li><code>INSERT</code> 操作中的所有新数据</li><li><code>UPDATE</code> 操作中的所有新数据和旧数据</li><li><code>DELETE</code> 操作中删除的数据</li></ul></li><li>触发器的一些常见用途<ul><li>保证数据一致</li><li>基于某个表的变动在其他表上执行活动</li><li>进行额外的验证并根据需要回退数据</li><li>计算计算列的值或更新时间戳</li></ul></li><li>约束的处理比触发器快，因此在可能的时候，应该尽量使用约束</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对所有 INSERT 和 UPDATE 操作</span></span><br><span class="line"><span class="comment">-- 将 Customers 表中的 cust_state 列转换为大写。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> customer_state</span><br><span class="line"><span class="keyword">ON</span> Customers</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">UPDATE</span> Customers</span><br><span class="line"><span class="keyword">SET</span> cust_state <span class="operator">=</span> <span class="built_in">Upper</span>(cust_state)</span><br><span class="line"><span class="keyword">WHERE</span> Customers.cust_id <span class="operator">=</span> inserted.cust_id;</span><br></pre></td></tr></table></figure><h2 id="数据库安全">数据库安全</h2><ul><li>大多数 DBMS 都给管理员提供了管理机制，利用管理机制授予或限制对数据的访问</li><li>安全性使用 SQL 的 <code>GRANT</code> 和 <code>REVOKE</code> 语句来管理</li></ul><hr><blockquote><p>SQL 必知必会 - 全书目录</p><ol><li>第 01 - 10 章：<a href="/p/57d19b2c">SQL 必知必会 - 单表查询/过滤/汇总</a></li><li>第 11 - 24 章：<a href="/p/4c50c6b4">SQL 必知必会 - 多表查询/联结/组合</a></li><li>第 15 - 24 章：<a href="/p/3b57f622">SQL 必知必会 - 数据更新/存储/事务</a></li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;SQL 必知必会 - 全书目录&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第 01 - 10 章：&lt;a href=&quot;/p/57d19b2c&quot;&gt;SQL 必知必会 - 单表查询/过滤/汇总&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;第 11 - 24 章：&lt;a href=&quot;/p/4c50c6b4&quot;&gt;SQL 必知必会 - 多表查询/联结/组合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;第 15 - 24 章：&lt;a href=&quot;/p/3b57f622&quot;&gt;SQL 必知必会 - 数据更新/存储/事务&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="SQL" scheme="http://blog.czccc.cc/categories/SQL/"/>
    
    
    <category term="SQL" scheme="http://blog.czccc.cc/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Rust 中的错误处理</title>
    <link href="http://blog.czccc.cc/p/d02431de/"/>
    <id>http://blog.czccc.cc/p/d02431de/</id>
    <published>2020-08-03T01:35:41.000Z</published>
    <updated>2022-08-06T13:07:33.621Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>原文地址：<a target="_blank" rel="noopener" href="https://blog.burntsushi.net/rust-error-handling/">https://blog.burntsushi.net/rust-error-handling/</a></p><p>原文标题：Error Handling in Rust</p><p>原文作者：<a target="_blank" rel="noopener" href="https://blog.burntsushi.net/">Andrew Gallant’s Blog</a></p><p>翻译日期：2020/08/03</p></blockquote><span id="more"></span><h1>Rust 中的错误处理</h1><p>与大多数编程语言一样，Rust 鼓励程序员以特定方式处理错误。一般而言，错误处理分为两大类：<strong>异常</strong>和<strong>返回值</strong>。Rust选择<strong>使用返回值</strong>进行错误处理。</p><p>在本文中，我尝试对 Rust 中如何进行错误处理提供全面的说明。并且，我将尝试一次引入一个错误处理的方法，并帮助你获得扎实的实践知识，即如何整合所有内容。</p><p>如果没有良好的实现方式，Rust 中的错误处理可能会很冗长并繁琐。本文将探讨这些问题，并展示如何<strong>使用标准库</strong>使错误处理变得简明，并符合工程习惯。</p><p><strong>目标受众</strong>：尚不明确 Rust 错误处理用法的新手。熟悉 Rust 语法会更好。（本文使用了许多标准库 trait，但很少使用闭包和宏。）</p><p><strong>更新（2018/04/14）</strong>：示例已转换为使用 <code>?</code> 进行处理，并添加了一些文本以提供更改的背景。</p><p><strong>更新（2020/01/03）</strong>：删除了 <a target="_blank" rel="noopener" href="https://crates.io/crates/failure"><code>failure</code></a> 的使用建议， 并替换为建议使用 <code>Box&lt;Error + Send + Sync&gt;</code> 或 <a target="_blank" rel="noopener" href="https://crates.io/crates/anyhow"><code>anyhow</code></a>。</p><h2 id="简要说明-2">简要说明</h2><p>文中的代码示例均通过 Rust <code>1.0.0-beta.5</code> 进行编译。随着 Rust 1.0 稳定版的发布，他们应该同样可以运行。</p><p>所有的代码都可以在作者的<a target="_blank" rel="noopener" href="https://github.com/BurntSushi/blog/tree/master/code/rust-error-handling">博客仓库</a>中找到并编译。</p><p><a target="_blank" rel="noopener" href="http://doc.rust-lang.org/1.0.0-beta.5/book/">Rust Book</a> 中有一节 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/1.0.0-beta.5/book/error-handling.html">section on error handling</a>。它提供了非常简短的概述，但是（还）没有介绍得足够详细，尤其是在使用标准库的一些最新内容时。</p><blockquote><p>译者注：最新版的 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/title-page.html">Rust Book</a> 已经更新了许多内容，建议阅读<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">新版的错误处理章节</a>。</p><p><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/title-page.html">简体中文版地址</a>, <a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch09-00-error-handling.html">错误处理章节</a>。</p></blockquote><h2 id="运行代码">运行代码</h2><p>读者如果想要运行本文中的代码示例，可以使用下面的方法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://github.com/BurntSushi/blog</span><br><span class="line">$ <span class="built_in">cd</span> blog/code/rust-error-handling</span><br><span class="line">$ cargo run --bin NAME-OF-CODE-SAMPLE [ args ... ]</span><br></pre></td></tr></table></figure><p>每个代码示例有其名称。（没有命名的代码不能按照这种方式运行。）</p><h2 id="说明">说明</h2><p>本文很长，主要是因为我从一开始就使用多种错误类型及其组合，并尝试使用 Rust 逐步进行错误处理。因此，在其他显式类型系统中有经验的程序员可能想快速跳转本文。这是一些简短指南：</p><ul><li>如果你不熟悉 Rust，系统编程和显式类型系统，那么请从头开始并逐步进行。（如果你是全新用户，则可能应该先通读 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/title-page.html">Rust Book</a>。）</li><li>如果你以前从未看过 Rust，但是有过使用函数式语言的经验（对“代数数据类型”和“组合器”感到熟悉），那么你可以跳过基础知识，而先略读<a href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B">多种错误类型</a>，然后仔细阅读 <a href="#%E7%94%A8%E4%BA%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93-traits">标准库错误特征</a>。（如果你以前从未真正看过Rust，略读<a href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识</a>可能是一个不错的主意。）你可能需要查询 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/title-page.html">Rust Book</a>，以获取有关 Rust 闭包和宏的帮助。</li><li>如果你已经对 Rust 有所了解，并且只想学习如何对错误进行处理，那么你可以直接跳到<a href="#%E6%A6%82%E6%8B%AC">最后</a>。略读<a href="#%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0-%E8%AF%BB%E5%8F%96%E4%BA%BA%E5%8F%A3%E6%95%B0%E6%8D%AE">模式匹配</a>可能会比较有用。</li></ul><hr><h1>基础知识</h1><p>我喜欢将错误处理变为使用<strong>模式匹配</strong>来判断一个计算任务是否成功。正如我们将要看到的，工程上错误处理的关键是保持代码可组合性的同时，<strong>减少显式模式匹配的数目</strong>。</p><p>保持代码的可组合性很重要，因为如果没有此要求，我们可以在遇到意外情况时直接进行 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic</code></a> 操作。（<code>panic</code> 导致当前任务结束，并且在大多数情况下，整个程序都将中止。）这是一个示例：</p><figure class="highlight rust"><figcaption><span>panic-simple</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Guess a number between 1 and 10.</span></span><br><span class="line"><span class="comment">// If it matches the number I had in mind, return true. Else, return false.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">guess</span>(n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span> || n &gt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;Invalid number: &#123;&#125;&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    n == <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">guess</span>(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果你想要运行此代码，查看 <a href="#%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81">运行代码</a> 一章。</p></blockquote><p>如果你尝试运行此代码，程序将会中止，并报告错误信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="string">&#x27;&lt;main&gt;&#x27;</span> panicked at <span class="string">&#x27;Invalid number: 11&#x27;</span>, src/bin/panic-simple.rs:5</span><br></pre></td></tr></table></figure><p>这是另外一个例子。程序接收一个整数作为参数，将其乘 2 并打印出来。</p><figure class="highlight rust"><figcaption><span>unwrap-double</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">argv</span> = env::<span class="title function_ invoke__">args</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arg</span>: <span class="type">String</span> = argv.<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// error 1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = arg.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// error 2</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="number">2</span> * n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $ cargo run --bin unwrap-double 5</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>如果你没有给程序传递参数 (error 1) 或者第一个参数不是整数 (error 2)，程序会像第一个例子一样中止。</p><p>我认为这种错误处理方式就像是<em>在中国商店中奔跑的公牛</em>。公牛会到达它想去的地方，但是会践踏过程中的一切。</p><h2 id="Unwrapping-说明">Unwrapping 说明</h2><p>在上面的例子里 (<code>unwrap-double</code>)，我声称：如果程序满足两个错误条件之一，该程序将中止。但是，程序中并未像第一个示例（<code>panic-simple</code>）那样包含显式调用 <code>panic</code> 。这是因为 <code>panic</code> 嵌入在对 <code>unwrap</code> 的调用中。</p><p>要 “<code>unwrap</code>” Rust 中的某些内容，也就意味着：“给我计算的结果，并且如果有错误，请立即调用 <code>panic</code> 并中止程序。” 如果我直接展示用于 unwrapping 的代码可能会帮助你理解这一点，因为它十分简单。但是要做到这一点，我们首先需要探讨 <code>Option</code> 和 <code>Result</code> 类型。这两种类型在其上都有一个称为 <code>unwrap</code> 的方法。</p><h2 id="Option-类型"><code>Option</code> 类型</h2><p><code>Option</code> 类型定义在 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html">标准库</a> 中：</p><figure class="highlight rust"><figcaption><span>option-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Option</code> 类型在 Rust 中主要适用于表示<strong>不存在的可能性</strong>。将<strong>不存在的可能性</strong>编码到类型系统中是一个很重要的概念，因为它可以通过编译器去强制程序员处理这样的<strong>不存在的情况</strong>。让我们看一个例子，它在字符串中尝试查找一个字符：</p><figure class="highlight rust"><figcaption><span>option-ex-string-find</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Searches `haystack` for the Unicode character `needle`. If one is found, the</span></span><br><span class="line"><span class="comment">// byte offset of the character is returned. Otherwise, `None` is returned.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find</span>(haystack: &amp;<span class="type">str</span>, needle: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">usize</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">for</span> (offset, c) <span class="keyword">in</span> haystack.<span class="title function_ invoke__">char_indices</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> c == needle &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（Pro-tip：请勿使用此代码。请使用标准库中的 <code>find</code> 方法。）</p><p>注意到当函数找到一个匹配的字符时，它并不直接返回 <code>offset</code>，而是返回 <code>Some(offset)</code>。<code>Some</code> 是 <code>Option</code> 中的一个变体，或者说是一个值构造（value constructor）函数。你可以将其认为是一个函数：<code>fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;</code>。相应的， <code>None</code> 也是一个值构造（value constructor）函数,只不过它没有参数。你可以将 <code>None</code> 认为是一个函数： <code>fn&lt;T&gt;() -&gt; Option&lt;T&gt;</code>。</p><p>这看起来很简单，但这只是程序的一半，另一半是使用我们编写的函数 <code>find</code>。让我们尝试使用它在文件名中查找扩展名：</p><figure class="highlight rust"><figcaption><span>option-ex-string-find</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main_find</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_name</span> = <span class="string">&quot;foobar.rs&quot;</span>;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">find</span>(file_name, <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;No file extension found.&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;File extension: &#123;&#125;&quot;</span>, &amp;file_name[i+<span class="number">1</span>..]),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码对 <code>find</code> 返回的 <code>Option&lt;usize&gt;</code> 进行<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch06-00-enums.html"><strong>模式匹配</strong></a>，实际上，模式匹配是获取存储在<code>Option&lt;T&gt;</code>中的值的<strong>唯一方法</strong>。这意味着作为程序员的你，<strong>必须</strong>处理当 <code>Option&lt;T&gt;</code> 是 <code>None</code> 的情况，而不仅仅是 <code>Some(t)</code>。</p><p>但是等等，那么在 <code>unwrap-double</code> 中使用的 <code>unwrap</code> 是什么情况呢？那里没有模式匹配！这是因为它将模式匹配嵌入到 <code>unwrap</code> 方法中。你可以根据需要自己定义 <code>unwrap</code> 方法：</p><figure class="highlight rust"><figcaption><span>option-def-unwrap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">unwrap</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Option::<span class="title function_ invoke__">Some</span>(val) =&gt; val,</span><br><span class="line">            Option::<span class="literal">None</span> =&gt;</span><br><span class="line">              <span class="built_in">panic!</span>(<span class="string">&quot;called `Option::unwrap()` on a `None` value&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>unwrap</code> 方法中抽象出模式匹配，正是工程中使用 <code>unwrap</code> 的方式。然而，<code>unwrap</code> 中的 <code>panic!</code> 仍然意味着这个 <code>unwrap</code> 是不可组合的：<em>这是中国商店里的公牛</em>。</p><h3 id="组合-Option-T">组合 <code>Option&lt;T&gt;</code></h3><p>在 <code>option-ex-string-find</code> 其中，我们看到如何使用<code>find</code>来查找文件名中的扩展名。但是，并非所有文件名都带有 <code>.</code>，因此文件名<em>可能没有扩展名</em>。我们将这种<strong>不存在的可能性</strong>编码为类型 <code>Option&lt;T&gt;</code>。换句话说，编译器将迫使我们处理扩展不存在的可能性。就我们而言，我们只是打印出一条错误消息。</p><p>获取文件扩展名是很常见的操作，因此可以将其放入函数中：</p><figure class="highlight rust"><figcaption><span>option-ex-string-find</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the extension of the given file name, where the extension is defined</span></span><br><span class="line"><span class="comment">// as all characters succeeding the first `.`.</span></span><br><span class="line"><span class="comment">// If `file_name` has no `.`, then `None` is returned.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">extension_explicit</span>(file_name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">find</span>(file_name, <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(&amp;file_name[i+<span class="number">1</span>..]),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（Pro-tip：请勿使用此代码。请使用标准库中的 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/path/struct.Path.html#method.extension"><code>extension</code></a> 方法。）</p><p>上面的代码仍然很简单，但需要注意的一点是，<code>find</code> 强制我们考虑不存在的可能性。这种情况的好处在于：编译器不会让我们意外忘记文件名没有扩展名的情况。另一方面，像 <code>extension_explicit</code> 函数所实现的那样，进行显式的模式匹配可能会有点繁琐。</p><p>实际上，<code>extension_explicit</code> 中的模式匹配遵循一种非常常见的模式：将函数映射到 <code>Option&lt;T&gt;</code> 内部的值，如果该 <code>Option</code> 为 <code>None</code>，只需返回 <code>None</code> 即可。</p><p>Rust 具有参数多态性，因此定义抽象该模式的组合器非常容易：</p><figure class="highlight rust"><figcaption><span>option-map</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">map</span>&lt;F, T, A&gt;(option: <span class="type">Option</span>&lt;T&gt;, f: F) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;A&gt; <span class="keyword">where</span> F: <span class="title function_ invoke__">FnOnce</span>(T) <span class="punctuation">-&gt;</span> A &#123;</span><br><span class="line">    <span class="keyword">match</span> option &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(value) =&gt; <span class="title function_ invoke__">Some</span>(<span class="title function_ invoke__">f</span>(value)),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，<code>map</code> 在标准库中被定义为 <code>Option&lt;T&gt;</code> 上的一种<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map">方法</a>。</p><p>有了新的组合器，我们可以重写 <code>extension_explicit</code> 方法以去除模式匹配：</p><figure class="highlight rust"><figcaption><span>option-ex-string-find</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the extension of the given file name, where the extension is defined</span></span><br><span class="line"><span class="comment">// as all characters succeeding the first `.`.</span></span><br><span class="line"><span class="comment">// If `file_name` has no `.`, then `None` is returned.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">extension</span>(file_name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">find</span>(file_name, <span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">map</span>(|i| &amp;file_name[i+<span class="number">1</span>..])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种很常见的模式是，当 <code>Option</code> 值为 <code>None</code> 时，为其<strong>分配一个默认值</strong>。例如，你的程序假定：即使文件扩展名不存在，文件的扩展名也是 <code>rs</code>。同样的，对此情况的模式匹配并不特定于文件扩展名。使用 <code>Option&lt;T&gt;</code> 也可以实现它：</p><figure class="highlight rust"><figcaption><span>option-unwrap-or</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">unwrap_or</span>&lt;T&gt;(option: <span class="type">Option</span>&lt;T&gt;, default: T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">match</span> option &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; default,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(value) =&gt; value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的要求是，默认值必须与 <code>Option&lt;T&gt;</code> 内的值具有相同的类型。在我们的例子里，使用它非常简单：</p><figure class="highlight rust"><figcaption><span>option-ex-string-find</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">extension</span>(<span class="string">&quot;foobar.csv&quot;</span>).<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;rs&quot;</span>), <span class="string">&quot;csv&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">extension</span>(<span class="string">&quot;foobar&quot;</span>).<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;rs&quot;</span>), <span class="string">&quot;rs&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（请注意，<code>unwrap_or</code> 在标准库中是定义在 <code>Option&lt;T&gt;</code> 上的一种<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or">方法</a>，所以我们在这里用的并不是我们在上面自己定义的函数。记得查找更通用的 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code> 方法</a>。）</p><p>我认为还有一种组合器值得特别注意：<code>and_then</code>。它使组合不同的计算变得更容易，这些计算都会处理不存在的可能性。例如，本节中的许多代码都是关于查找给定文件名的扩展名。为此，你首先需要从文件路径中提取出文件名。尽管大多数文件路径都具有文件名，但并非所有都具有，例如<code>.</code>，<code>..</code>或 <code>/</code>。</p><p>因此，我们面临的挑战是查找给定文件路径下所有文件的扩展名 。让我们从显式模式匹配开始：</p><figure class="highlight rust"><figcaption><span>option-ex-string-find</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">file_path_ext_explicit</span>(file_path: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">file_name</span>(file_path) &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(name) =&gt; <span class="keyword">match</span> <span class="title function_ invoke__">extension</span>(name) &#123;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(ext) =&gt; <span class="title function_ invoke__">Some</span>(ext),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_name</span>(file_path: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// implementation elided</span></span><br><span class="line">  <span class="built_in">unimplemented!</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会认为我们可以只使用 <code>map</code> 组合器来减少模式匹配，但是它的类型不太合适。即，<code>map</code> 采用仅对内部值执行某些操作的函数。然后，总是用 <code>Some</code> 来包装该函数的结果。但是，我们需要类似于 <code>map</code>，但允许调用者返回其他的 <code>Option</code>。它的通用实现甚至比 <code>map</code> 更简单：</p><figure class="highlight rust"><figcaption><span>option-and-then</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">and_then</span>&lt;F, T, A&gt;(option: <span class="type">Option</span>&lt;T&gt;, f: F) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;A&gt;</span><br><span class="line">        <span class="keyword">where</span> F: <span class="title function_ invoke__">FnOnce</span>(T) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;A&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> option &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(value) =&gt; <span class="title function_ invoke__">f</span>(value),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以重写 <code>file_path_ext</code> 函数，而无需进行显式的模式匹配：</p><figure class="highlight rust"><figcaption><span>option-ex-string-find</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">file_path_ext</span>(file_path: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">file_name</span>(file_path).<span class="title function_ invoke__">and_then</span>(extension)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Option</code> 类型在<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html">标准库</a>中定义了许多其他组合器。建议浏览此文档并熟悉其可用的内容，它们通常可以为你减少模式匹配。熟悉这些组合器会很有帮助，并且它们中大多也为 <code>Result</code> 定义了相似的语义，我们将在下面讨论。</p><p>组合使用 <code>Option</code> 类型是个比较符合工程学的实现，因为它们减少了显式的模式匹配。它们仍然是可组合的，因为它们允许调用者以自己的方式处理不存在的可能性。类似于 <code>unwrap</code> 的方法移除了这种可能性，因为他们在 <code>Option&lt;T&gt;</code> 是 <code>None</code> 会中止程序运行。</p><h2 id="Result-类型"><code>Result</code> 类型</h2><p><code>Result</code> 类型也定义在<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/">标准库</a>中：</p><figure class="highlight rust"><figcaption><span>result-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Result</code> 类型是更丰富版的 <code>Option</code>。也就是说，不同于像 <code>Option</code> 那样表示<strong>不存在的可能性</strong>，<code>Result</code>表示的是<strong>出现错误的可能性</strong>。通常，错误用于解释为什么某些计算结果会失败。这是更严格的 <code>Option</code> 的通用形式。请考虑以下类型别名，该别名在各个方面的语义上均等同于实际的 <code>Option&lt;T&gt;</code> ：</p><figure class="highlight rust"><figcaption><span>option-as-result</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Option</span>&lt;T&gt; = <span class="type">Result</span>&lt;T, ()&gt;;</span><br></pre></td></tr></table></figure><p>这将 <code>Result</code> 的第二个参数类型始终固定为 <code>()</code>（发音为 “unit” 或 “empty tuple”）。并且也只定义在 <code>()</code> 类型中。（<code>()</code> 类型和值这两个级别的术语具有相同的符号！）</p><p><code>Result</code> 类型是表示计算中两个可能结果之一的方式。按照惯例，一个结果是预期正确的结果即“<code>Ok</code>”，而另一个结果是不预期的错误即“<code>Err</code>”。</p><p>就像 <code>Option</code> 一样，<code>Result</code> 类型也具有在标准库中定义的 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>unwrap</code></a> 方法。让我们自己定义一下：</p><figure class="highlight rust"><figcaption><span>result-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T, E: ::std::fmt::<span class="built_in">Debug</span>&gt; <span class="type">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">unwrap</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Result::<span class="title function_ invoke__">Ok</span>(val) =&gt; val,</span><br><span class="line">            Result::<span class="title function_ invoke__">Err</span>(err) =&gt;</span><br><span class="line">              <span class="built_in">panic!</span>(<span class="string">&quot;called `Result::unwrap()` on an `Err` value: &#123;:?&#125;&quot;</span>, err),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上与我们对 <code>Option::unwrap</code> 的定义相类似，只不过它在 <code>panic!</code> 消息中返回错误值。这使调试程序更加容易，但还需要我们在 <code>E</code> 类型参数（代表我们的错误类型）上添加 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> 约束。由于绝大多数类型都应满足 <code>Debug</code> 约束条件，因此这在实践中很容易解决。（类型上的 <code>Debug</code> 只是意味着有一种合理的方式来以人类可读的形式打印该类型的值。）</p><p>好的，让我们继续下一个例子。</p><h3 id="解析整数">解析整数</h3><p>Rust 标准库使将字符串转换为整数十分容易。实际上也是如此，编写如下内容非常简单：</p><figure class="highlight rust"><figcaption><span>result-num-unwrap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">double_number</span>(number_str: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="number">2</span> * number_str.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = <span class="title function_ invoke__">double_number</span>(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(n, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此时，你应该对调用 <code>unwrap</code> 表示警惕。例如，如果字符串未解析为数字，则会出现 <code>panic</code>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;&lt;main&gt;&#x27; panicked at &#x27;called `Result::unwrap()` on an `Err` value: ParseIntError &#123; kind: InvalidDigit &#125;&#x27;, /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729</span><br></pre></td></tr></table></figure><p>这是相当不直观的，如果这种情况发生在你正在使用的库函数中，你可能会感到很烦恼。因此，我们应该尝试处理函数中的错误，并让调用者决定如何处理。这意味着更改 <code>double_number</code> 的返回类型。但是要怎么做呢？让我们查看标准库中 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse</code> 方法</a>的定义 ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">str</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">parse</span>&lt;F: FromStr&gt;(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;F, F::<span class="literal">Err</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯… 所以我们至少知道需要使用 <code>Result</code>。当然，返回 <code>Option</code> 也是可取的。毕竟，字符串要么解析为数字，要么不是数字。虽然这是一种合理的方法，但是使用 <code>Result</code> 可以从内部区分为什么字符串没有解析为整数。（无论它是一个空字符串，一个无效数字，数字太大还是太小。）因此，使用 <code>Result</code> 更有意义，因为我们希望提供的信息不仅仅是简单的“不存在”，我们想说明为什么解析会失败。当遇到 <code>Option</code> 和 <code>Result</code> 之间的选择时，你应该尝试效仿这样的推理。如果你可以提供详细的错误信息，那么你就应该这样做。（我们将在稍后看到更多信息。）</p><p>好的，但是我们如何编写返回类型？上面定义的 <code>parse</code> 方法在标准库中所有不同的数字类型上都是通用的。我们可以（并且应该）使函数也如此通用，不过现在让我们首先仅支持显式定义类型。我们只关心 <code>i32</code>，因此我们需要找到它的 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.i32.html"><code>FromStr</code> 实现</a>并查看其<a target="_blank" rel="noopener" href="http://doc.rust-lang.org/1.0.0-beta.5/book/associated-types.html">关联类型 <code>Err</code></a>。这么做是为了找到具体的错误类型，在此情况下为 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a>。然后，我们可以重写函数：</p><figure class="highlight rust"><figcaption><span>result-num-no-unwrap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">double_number</span>(number_str: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> number_str.parse::&lt;<span class="type">i32</span>&gt;() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="title function_ invoke__">Err</span>(err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">double_number</span>(<span class="string">&quot;10&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">assert_eq!</span>(n, <span class="number">20</span>),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;:?&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这看起来好了一些，但是现在代码行数更多了！模式匹配再次使我们感到繁琐。</p><p>因此可以<strong>使用组合器</strong>来帮助我们！就像 <code>Option</code> 一样，<code>Result</code> 有很多定义为方法的组合器。<code>Result</code> 和 <code>Option</code> 在公共的组合器上有很大的交集。特别的，<code>map</code> 便是该交集的一部分：</p><figure class="highlight rust"><figcaption><span>result-num-no-unwrap-map</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">double_number</span>(number_str: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    number_str.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map</span>(|n| <span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">double_number</span>(<span class="string">&quot;10&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">assert_eq!</span>(n, <span class="number">20</span>),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;:?&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常使用的组合器在 <code>Result</code> 中都有，包括 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or"><code>unwrap_or</code></a> 和 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then"><code>and_then</code></a>。此外，由于 <code>Result</code> 具有第二种类型的参数，因此有一些组合器仅使用错误类型，例如 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>map_err</code></a>（类似于 <code>map</code>）和 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/result/enum.Result.html#method.or_else"><code>or_else</code></a> （类似于 <code>and_then</code>）。</p><h3 id="Result-类型别名"><code>Result</code> 类型别名</h3><p>在标准库中，你可能经常看到类似 <code>Result&lt;i32&gt;</code> 的类型。但是，在 <code>Result</code> 中定义了两个类型参数，我们如何只指定一个就可以使用呢？答案是定义一个 <code>Result</code> 类型别名，在其中固定类型参数中的一个特定类型。通常，固定类型是错误类型。例如，我们前面的解析整数的示例可以这样重写：</p><figure class="highlight rust"><figcaption><span>result-num-no-unwrap-map-alias</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::num::ParseIntError;</span><br><span class="line"><span class="keyword">use</span> std::result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span>&lt;T&gt; = result::<span class="type">Result</span>&lt;T, ParseIntError&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">double_number</span>(number_str: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="built_in">unimplemented!</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要这样做？因为如果我们有很多需要返回 <code>ParseIntError</code> 的函数，那么定义一个始终使用 <code>ParseIntError</code> 的别名要方便得多，这样我们就不必一直重复它。</p><p>这个习惯用法在标准库中最常见的地方是 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>。通常情况下，这样编写<code>io::Result&lt;T&gt;</code> 就可以清楚地表明你使用的是 <code>io</code> 模块的类型别名，而不是使用的普通定义 <code>std::result</code>。（此习惯用法也用于 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/fmt/type.Result.html"><code>fmt::Result</code></a>。）</p><h2 id="小插曲：unwrapping-并非不能使用的">小插曲：unwrapping 并非不能使用的</h2><p>如果你一直在阅读本文，你可能已经注意到，我采取了相当严格的措施来禁止调用 <code>unwrap</code> 导致程序中止 <code>panic</code> 的方法。一般来说，这是一个很好的建议。</p><p>但是，<code>unwrap</code> 仍然是可以使用。确切地说，使用 <code>unwrap</code> 是一个灰色地带，部分人并不建议使用。我总结了我对此事的一些<strong>看法</strong>。</p><ul><li>**在代码示例和简短的程序中。**有时你正在编写示例或简短的程序，而错误处理并不重要。在这种情况下使用 <code>unwrap</code> 非常方便。</li><li>**在程序中止时表示程序中有错误。**当程序应防止发生某种情况时（例如，从空堆栈中弹出），则可以允许中止。因为它暴露了程序中的错误，这既可能是明确的，例如 <code>assert!</code> 失败，也可能是因为你对数组的索引超出范围。</li></ul><p>这可能并不是详尽的说明。此外，使用 <code>Option</code> 时，通常最好使用其 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>expect</code></a> 方法。除了打印一条给你的消息外，它的用途与 <code>unwrap</code> 完全相同。但它使输出的程序中止问题描述变得友好一些，因为它将显示你的消息，而不是“调用 <code>None</code> 值的 <code>unwrap</code>”。</p><p>我的建议可以归结为：运用你良好的判断力。我的写作中从不出现 “从不做X” 或 “Y被视为有害” 这两个词。在所有方面都有权衡取舍，由程序员在你的用例使用可接受的部分。我的目标只是帮助你尽可能准确地评估权衡。</p><p>既然我们已经介绍了 Rust 中错误处理的基础知识，并且我已经讲过关于 <code>unwrap</code> 的内容，那么让我们开始探索标准库的更多内容。</p><h1>使用多种错误类型</h1><p>到目前为止，我们已经尝试的错误处理都是基于 <code>Option&lt;T&gt;</code> 或 <code>Result&lt;T, SomeError&gt;</code>。但是，当你同时使用 <code>Option</code> 和 <code>Result</code> 时会发生什么？又或者如果有一个 <code>Result&lt;T, Error1&gt;</code> 和一个 <code>Result&lt;T, Error2&gt;</code>？处理<strong>不同错误类型的组合</strong>是摆在我们面前的下一个挑战，它将成为本文其余部分的主题。</p><h2 id="组合-Option-与-Result">组合 <code>Option</code> 与 <code>Result</code></h2><p>到目前为止，我已经讨论了为 <code>Option</code> 定义的组合器和为 <code>Result</code> 定义的组合器。我们可以使用这些组合器来组合不同计算的结果，而无需进行明确的模式匹配。</p><p>但是在实际代码中，事情并不总是那么简单。有时你需要混合使用 <code>Option</code> 和 <code>Result</code> 类型。我们是否必须诉诸明确的模式匹配，还是可以继续使用组合器？</p><p>现在，让我们重新回顾本文中的第一个示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">argv</span> = env::<span class="title function_ invoke__">args</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arg</span>: <span class="type">String</span> = argv.<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// error 1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = arg.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// error 2</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="number">2</span> * n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $ cargo run --bin unwrap-double 5</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>鉴于我们刚学会的 <code>Option</code>，<code>Result</code> 以及它们的各种组合器，我们应该尝试改写这个程序，以让错误得到妥善处理：当没有错误时，程序不应该崩溃。</p><p>这里的棘手问题是 <code>argv.nth(1)</code> 返回一个 <code>Option</code>，而 <code>arg.parse()</code> 返回一个 <code>Result</code>，这些不是可以直接组合的。当同时面对 <code>Option</code> 和 <code>Result</code> 时，解决方案通常<strong>是将 <code>Option</code> 转换为 <code>Result</code></strong>。在我们的示例中，命令行参数如果为空（来自 <code>env::args()</code>）表示用户未正确调用程序。我们可以使用 <code>String</code> 来描述这个错误。我们试试吧：</p><figure class="highlight rust"><figcaption><span>error-double-string</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">double_arg</span>(<span class="keyword">mut</span> argv: env::Args) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    argv.<span class="title function_ invoke__">nth</span>(<span class="number">1</span>)</span><br><span class="line">        .<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;Please give at least one argument&quot;</span>.<span class="title function_ invoke__">to_owned</span>())</span><br><span class="line">        .<span class="title function_ invoke__">and_then</span>(|arg| arg.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map_err</span>(|err| err.<span class="title function_ invoke__">to_string</span>()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">double_arg</span>(env::<span class="title function_ invoke__">args</span>()) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此示例中，有一些新东西。首先是 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or"><code>Option::ok_or</code></a> 组合器的使用。这是将 <code>Option</code> 转换为 <code>Result</code> 的一种方法。转换需要你指定如果 <code>Option</code> 是 <code>None</code>，会使用什么错误。就像我们看到的其他组合器一样，其定义非常简单：</p><figure class="highlight rust"><figcaption><span>option-ok-or-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">ok_or</span>&lt;T, E&gt;(option: <span class="type">Option</span>&lt;T&gt;, err: E) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> option &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(val) =&gt; <span class="title function_ invoke__">Ok</span>(val),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="title function_ invoke__">Err</span>(err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的另一个新的组合器是 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>Result::map_err</code></a>。类似于<code>Result::map</code>，但它将函数映射到<code>Result</code>的<strong>错误</strong>部分上。如果<code>Result</code>是一个<code>Ok(...)</code>值，则将其返回原样。</p><p>我们之所以在这里使用 <code>map_err</code>，是因为错误类型必须保持相同（因为我们使用 <code>and_then</code>）。由于我们选择将 <code>Option&lt;String&gt;</code>（来自于 <code>argv.nth(1)</code>）转换为 <code>Result&lt;String, String&gt;</code>，因此我们还必须将 <code>ParseIntError</code>（来自于 <code>arg.parse()</code>）转换为 <code>String</code>。</p><h2 id="组合器的限制">组合器的限制</h2><p>进行 IO 和解析输入是一项非常常见的任务，这也是我个人在 Rust 中做的比较多的工作。因此，我们将使用 IO 和各种解析例程来举例说明错误处理。</p><p>让我们从一个简单的例子开始。我们的任务是打开文件，读取文件的所有内容并将其内容转换为数字。然后，将其乘以 <code>2</code> 并打印输出。</p><p>尽管我尝试说服你不要使用 <code>unwrap</code>，但是开始编写代码时 <code>unwrap</code> 是很有用的。它使你可以专注于问题而不是错误处理，并且可以揭示需要进行正确错误处理的地方。让我们开始编写第一版程序，然后对其进行重构，以使用更好的错误处理。</p><figure class="highlight rust"><figcaption><span>io-basic-unwrap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(file_path).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// error 1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// error 2</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = contents.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// error 3</span></span><br><span class="line">    <span class="number">2</span> * n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">doubled</span> = <span class="title function_ invoke__">file_double</span>(<span class="string">&quot;foobar&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, doubled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（N.B. 使用 <code>AsRef&lt;Path&gt;</code> 因为它们是使用在 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>std::fs::File::open</code></a> 上的<a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open">相同参数类型</a>。这使得使用任何类型的字符串作为文件路径都符合工程学。）</p><p>这里可能会发生三种不同的错误：</p><ol><li>打开文件时出现问题。</li><li>从文件读取数据时出现问题。</li><li>将数据解析为数字时出现问题。</li></ol><p>前两个问题属于 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/io/struct.Error.html"><code>std::io::Error</code></a> 类型 ，这一点可以从 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>std::fs::File::open</code></a> 和 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>std::io::Read::read_to_string</code></a> 的返回类型中得知 。（请注意，它们都使用前面描述的 <code>Result</code> 类型别名。如果单击 <code>Result</code> 类型，你将看到<a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/io/type.Result.html">类型别名</a>，并因此看到基础的 <code>io::Error</code> 类型。）第三个问题属于 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a> 类型。<code>io::Error</code> 这种类型在整个标准库中的使用非常广泛，你将经常看到它。</p><p>让我们开始重构 <code>file_double</code> 函数。为了使此功能可与程序的其他组件组合，如果满足上述任何错误条件，则不要 <code>panic</code>。实际上，这意味着该函数在任何操作失败时都应<strong>返回错误</strong>。我们的问题是 <code>file_double</code> 的返回类型为 <code>i32</code>，这无法为我们提供任何有用的报告错误的方式。因此，我们必须首先将返回类型从 <code>i32</code> 更改为其他类型。</p><p>我们需要决定的第一件事：我们应该使用 <code>Option</code> 还是 <code>Result</code>？使用 <code>Option</code> 非常简单，如果发生三个错误中的任何一个，我们可以简单地返回 <code>None</code>。这有一定效果，<em>并且比 <code>panic</code> 更好</em>，但是我们可以做得更好，我们应该传递一些有关发生的错误的详细信息。由于我们要表达<strong>错误的可能性</strong>，因此应使用 <code>Result&lt;i32, E&gt;</code>。但是 <code>E</code> 应该是什么呢？由于可能发生两种不同类型的错误，因此我们需要将它们转换为常见类型。一种这样的类型是 <code>String</code>。让我们看看这如何影响我们的代码：</p><figure class="highlight rust"><figcaption><span>io-basic-error-string</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(file_path)</span><br><span class="line">         .<span class="title function_ invoke__">map_err</span>(|err| err.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">         .<span class="title function_ invoke__">and_then</span>(|<span class="keyword">mut</span> file| &#123;</span><br><span class="line">              <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">              file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents)</span><br><span class="line">                  .<span class="title function_ invoke__">map_err</span>(|err| err.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">                  .<span class="title function_ invoke__">map</span>(|_| contents)</span><br><span class="line">         &#125;)</span><br><span class="line">         .<span class="title function_ invoke__">and_then</span>(|contents| &#123;</span><br><span class="line">              contents.<span class="title function_ invoke__">trim</span>().parse::&lt;<span class="type">i32</span>&gt;()</span><br><span class="line">                      .<span class="title function_ invoke__">map_err</span>(|err| err.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">         &#125;)</span><br><span class="line">         .<span class="title function_ invoke__">map</span>(|n| <span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">file_double</span>(<span class="string">&quot;foobar&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来有些复杂。像这样的代码可能需要大量的练习才能变得容易编写，我写的方式是<em>遵循返回类型</em>。一旦将 <code>file_double</code> 返回类型更改为 <code>Result&lt;i32, String&gt;</code>，我就必须开始寻找合适的组合器。在这种情况下，我们只用了三种不同的组合程序：<code>and_then</code>，<code>map</code> 和 <code>map_err</code>。</p><p><code>and_then</code> 用于链接多个计算，其中每个计算都可能返回错误。打开文件后，还有另外两个可能失败的计算：从文件读取并将内容解析为数字，相应地，有两个 <code>and_then</code> 调用。</p><p><code>map</code> 用于将函数应用于 <code>Result</code> 的 <code>Ok(...)</code> 值。例如，最后一次调用 <code>map</code> 将 <code>Ok(...)</code> 值（<code>i32</code>）乘以 <code>2</code>。如果在此之前发生了错误，则由于 <code>map</code> 定义的方式，该操作将被跳过。</p><p><code>map_err</code> 是使所有这些工作都有效的技巧。<code>map_err</code> 就像 <code>map</code> 一样，只是它对 <code>Result</code> 的 <code>Err(...)</code> 值应用了一个函数。在这种情况下，我们希望将所有错误都转换为一种类型：<code>String</code>。由于 <code>io::Error</code> 和 <code>num::ParseIntError</code> 实现 <code>ToString</code>，我们可以调用 <code>to_string()</code> 方法将其转换。</p><p>综上所述，代码仍然很繁琐。掌握组合器的用法很重要，但是它们有其局限性。让我们尝试另一种方法：<strong>提前返回</strong>。</p><h2 id="提取返回">提取返回</h2><p>我想使用<strong>提前返回</strong>重写上一节的代码。提前返回可以让你尽早退出该功能。我们在 <code>file_double</code> 中无法从一个闭包内部提前返回，因此我们需要恢复为显式的模式匹配。</p><figure class="highlight rust"><figcaption><span>io-basic-error-string-early-return</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = <span class="keyword">match</span> File::<span class="title function_ invoke__">open</span>(file_path) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(err) = file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = <span class="keyword">match</span> contents.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; n,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">file_double</span>(<span class="string">&quot;foobar&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分人可能不认为此代码是比使用组合器的代码更好，但是，如果你不熟悉组合器方法，那么这段代码看起来将会更简单。它使用带有 <code>match</code> 和 <code>if let</code> 的显式模式匹配。如果发生错误，它只是停止执行该函数并返回错误（通过将其转换为字符串）。</p><p>这不是倒退一步吗？之前，我曾说过，工程学错误处理的关键是减少显式模式匹配，但是我们在这里已恢复为显式模式匹配。事实证明，有多种方法可以减少显式模式匹配，组合器不是唯一的方法。</p><h2 id="try-宏-操作符"><code>try!</code> 宏/<code>?</code> 操作符</h2><p>在较旧的 Rust 版本（Rust 1.12 或更早版本）中，Rust 中错误处理的基石是 <code>try!</code> 宏。<code>try!</code> 宏将模式匹配抽象成组合器，但不同于组合器，它也抽象<em>控制流</em>。即，它可以抽象出上面看到的<em>提前返回</em>模式。</p><p>这是<code>try!</code>宏的简化定义：</p><figure class="highlight rust"><figcaption><span>try-def-simple</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> <span class="keyword">try</span> &#123;</span><br><span class="line">    ($e:expr) =&gt; (<span class="keyword">match</span> $e &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(val) =&gt; val,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（ <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/macro.try!.html">真实的定义</a> 要复杂得多。我们将在以后再看。）</p><p>使用 <code>try!</code> 宏可以很容易地简化我们的示例。由于它可以进行模式匹配并为我们实现提前返回，因此我们获得了更易于阅读的紧凑代码：</p><figure class="highlight rust"><figcaption><span>io-basic-error-try</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = <span class="built_in">try!</span>(File::<span class="title function_ invoke__">open</span>(file_path).<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="built_in">try!</span>(file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents).<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="built_in">try!</span>(contents.<span class="title function_ invoke__">trim</span>().parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">file_double</span>(<span class="string">&quot;foobar&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map_err</code> 调用仍然需要传递给我们的 <code>try!</code> 定义。这是因为错误类型仍需要转换为 <code>String</code>。好消息是，我们将很快学习如何删除这些 <code>map_err</code> 调用！坏消息是，在删除 <code>map_err</code> 调用之前，我们将需要更多地了解标准库中的几个重要特征。</p><p>在较新版本的 Rust（Rust 1.13 或更高版本）中，该 <code>try!</code> 宏已替换为 <code>?</code> 操作符。虽然它打算增加我们在这里不会介绍的新功能，但是使用 <code>?</code> 代替<code>try!</code> 是很简单的：</p><figure class="highlight rust"><figcaption><span>io-basic-error-question</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(file_path).<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>())?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents).<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>())?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = contents.<span class="title function_ invoke__">trim</span>().parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>())?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">file_double</span>(<span class="string">&quot;foobar&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义自己的错误类型">定义自己的错误类型</h2><p>在深入探讨一些标准库错误 traits 之前，我想通过在前面的示例中删除对我们的错误类型 <code>String</code> 的使用来结束本节。</p><p><code>String</code> 像在前面的示例中一样，使用起来很方便，因为很容易将错误转换为字符串，甚至可以当场将自己的错误作为字符串来实现。但是，使用 <code>String</code> 错误会带来一些不利影响。</p><p>第一个缺点是错误消息往往会使你的代码变得混乱。可以在其他地方定义错误消息，但是除非你受过特别的训练，否则很难将错误消息嵌入代码中。确实，我们在前面的示例中完全做到了这一点。</p><p>第二个更重要的缺点是 <code>String</code> 是<strong>有损的</strong>。也就是说，如果所有错误都转换为字符串，那么我们传递给调用方的错误将变得完全不透明。调用者可以对 <code>String</code> 错误进行的唯一合理的处理就是将其显示给用户。当然，检查字符串以确定错误的类型并不可靠。（诚然，与应用程序相比，此缺点在库内部要重要得多。）</p><p>例如，<code>io::Error</code> 类型嵌入 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>io::ErrorKind</code></a>，这是表示 IO 操作期间出了什么问题的<em>结构化数据</em>。这很重要，因为你可能希望根据错误做出不同的反应。（例如，<code>BrokenPipe</code> 错误可能意味着优雅地退出程序，而 <code>NotFound</code> 错误可能意味着退出并显示错误代码以向用户显示错误。）使用 <code>io::ErrorKind</code>，调用者可以使用模式匹配检查错误的类型，这绝对优于试图弄清楚一个 <code>String</code> 错误的细节。</p><p>与其在前面的从文件中读取整数的示例中将 <code>String</code> 用作错误类型，不如定义自己的错误类型，该错误类型表示结构化数据中的错误。如果调用者想检查详细信息，我们将努力不从潜在错误中删除信息。</p><p>表示<em>多种可能性之一</em>的理想方法是定义自己的枚举类型 <code>enum</code>。在我们的例子中，错误是 <code>io::Error</code> 或 <code>num::ParseIntError</code>，因此很自然地定义为：</p><figure class="highlight rust"><figcaption><span>io-basic-error-custom</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We derive `Debug` because all types should probably derive `Debug`.</span></span><br><span class="line"><span class="comment">// This gives us a reasonable human readable description of `CliError` values.</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Io</span>(io::Error),</span><br><span class="line">    <span class="title function_ invoke__">Parse</span>(num::ParseIntError),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调整我们的代码非常容易。无需将错误转换为字符串，我们只需使用相应的值构造函数将它们转换为我们的类型 <code>CliError</code> 即可：</p><figure class="highlight rust"><figcaption><span>io-basic-error-custom</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, CliError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(file_path).<span class="title function_ invoke__">map_err</span>(CliError::Io)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents).<span class="title function_ invoke__">map_err</span>(CliError::Io)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = contents.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">map_err</span>(CliError::Parse)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">file_double</span>(<span class="string">&quot;foobar&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;:?&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一的更改是将 <code>map_err(|e| e.to_string())</code>（将错误转换为字符串）切换到 <code>map_err(CliError::Io)</code> 或 <code>map_err(CliError::Parse)</code>，调用者可以通过问题的错误等级决定是否向用户报告。实际上，将 <code>String</code> 用作错误类型会从调用方中删除这种选择，而使用自定义 <code>enum</code> 错误类型，例如 <code>CliError</code>，除了描述错误的结构化数据外，还可以像以前一样为调用方提供很多便利。</p><p><strong>经验法则</strong>是尽量定义自己的错误类型，但是 <code>String</code> 错误类型会在一定程度上发生，特别是在编写应用程序时。如果要编写库，则强烈建议定义自己的错误类型，以免不必要地从调用方中删除选择。</p><h1>用于错误处理的标准库 traits</h1><p>标准库为错误处理定义了两个不可或缺的 trait： <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a> 和 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>std::convert::From</code></a>。尽管 <code>Error</code> 专为一般性地描述错误而设计，但是 <code>From</code> trait 在两个不同类型之间转换值时起更一般的作用。</p><h2 id="Error-trait"><code>Error</code> trait</h2><p><code>Error</code> trait 在<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/error/trait.Error.html">标准库中的定义</a>如下：</p><figure class="highlight rust"><figcaption><span>error-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::&#123;<span class="built_in">Debug</span>, Display&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Error</span>: <span class="built_in">Debug</span> + Display &#123;</span><br><span class="line">  <span class="comment">/// A short description of the error.</span></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">description</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The lower level cause of this error, if any.</span></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">cause</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;Error&gt; &#123; <span class="literal">None</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此 trait 是非常通用的，因为它打算表示<strong>错误的所有类型</strong>。我们将在后面看到这对编写可组合代码很有帮助。简单地说，该 trait 允许你执行以下操作：</p><ul><li>获取 <code>Debug</code> 错误的表示形式。</li><li>获取 <code>Display</code> 错误的面向用户的表示形式。</li><li>获得错误的简短描述（通过 <code>description</code> 方法）。</li><li>检查错误的因果链（如果存在）（通过 <code>cause</code> 方法）。</li></ul><p>前两个来自于 <code>Error</code> 要求实现 <code>Debug</code> 和 <code>Display</code>。后两者来自 <code>Error</code> 上定义的两种方法。<code>Error</code> 的力量来自所有错误类型均隐含 <code>Error</code> 的事实，这意味着可以将存在的错误量化为 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/1.0.0-beta.5/book/trait-objects.html">trait 对象</a>，这表现为 <code>Box&lt;Error&gt;</code> 或 <code>&amp;Error</code>。实际上，<code>cause</code> 方法返回一个 <code>&amp;Error</code>，它本身就是一个 trait 对象。稍后，我们将重新使用 <code>Error</code> trait 作为 trait 对象。</p><p>就目前而言，已经能够通过实现 <code>Error</code>trait 编写示例。让我们使用上一节中定义的错误类型 ：</p><figure class="highlight rust"><figcaption><span>error-impl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We derive `Debug` because all types should probably derive `Debug`.</span></span><br><span class="line"><span class="comment">// This gives us a reasonable human readable description of `CliError` values.</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Io</span>(io::Error),</span><br><span class="line">    <span class="title function_ invoke__">Parse</span>(num::ParseIntError),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种特殊的错误类型表示可能发生两种类型的错误：处理 I/O 的错误或将字符串转换为数字的错误。通过向 <code>enum</code> 定义添加新的变体，该错误可以表示所需的错误类型。</p><p>为其实现 <code>Error</code> 非常简单，主要是要进行很多显式的模式匹配。</p><figure class="highlight rust"><figcaption><span>error-impl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="comment">// Both underlying errors already impl `Display`, so we defer to</span></span><br><span class="line">            <span class="comment">// their implementations.</span></span><br><span class="line">            CliError::<span class="title function_ invoke__">Io</span>(<span class="keyword">ref</span> err) =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;IO error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">            CliError::<span class="title function_ invoke__">Parse</span>(<span class="keyword">ref</span> err) =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;Parse error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">error</span>::Error <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">description</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="comment">// Both underlying errors already impl `Error`, so we defer to their</span></span><br><span class="line">        <span class="comment">// implementations.</span></span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            CliError::<span class="title function_ invoke__">Io</span>(<span class="keyword">ref</span> err) =&gt; err.<span class="title function_ invoke__">description</span>(),</span><br><span class="line">            <span class="comment">// Normally we can just write `err.description()`, but the error</span></span><br><span class="line">            <span class="comment">// type has a concrete method called `description`, which conflicts</span></span><br><span class="line">            <span class="comment">// with the trait method. For now, we must explicitly call</span></span><br><span class="line">            <span class="comment">// `description` through the `Error` trait.</span></span><br><span class="line">            CliError::<span class="title function_ invoke__">Parse</span>(<span class="keyword">ref</span> err) =&gt; error::Error::<span class="title function_ invoke__">description</span>(err),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cause</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;error::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="comment">// N.B. Both of these implicitly cast `err` from their concrete</span></span><br><span class="line">            <span class="comment">// types (either `&amp;io::Error` or `&amp;num::ParseIntError`)</span></span><br><span class="line">            <span class="comment">// to a trait object `&amp;Error`. This works because both error types</span></span><br><span class="line">            <span class="comment">// implement `Error`.</span></span><br><span class="line">            CliError::<span class="title function_ invoke__">Io</span>(<span class="keyword">ref</span> err) =&gt; <span class="title function_ invoke__">Some</span>(err),</span><br><span class="line">            CliError::<span class="title function_ invoke__">Parse</span>(<span class="keyword">ref</span> err) =&gt; <span class="title function_ invoke__">Some</span>(err),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这是一个非常典型的 <code>Error</code> 实现：匹配不同的错误类型，并实现 <code>description</code> 和 <code>cause</code> 的定义。</p><h2 id="From-trait"><code>From</code> trait</h2><p><code>std::convert::From</code> trait 也是<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.From.html">定义在标准库中</a>:</p><figure class="highlight rust"><figcaption><span>from-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">From</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是非常简单？<code>From</code> 之所以非常有用，是因为它为我们提供了一种通用的方式来实现从特定类型 <code>T</code> 到其他类型的转换（在这种情况下，“其他类型”是 <code>impl</code> 的主体，也即是 <code>Self</code>）。<code>From</code> 有<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.From.html">标准库提供的一组实现</a>。</p><p>以下是一些简单的示例，说明其 <code>From</code> 工作方式：</p><figure class="highlight rust"><figcaption><span>from-examples</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">string</span>: <span class="type">String</span> = <span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">bytes</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">cow</span>: ::std::borrow::Cow&lt;<span class="type">str</span>&gt; = <span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br></pre></td></tr></table></figure><p>OK，因此 <code>From</code> 对于在字符串之间进行转换很有用。那么错误呢？同样有一个关键的实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, E: Error + <span class="symbol">&#x27;a</span>&gt; <span class="built_in">From</span>&lt;E&gt; <span class="keyword">for</span> <span class="title class_">Box</span>&lt;Error + <span class="symbol">&#x27;a</span>&gt;</span><br></pre></td></tr></table></figure><p>这个实现表示对于<strong>任何</strong>实现了 <code>Error</code> 的类型，我们可以将它转换为 trait 对象 <code>Box&lt;Error&gt;</code>，这在一般情况下很有用。</p><p>还记得我们以前处理的两个错误吗？也就是，<code>io::Error</code> 和 <code>num::ParseIntError</code>。既然都实现了 <code>Error</code>，它们同样可以使用 <code>From</code>：</p><figure class="highlight rust"><figcaption><span>from-examples-errors</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We have to jump through some hoops to actually get error values.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">io_err</span>: io::Error = io::Error::<span class="title function_ invoke__">last_os_error</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">parse_err</span>: num::ParseIntError = <span class="string">&quot;not a number&quot;</span>.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap_err</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK, here are the conversions.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">err1</span>: <span class="type">Box</span>&lt;Error&gt; = <span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(io_err);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">err2</span>: <span class="type">Box</span>&lt;Error&gt; = <span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(parse_err);</span><br></pre></td></tr></table></figure><p>注意这里有一个非常重要的模式。两个 <code>err1</code> 和 <code>err2</code> 具有<em>相同的类型</em>。这是因为它们是表示上完全相同的类型或 trait 对象。并且，编译器删除了它们的底层类型，因此在编译器看来，<code>err1</code> 和 <code>err2</code> 完全相同。此外，我们构造 <code>err1</code> 和 <code>err2</code> 使用了完全相同的函数调用：<code>From::from</code>。这是因为 <code>From::from</code> 在其参数和返回类型上都重载了。</p><p>此模式很重要，因为它解决了我们先前遇到的一个问题：提供了一种使用相同函数，将错误转换为相同类型的方法。</p><p>是时候重温一个老朋友了：<code>try!</code> 宏/ <code>?</code> 操作符。</p><h2 id="实际的-try-宏-操作符">实际的 <code>try!</code> 宏/ <code>?</code> 操作符</h2><p>之前，我介绍了 <code>try!</code> 的定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> <span class="keyword">try</span> &#123;</span><br><span class="line">    ($e:expr) =&gt; (<span class="keyword">match</span> $e &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(val) =&gt; val,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不是真实的定义。它<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/macro.try!.html">在标准库中</a>的真正定义：</p><figure class="highlight rust"><figcaption><span>try-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> <span class="keyword">try</span> &#123;</span><br><span class="line">    ($e:expr) =&gt; (<span class="keyword">match</span> $e &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(val) =&gt; val,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(::std::convert::<span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(err)),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个微小而强大的更改：错误值 <code>From::from</code> 通过传递。这使 <code>try!</code> 宏的功能更加强大，因为它为你提供了自动类型转换。这也与 <code>?</code> 操作符的工作方式非常相似，但后者的定义略有不同，即 <code>x?</code> 类似以下内容：</p><figure class="highlight rust"><figcaption><span>questionmark-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> ::std::ops::Try::<span class="title function_ invoke__">into_result</span>(x) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(v) =&gt; v,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> ::std::ops::Try::<span class="title function_ invoke__">from_error</span>(<span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(e)),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Try.html"><code>Try</code> trait</a> 暂时还在修改，不在本文的讨论范围之内，但是其本质是它提供了一种对许多不同类型的成功/失败模式进行抽象的方法，而无需与 <code>Result&lt;T, E&gt;</code> 紧密联系。如你所见，<code>x?</code> 语法仍然调用 <code>From::from</code>，这是我们实现自动错误转换的方式。</p><p>由于目前编写的大多数代码都使用 <code>?</code> 代替 <code>try!</code>，因此我们将在本文的其余部分中继续使用 <code>?</code>。</p><p>让我们看一下我们之前编写的用于读取文件并将其内容转换为整数的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(file_path).<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>())?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents).<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>())?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = contents.<span class="title function_ invoke__">trim</span>().parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>())?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前，我说过我们可以不调用 <code>map_err</code>。确实，我们要做的就是选择一种适用 <code>From</code> 的类型。正如我们在上一节中所看到的，<code>From</code> 的实现可以让我们将任何错误类型转换为 <code>Box&lt;Error&gt;</code>：</p><figure class="highlight rust"><figcaption><span>io-basic-error-try-from</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">Box</span>&lt;Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(file_path)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = contents.<span class="title function_ invoke__">trim</span>().parse::&lt;<span class="type">i32</span>&gt;()?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经非常接近理想的错误处理。我们的代码在错误处理上的开销很小，因为 <code>?</code> 操作符同时封装了三件事：</p><ol><li>模式匹配。</li><li>控制流。</li><li>错误类型转换。</li></ol><p>当三者结合在一起时，我们得到的代码不受组合器，调用 <code>unwrap</code> 或模式匹配的束缚。</p><p>剩下的只有一点点：<code>Box&lt;Error&gt;</code> 类型是<em>不透明的</em>。如果我们返回 <code>Box&lt;Error&gt;</code> 给调用方，则调用方将无法检查潜在的错误类型。虽然这种情况肯定比返回 <code>String</code> 要好，因为调用者可以调用诸如 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/error/trait.Error.html#tymethod.description"><code>description</code></a> 和 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/error/trait.Error.html#method.cause"><code>cause</code></a>的方法，但局限性仍然是：<code>Box&lt;Error&gt;</code> 不透明。（注意，这并非完全正确，因为 Rust 确实具有运行时反射，这在<a target="_blank" rel="noopener" href="https://crates.io/crates/error">超出本文范围的</a>某些情况下很有用。）</p><p>现在该重新审视我们的自定义 <code>CliError</code> 类型并将所有内容整合在一起。</p><h2 id="组合自定义错误类型">组合自定义错误类型</h2><p>在上一节中，我们研究了 <code>?</code> 运算符以及它如何通过调用 <code>From::from</code> 错误值为我们完成自动类型转换。特别是，我们可以将错误转换为 <code>Box&lt;Error&gt;</code>，但是类型对于调用者是不透明的。</p><p>要解决此问题，我们使用我们已经熟悉的相同补救措施：自定义错误类型。下面仍然是读取文件内容并将其转换为整数的代码：</p><figure class="highlight rust"><figcaption><span>io-basic-error-custom-from</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"><span class="keyword">use</span> std::num;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We derive `Debug` because all types should probably derive `Debug`.</span></span><br><span class="line"><span class="comment">// This gives us a reasonable human readable description of `CliError` values.</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Io</span>(io::Error),</span><br><span class="line">    <span class="title function_ invoke__">Parse</span>(num::ParseIntError),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double_verbose</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, CliError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(file_path).<span class="title function_ invoke__">map_err</span>(CliError::Io)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents).<span class="title function_ invoke__">map_err</span>(CliError::Io)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = contents.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">map_err</span>(CliError::Parse)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，我们仍然有 <code>map_err</code> 的调用。为什么？回想一下 <code>?</code> 运算符和 <code>From</code> 的定义，问题在于，没有 <code>From</code> 实现使我们能够从错误类型（例如 <code>io::Error</code> 和 <code>num::ParseIntError</code>）转换为我们自己的自定义类型 <code>CliError</code>。当然，解决这个问题很容易！既然定义了 <code>CliError</code>，我们就可以为它实现 <code>From</code>：</p><figure class="highlight rust"><figcaption><span>io-basic-error-custom-from</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;io::Error&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(err: io::Error) <span class="punctuation">-&gt;</span> CliError &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">Io</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;num::ParseIntError&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(err: num::ParseIntError) <span class="punctuation">-&gt;</span> CliError &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">Parse</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有这些实现正在做的事情是教导 <code>From</code> 如何从其他错误类型创建 <code>CliError</code>。在我们的例子中，实现就像调用相应的值构造函数一样简单。确实，这通常很容易。</p><p>我们终于可以重写<code>file_double</code>：</p><figure class="highlight rust"><figcaption><span>io-basic-error-custom-from</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, CliError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(file_path)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = contents.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>()?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在这里所做的唯一一件事就是删除对 <code>map_err</code> 的调用。不再需要它们，因为 <code>?</code> 运算符会在错误值上调用 <code>From::from</code>。之所以有效，是因为我们为所有可能出现的错误类型提供了 <code>From</code> 的实现。</p><p>如果我们修改 <code>file_double</code> 函数以执行其他操作，例如，将字符串转换为浮点数，则需要为错误类型添加新的变体：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Io</span>(io::Error),</span><br><span class="line">    <span class="title function_ invoke__">ParseInt</span>(num::ParseIntError),</span><br><span class="line">    <span class="title function_ invoke__">ParseFloat</span>(num::ParseFloatError),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了反映此更改，我们需要更新之前的 <code>impl From&lt;num::ParseIntError&gt; for CliError</code> 并添加新的 <code>impl From&lt;num::ParseFloatError&gt; for CliError</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;num::ParseIntError&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(err: num::ParseIntError) <span class="punctuation">-&gt;</span> CliError &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">ParseInt</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;num::ParseFloatError&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(err: num::ParseFloatError) <span class="punctuation">-&gt;</span> CliError &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">ParseFloat</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这样！</p><h2 id="对库作者的建议">对库作者的建议</h2><p>Rust 库的范式仍在形成，但是如果你的库需要报告自定义错误，那么你可能需要定义自己的错误类型。是否公开其表示形式（如 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>ErrorKind</code></a>）或使其隐藏（如 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>）取决于你。无论如何执行，通常最好的做法是至少提供有关错误的信息，而不仅仅是其 <code>String</code> 表示形式。但是可以肯定的是，这将取决于用例。</p><p>至少，你应该实现 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a> trait。这将使你的库用户在组合错误类型时有一定的灵活性。实施此 <code>Error</code> 特征还意味着要确保用户具有获取错误的字符串表示形式的能力（因为它要求实现 <code>fmt::Debug</code> 和 <code>fmt::Display</code>）。</p><p>除此之外，提供 <code>From</code> 错误类型的实现也可能很有用。这使你（库作者）和你的用户可以编写更详细的错误。例如， <a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/csv/1.0.0-beta.5/enum.Error.html"><code>csv::Error</code></a>同时为 <code>io::Error</code> 和 <code>byteorder::Error</code> 提供了 <code>From</code> 实现 。</p><p>最后，根据你的喜好，你可能还想定义一个 <code>Result</code> 类型别名，尤其是在你的库定义了单个错误类型的情况下。这是在标准库使用的 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a> 和 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/fmt/type.Result.html"><code>fmt::Result</code></a>。</p><h1>案例学习: 读取人口数据</h1><p>这个案例很长，根据你的知识背景，可能会比较复杂。虽然有很多示例代码与说明一起使用，但大多数代码都是专门为教学目的而设计的。虽然我不够聪明，无法制作既不是玩具示例又能够实现教学的示例，但我可以撰写实际案例。</p><p>为此，我想构建一个命令行程序，让你查询世界人口数据。目标很简单：你给它一个位置，它将告诉你人口数据。尽管简单，但仍有很多地方可能出错！</p><p>我们将使用的<a target="_blank" rel="noopener" href="https://github.com/petewarden/dstkdata">数据</a>来自 <a target="_blank" rel="noopener" href="https://github.com/petewarden/dstkdata">Data Science Toolkit</a>。我已经为此练习准备了一些数据。你可以获取 <a target="_blank" rel="noopener" href="https://burntsushi.net/stuff/worldcitiespop.csv.gz">世界人口数据</a> （41MB gzip 压缩，145MB 未压缩），也可以仅获取 <a target="_blank" rel="noopener" href="https://burntsushi.net/stuff/uscitiespop.csv.gz">美国人口数据</a> （2.2MB gzip 压缩，7.2MB 未压缩）。</p><p>到目前为止，我一直将代码限制为 Rust 的标准库。但是对于像这样的真实任务，我们至少要使用某种东西来解析CSV数据，解析程序参数并将这些东西自动解码为 Rust 类型。为此，我们将使用 <a target="_blank" rel="noopener" href="https://crates.io/crates/csv"><code>csv</code></a>， <a target="_blank" rel="noopener" href="https://crates.io/crates/docopt"><code>docopt</code></a> 和<a target="_blank" rel="noopener" href="https://crates.io/crates/rustc-serialize"><code>rustc-serialize</code></a> crate。</p><h2 id="在-Github-上获取">在 Github 上获取</h2><p>该案例研究的最终代码<a target="_blank" rel="noopener" href="https://github.com/BurntSushi/rust-error-handling-case-study">在Github上</a>。如果你安装了Rust和Cargo，那么你要做的就是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/BurntSushi/rust-error-handling-case-study</span><br><span class="line"><span class="built_in">cd</span> rust-error-handling-case-study</span><br><span class="line">cargo build --release</span><br><span class="line">./target/release/city-pop --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>我们将逐步构建该项目。继续！</p><h2 id="初始化">初始化</h2><p>我不会花很多时间在 Cargo 上建立项目，因为 <a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch01-03-hello-cargo.html">Rust Book</a> 和 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/guide/">Cargo的文档 </a> 已经很好地介绍了该项目 。</p><p>要从头开始，请运行 <code>cargo new --bin city-pop</code> 并确保你的 <code>Cargo.toml</code> 如下所示：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">package</span>]</span><br><span class="line"><span class="string">name</span> <span class="string">=</span> <span class="string">&quot;city-pop&quot;</span></span><br><span class="line"><span class="string">version</span> <span class="string">=</span> <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="string">authors</span> <span class="string">=</span> [<span class="string">&quot;Andrew Gallant &lt;jamslam@gmail.com&gt;&quot;</span>]</span><br><span class="line"></span><br><span class="line">[[<span class="string">bin</span>]]</span><br><span class="line"><span class="string">name</span> <span class="string">=</span> <span class="string">&quot;city-pop&quot;</span></span><br><span class="line"></span><br><span class="line">[<span class="string">dependencies</span>]</span><br><span class="line"><span class="string">csv</span> <span class="string">=</span> <span class="string">&quot;0.*&quot;</span></span><br><span class="line"><span class="string">docopt</span> <span class="string">=</span> <span class="string">&quot;0.*&quot;</span></span><br><span class="line"><span class="string">rustc-serialize</span> <span class="string">=</span> <span class="string">&quot;0.*&quot;</span></span><br></pre></td></tr></table></figure><p>你应该能够直接运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cargo build --release</span><br><span class="line">./target/release/city-pop</span><br><span class="line"><span class="comment">#Outputs: Hello, world!</span></span><br></pre></td></tr></table></figure><h2 id="参数解析">参数解析</h2><p>让我们首先进行参数解析。我不会在 Docopt 上介绍太多细节，但是有一个 <a target="_blank" rel="noopener" href="http://docopt.org/">不错的网页</a> 描述了它以及 <a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/docopt/">Rust crate 的文档</a>。简单地说，Docopt 从 Usage 字符串生成一个<strong>参数解析器</strong>。解析完成后，我们可以将程序参数解码为Rust 结构体。我们的程序如下，其中带有适当的 <code>extern crate</code> 语句，Usage 字符串，我们的 <code>Args</code> struct 和一个空的 <code>main</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> docopt;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> rustc_serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> USAGE: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;</span></span><br><span class="line"><span class="string">Usage: city-pop [options] &lt;data-path&gt; &lt;city&gt;</span></span><br><span class="line"><span class="string">       city-pop --help</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">    -h, --help     Show this usage message.</span></span><br><span class="line"><span class="string">&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Args</span> &#123;</span><br><span class="line">    arg_data_path: <span class="type">String</span>,</span><br><span class="line">    arg_city: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，是时候开始编写了。<a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/docopt/struct.Docopt.html#method.new">Docopt 的文档</a>说，我们可以创建一个解析器 <code>Docopt::new</code>，然后使用 <code>Docopt::decode</code> 将其解码为一个结构体。这两个函数都会返回 <a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/docopt/enum.Error.html"><code>docopt::Error</code></a>。我们可以从显式模式匹配开始：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// These use statements were added below the `extern` statements.</span></span><br><span class="line"><span class="comment">// I&#x27;ll elide them in the future. Don&#x27;t worry! It&#x27;s all on Github:</span></span><br><span class="line"><span class="comment">// https://github.com/BurntSushi/rust-error-handling-case-study</span></span><br><span class="line"><span class="comment">//use std::io::&#123;self, Write&#125;;</span></span><br><span class="line"><span class="comment">//use std::process;</span></span><br><span class="line"><span class="comment">//use docopt::Docopt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: Args = <span class="keyword">match</span> Docopt::<span class="title function_ invoke__">new</span>(USAGE) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; &#123;</span><br><span class="line">            <span class="built_in">writeln!</span>(&amp;<span class="keyword">mut</span> io::<span class="title function_ invoke__">stderr</span>(), <span class="string">&quot;&#123;&#125;&quot;</span>, err).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(dopt) =&gt; <span class="keyword">match</span> dopt.<span class="title function_ invoke__">decode</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(err) =&gt; &#123;</span><br><span class="line">                <span class="built_in">writeln!</span>(&amp;<span class="keyword">mut</span> io::<span class="title function_ invoke__">stderr</span>(), <span class="string">&quot;&#123;&#125;&quot;</span>, err).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(args) =&gt; args,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这并不是很好。为了使代码更清晰，我们可以做的一件事是编写一个宏以将消息打印到 <code>stderr</code> 然后退出：</p><figure class="highlight rust"><figcaption><span>fatal-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> fatal &#123;</span><br><span class="line">    ($($tt:tt)*) =&gt; &#123;&#123;</span><br><span class="line">        <span class="keyword">use</span> std::io::Write;</span><br><span class="line">        <span class="built_in">writeln!</span>(&amp;<span class="keyword">mut</span> ::std::io::<span class="title function_ invoke__">stderr</span>(), $($tt)*).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        ::std::process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unwrap</code> 在这里是没问题的，因为如果失败的话，就意味着你的程序无法写入 <code>stderr</code>。一个好的经验法则是可以中止，但是可以肯定的是，如果需要，你可以做其他事情。</p><p>这个代码看起来更好，但是显式的模式匹配仍然很麻烦：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">args</span>: Args = <span class="keyword">match</span> Docopt::<span class="title function_ invoke__">new</span>(USAGE) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(err) =&gt; fatal!(<span class="string">&quot;&#123;&#125;&quot;</span>, err),</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(dopt) =&gt; <span class="keyword">match</span> dopt.<span class="title function_ invoke__">decode</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; fatal!(<span class="string">&quot;&#123;&#125;&quot;</span>, err),</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(args) =&gt; args,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>值得庆幸的是，<a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/docopt/enum.Error.html"><code>docopt::Error</code></a> 类型定义了一种便捷的方法 <a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/docopt/enum.Error.html#method.exit"><code>exit</code></a>，该方法可以有效地完成我们刚刚做的事情。将其与我们的组合器知识相结合，我们获得了简洁明了的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">args</span>: Args = Docopt::<span class="title function_ invoke__">new</span>(USAGE)</span><br><span class="line">                        .<span class="title function_ invoke__">and_then</span>(|d| d.<span class="title function_ invoke__">decode</span>())</span><br><span class="line">                        .<span class="title function_ invoke__">unwrap_or_else</span>(|err| err.<span class="title function_ invoke__">exit</span>());</span><br></pre></td></tr></table></figure><p>如果此代码成功完成，则将根据用户提供的值填充 <code>args</code>。</p><h2 id="编写程序逻辑">编写程序逻辑</h2><p>编写代码的方式各不相同，但是当我不确定如何编码问题时，错误处理通常是我要考虑的最后一件事。对于好的设计来说，这不是一个很好的做法，但是对于快速原型制作可能是有用的。在我们的案例中，由于 Rust 迫使我们对错误进行处理，这也将使程序的哪些部分可能导致错误变得显而易见。为什么？因为 Rust 将使我们调用 <code>unwrap</code>，这可以使我们很好地了解如何进行错误处理。</p><p>在本案例中，程序逻辑非常简单。我们需要做的就是解析提供给我们的 CSV 数据，并在匹配的行中打印出一个字段。我们开始吧。（确保添加 <code>extern crate csv;</code> 到文件的顶部。）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This struct represents the data in each row of the CSV file.</span></span><br><span class="line"><span class="comment">// Type based decoding absolves us of a lot of the nitty gritty error</span></span><br><span class="line"><span class="comment">// handling, like parsing strings as integers or floats.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Row</span> &#123;</span><br><span class="line">    country: <span class="type">String</span>,</span><br><span class="line">    city: <span class="type">String</span>,</span><br><span class="line">    accent_city: <span class="type">String</span>,</span><br><span class="line">    region: <span class="type">String</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not every row has data for the population, latitude or longitude!</span></span><br><span class="line">    <span class="comment">// So we express them as `Option` types, which admits the possibility of</span></span><br><span class="line">    <span class="comment">// absence. The CSV parser will fill in the correct value for us.</span></span><br><span class="line">    population: <span class="type">Option</span>&lt;<span class="type">u64</span>&gt;,</span><br><span class="line">    latitude: <span class="type">Option</span>&lt;<span class="type">f64</span>&gt;,</span><br><span class="line">    longitude: <span class="type">Option</span>&lt;<span class="type">f64</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: Args = Docopt::<span class="title function_ invoke__">new</span>(USAGE)</span><br><span class="line">                            .<span class="title function_ invoke__">and_then</span>(|d| d.<span class="title function_ invoke__">decode</span>())</span><br><span class="line">                            .<span class="title function_ invoke__">unwrap_or_else</span>(|err| err.<span class="title function_ invoke__">exit</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = fs::File::<span class="title function_ invoke__">open</span>(args.arg_data_path).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rdr</span> = csv::Reader::<span class="title function_ invoke__">from_reader</span>(file);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> rdr.decode::&lt;Row&gt;() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">row</span> = row.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">if</span> row.city == args.arg_city &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;: &#123;:?&#125;&quot;</span>,</span><br><span class="line">                     row.city, row.country,</span><br><span class="line">                     row.population.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;population count&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们分析可能出现的错误。我们可以从显而易见的地方开始：这三个 <code>unwrap</code> 地方为：</p><ol><li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>fs::File::open</code></a> 可能返回 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/io/struct.Error.html"><code>io::Error</code></a>。</li><li><a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/csv/struct.Reader.html#method.decode"><code>csv::Reader::decode</code></a> 一次解码一个记录，但是<a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html">解码一条记录</a> （查看 <code>Iterator</code> 上的关联类型 <code>Item</code>）可能产生一个 <a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/csv/1.0.0-beta.5/enum.Error.html"><code>csv::Error</code></a>。</li><li>如果 <code>row.population</code> 为 <code>None</code>，则调用 <code>expect</code> 会导致 <code>panic</code>。</li></ol><p>还有其他吗？如果我们找不到匹配的城市怎么办？类似的工具 <code>grep</code> 将返回错误代码，因此我们也应该这样做。因此，我们得到了特定于我们问题的逻辑错误，IO 错误和 CSV 分析错误。我们将探索两种不同的方法来处理这些错误。</p><p>我想从使用 <code>Box&lt;Error&gt;</code> 开始。稍后，我们将看到定义自己的错误类型也是很有用的。</p><h2 id="使用-Box-Error-进行错误处理">使用 <code>Box&lt;Error&gt;</code> 进行错误处理</h2><p><code>Box&lt;Error&gt;</code> 的特性很合适，因为你不需要定义自己的错误类型，也不需要任何 <code>From</code> 实现。缺点是，由于 <code>Box&lt;Error&gt;</code> 是 trait 对象，因此<strong>会删除隐含的类型</strong>，这意味着编译器无法再对其基础类型进行推理。</p><p>让我们开始改变函数的返回类型 <code>T</code> 到 <code>Result&lt;T, OurErrorType&gt;</code> 重构我们的代码。在这种情况下，<code>OurErrorType</code> is <code>Box&lt;Error&gt;</code>。那么 <code>T</code> 是什么？我们可以将返回类型添加到<code>main</code>吗？</p><p>第二个问题的答案是否定的，我们不能。这意味着我们需要编写一个新函数。但是 <code>T</code> 是什么呢？最简单的方法是将匹配 <code>Row</code> 值的列表作为 <code>Vec&lt;Row&gt;</code> 返回。（更好的代码将返回一个迭代器，但这留给读者练习。）</p><p>让我们将代码重构为自己的函数，但保留对 <code>unwrap</code> 的调用。请注意，我们选择通过简单地忽略该行来处理人口总数缺失的可能性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Row</span> &#123;</span><br><span class="line">    <span class="comment">// unchanged</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PopulationCount</span> &#123;</span><br><span class="line">    city: <span class="type">String</span>,</span><br><span class="line">    country: <span class="type">String</span>,</span><br><span class="line">    <span class="comment">// This is no longer an `Option` because values of this type are only</span></span><br><span class="line">    <span class="comment">// constructed if they have a population count.</span></span><br><span class="line">    count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P, city: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;PopulationCount&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">found</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = fs::File::<span class="title function_ invoke__">open</span>(file_path).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rdr</span> = csv::Reader::<span class="title function_ invoke__">from_reader</span>(file);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> rdr.decode::&lt;Row&gt;() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">row</span> = row.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">match</span> row.population &#123;</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123; &#125; <span class="comment">// skip it</span></span><br><span class="line">            <span class="title function_ invoke__">Some</span>(count) =&gt; <span class="keyword">if</span> row.city == city &#123;</span><br><span class="line">                found.<span class="title function_ invoke__">push</span>(PopulationCount &#123;</span><br><span class="line">                    city: row.city,</span><br><span class="line">                    country: row.country,</span><br><span class="line">                    count: count,</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    found</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: Args = Docopt::<span class="title function_ invoke__">new</span>(USAGE)</span><br><span class="line">                            .<span class="title function_ invoke__">and_then</span>(|d| d.<span class="title function_ invoke__">decode</span>())</span><br><span class="line">                            .<span class="title function_ invoke__">unwrap_or_else</span>(|err| err.<span class="title function_ invoke__">exit</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">pop</span> <span class="keyword">in</span> <span class="title function_ invoke__">search</span>(&amp;args.arg_data_path, &amp;args.arg_city) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;: &#123;:?&#125;&quot;</span>, pop.city, pop.country, pop.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管我们摆脱了对 <code>expect</code> 的调用（是 <code>unwrap</code> 的更好的变体），但我们仍然应该处理没有任何搜索结果的情况。</p><p>要将其转换为正确的错误处理，我们需要执行以下操作：</p><ol><li>将 <code>search</code> 的返回类型更改为 <code>Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt;</code>。</li><li>使用 <code>?</code> 运算符，以便将错误返回给调用者，而不用 <code>panic</code> 该程序。</li><li>处理 <code>main</code> 中的错误。</li></ol><p>让我们尝试一下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;</span><br><span class="line">         (file_path: P, city: &amp;<span class="type">str</span>)</span><br><span class="line">         <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;PopulationCount&gt;, <span class="type">Box</span>&lt;Error+<span class="built_in">Send</span>+<span class="built_in">Sync</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">found</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = fs::File::<span class="title function_ invoke__">open</span>(file_path)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rdr</span> = csv::Reader::<span class="title function_ invoke__">from_reader</span>(file);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> rdr.decode::&lt;Row&gt;() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">row</span> = row?;</span><br><span class="line">        <span class="keyword">match</span> row.population &#123;</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123; &#125; <span class="comment">// skip it</span></span><br><span class="line">            <span class="title function_ invoke__">Some</span>(count) =&gt; <span class="keyword">if</span> row.city == city &#123;</span><br><span class="line">                found.<span class="title function_ invoke__">push</span>(PopulationCount &#123;</span><br><span class="line">                    city: row.city,</span><br><span class="line">                    country: row.country,</span><br><span class="line">                    count: count,</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> found.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;No matching cities with a population were found.&quot;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(found)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于 <code>x.unwrap()</code>，我们现在使用 <code>x?</code>。由于我们的函数返回 <code>Result&lt;T, E&gt;</code>，因此如果发生错误，<code>?</code> 操作符会从函数中提前返回。</p><p>这段代码有一个大陷阱：我们应该使用 <code>Box&lt;Error + Send + Sync&gt;</code> 代替 <code>Box&lt;Error&gt;</code>。我们这样做是为了将纯字符串转换为错误类型。我们需要这些额外的限制，以便我们可以使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.From.html">相应的 <code>From</code> impls</a>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We are making use of this impl in the code above, since we call `From::from`</span></span><br><span class="line"><span class="comment">// on a `&amp;&#x27;static str`.</span></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; <span class="built_in">From</span>&lt;&amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>&gt; <span class="keyword">for</span> <span class="title class_">Box</span>&lt;Error + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="symbol">&#x27;a</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// But this is also useful when you need to allocate a new string for an</span></span><br><span class="line"><span class="comment">// error message, usually with `format!`.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;<span class="type">String</span>&gt; <span class="keyword">for</span> <span class="title class_">Box</span>&lt;Error + <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt;</span><br></pre></td></tr></table></figure><p>现在，我们已经了解了如何使用 <code>Box&lt;Error&gt;</code> 进行正确的错误处理，让我们尝试使用自定义错误类型的另一种方法。但是首先，让我们从错误处理中休息一下，并增加对从 <code>stdin</code> 中读取数据的支持。</p><h2 id="从-stdin-读取">从 stdin 读取</h2><p>在我们的程序中，我们接受单个文件作为输入，并对数据进行一次传递。这意味着我们可能应该能够在 stdin 上接受输入。但是我们也喜欢当前的格式，所以让我们两者兼而有之！</p><p>添加对 stdin 的支持实际上非常容易。我们只需要做两件事：</p><ol><li>调整程序参数，以便在从 stdin 读取人口数据时可以接受一个参数：城市。</li><li>修改 <code>search</code> 功能以采用<em>可选的</em>文件路径。当为 <code>None</code> 时，它知道应该从 stdin 读取。</li></ol><p>首先，这是新的 Usage 和 <code>Args</code> 结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> USAGE: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;</span></span><br><span class="line"><span class="string">Usage: city-pop [options] [&lt;data-path&gt;] &lt;city&gt;</span></span><br><span class="line"><span class="string">       city-pop --help</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">    -h, --help     Show this usage message.</span></span><br><span class="line"><span class="string">&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Args</span> &#123;</span><br><span class="line">    arg_data_path: <span class="type">Option</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    arg_city: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们所做的就是在 Docopt 用法字符串中将 <code>data-path</code> 参数设置为可选，并将相应的 struct 成员 <code>arg_data_path</code> 设置为可选。<code>docopt</code> crate将处理其余部分。</p><p>修改 <code>search</code> 有些棘手。<code>csv</code> crate 可以解析任何实现了<a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/csv/struct.Reader.html#method.from_reader"><code>io::Read</code></a>的类型。但是，如何在两种类型上使用相同的代码？实际上，我们可以采取几种方法。一种方法是编写 <code>search</code> 代码，使其对某些实现了 <code>io::Read</code> 的类型参数 <code>R</code> 是通用的。另一种方法是只使用 trait 对象：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;</span><br><span class="line">         (file_path: &amp;<span class="type">Option</span>&lt;P&gt;, city: &amp;<span class="type">str</span>)</span><br><span class="line">         <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;PopulationCount&gt;, <span class="type">Box</span>&lt;Error+<span class="built_in">Send</span>+<span class="built_in">Sync</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">found</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span>: <span class="type">Box</span>&lt;io::Read&gt; = <span class="keyword">match</span> *file_path &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; Box::<span class="title function_ invoke__">new</span>(io::<span class="title function_ invoke__">stdin</span>()),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="keyword">ref</span> file_path) =&gt; Box::<span class="title function_ invoke__">new</span>(fs::File::<span class="title function_ invoke__">open</span>(file_path)?),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rdr</span> = csv::Reader::<span class="title function_ invoke__">from_reader</span>(input);</span><br><span class="line">    <span class="comment">// The rest remains unchanged!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用自定义类型进行错误处理">使用自定义类型进行错误处理</h2><p>之前，我们学习了如何使用自定义错误类型来编写错误类型。为此，我们将错误类型定义为 <code>enum</code>，然后实现 <code>Error</code> 和 <code>From</code>。</p><p>由于存在三个不同的错误（IO，CSV 解析和未找到），因此我们定义一个具有三个变体的 <code>enum</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Io</span>(io::Error),</span><br><span class="line">    <span class="title function_ invoke__">Csv</span>(csv::Error),</span><br><span class="line">    NotFound,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且实现 <code>Display</code> 和 <code>Error</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            CliError::<span class="title function_ invoke__">Io</span>(<span class="keyword">ref</span> err) =&gt; err.<span class="title function_ invoke__">fmt</span>(f),</span><br><span class="line">            CliError::<span class="title function_ invoke__">Csv</span>(<span class="keyword">ref</span> err) =&gt; err.<span class="title function_ invoke__">fmt</span>(f),</span><br><span class="line">            CliError::NotFound =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;No matching cities with a \</span></span><br><span class="line"><span class="string">                                             population were found.&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Error</span> <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">description</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            CliError::<span class="title function_ invoke__">Io</span>(<span class="keyword">ref</span> err) =&gt; err.<span class="title function_ invoke__">description</span>(),</span><br><span class="line">            CliError::<span class="title function_ invoke__">Csv</span>(<span class="keyword">ref</span> err) =&gt; err.<span class="title function_ invoke__">description</span>(),</span><br><span class="line">            CliError::NotFound =&gt; <span class="string">&quot;not found&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们可以在 <code>search</code> 函数中使用 <code>CliError</code> 类型之前，我们需要提供一些 <code>From</code> 实现。我们如何知道要提供哪些实现？好吧，我们需要同时从<code>io::Error</code> 和 <code>csv::Error</code> 中转换为 <code>CliError</code>。这些是唯一的外部错误，所以我们 <code>From</code> 现在只需要两个实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;io::Error&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(err: io::Error) <span class="punctuation">-&gt;</span> CliError &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">Io</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;csv::Error&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(err: csv::Error) <span class="punctuation">-&gt;</span> CliError &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">Csv</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于定义了 <code>?</code> 运算符，因此 <code>From</code> 非常重要 。特别是，如果发生错误，则对错误进行调用 <code>From::from</code>，在这种情况下，会将其转换为我们自己的错误类型 <code>CliError</code>。</p><p>随着 <code>From</code> 实现的完成，我们只需要对我们的 <code>search</code> 函数进行两个小调整：返回类型和“未找到”错误。这是完整的程序：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;</span><br><span class="line">         (file_path: &amp;<span class="type">Option</span>&lt;P&gt;, city: &amp;<span class="type">str</span>)</span><br><span class="line">         <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;PopulationCount&gt;, CliError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">found</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span>: <span class="type">Box</span>&lt;io::Read&gt; = <span class="keyword">match</span> *file_path &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; Box::<span class="title function_ invoke__">new</span>(io::<span class="title function_ invoke__">stdin</span>()),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="keyword">ref</span> file_path) =&gt; Box::<span class="title function_ invoke__">new</span>(fs::File::<span class="title function_ invoke__">open</span>(file_path)?),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rdr</span> = csv::Reader::<span class="title function_ invoke__">from_reader</span>(input);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> rdr.decode::&lt;Row&gt;() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">row</span> = row?;</span><br><span class="line">        <span class="keyword">match</span> row.population &#123;</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123; &#125; <span class="comment">// skip it</span></span><br><span class="line">            <span class="title function_ invoke__">Some</span>(count) =&gt; <span class="keyword">if</span> row.city == city &#123;</span><br><span class="line">                found.<span class="title function_ invoke__">push</span>(PopulationCount &#123;</span><br><span class="line">                    city: row.city,</span><br><span class="line">                    country: row.country,</span><br><span class="line">                    count: count,</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> found.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(CliError::NotFound)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(found)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无需其他更改。</p><h2 id="额外功能">额外功能</h2><p>如果你像我一样，那么编写通用代码会感觉不错，因为通用化的东西很酷！但是有时候，这样做是不值得的。看一下我们在上一步中所做的事情：</p><ol><li>定义了新的错误类型。</li><li>新增实现了 <code>Error</code>，<code>Display</code> 和两个 <code>From</code>。</li></ol><p>这里最大的缺点是我们的程序并没有改善很多。我个人喜欢它，因为我喜欢使用 <code>enum</code> 表示错误，但是这样做有很多开销，尤其是在像这样的短程序中。</p><p>像我们在这里一样使用自定义错误类型的一个有用方面是，<code>main</code> 函数现在可以选择以不同方式处理错误。以前，使用 <code>Box&lt;Error&gt;</code> 时，它没有太多选择：仅打印消息。我们在这里仍然这样做，但是如果我们想添加一个 <code>--quiet</code> 标志怎么办？该 <code>--quiet</code> 标志应使任何详细的输出静音。</p><p>现在，如果程序找不到匹配项，它将输出一条消息，说明是这样。这可能有点笨拙，特别是如果你打算将该程序用于 shell 脚本中时。</p><p>因此，让我们从添加标志开始。像以前一样，我们需要调整用法字符串并在 <code>Args</code> 结构中添加一个标志。<code>docopt</code> crate 完成剩下的事情：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> USAGE: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;</span></span><br><span class="line"><span class="string">Usage: city-pop [options] [&lt;data-path&gt;] &lt;city&gt;</span></span><br><span class="line"><span class="string">       city-pop --help</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">    -h, --help     Show this usage message.</span></span><br><span class="line"><span class="string">    -q, --quiet    Don&#x27;t show noisy messages.</span></span><br><span class="line"><span class="string">&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Args</span> &#123;</span><br><span class="line">    arg_data_path: <span class="type">Option</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    arg_city: <span class="type">String</span>,</span><br><span class="line">    flag_quiet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们只需要实现 “quiet” 功能即可。这需要我们在 <code>main</code> 中进行的调整：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="title function_ invoke__">search</span>(&amp;args.arg_data_path, &amp;args.arg_city) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(CliError::NotFound) <span class="keyword">if</span> args.flag_quiet =&gt; process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(err) =&gt; fatal!(<span class="string">&quot;&#123;&#125;&quot;</span>, err),</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(pops) =&gt; <span class="keyword">for</span> <span class="variable">pop</span> <span class="keyword">in</span> pops &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;: &#123;:?&#125;&quot;</span>, pop.city, pop.country, pop.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果发生 IO 错误或数据解析失败，我们不想静默输出。因此，我们采用模式匹配，以检查错误类型是否为 <code>NotFound</code> 和是否已启用 <code>--quiet</code>。如果搜索失败，我们仍然会退出代码（遵循 <code>grep</code> 的约定）。</p><p>如果我们坚持使用 <code>Box&lt;Error&gt;</code>，那么实现 <code>--quiet</code> 功能将非常棘手。</p><p>这几乎总结了我们的案例研究。从这里开始，你应该能够编写带有适当错误处理的自己的程序和库。</p><h1>概括</h1><p>由于本文很长，因此快速总结一下Rust中的错误处理很有用。这些是我的“经验法则”。他们并不是教条。每一个规则都可能会有充足的理由去反驳！</p><ul><li>如果你正在编写示例代码，并不想实现过于繁琐的错误处理，<code>unwrap</code> 应该是很好用的（不管是 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>Result::unwrap</code></a>， <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap"><code>Option::unwrap</code></a> 或更好的 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>Option::expect</code></a>）。你的代码的使用者应该知道如何使用正确的错误处理。（如果没有，让他们来看这篇文章！）</li><li>如果你正在编写 quick ‘n’ dirty 程序，请不要羞于使用 <code>unwrap</code>。警告：如果交接到别人的手中，当他们被错误的消息所困扰时，不要感到惊讶！</li><li>如果你正在编写一个 quick ‘n’ dirty 程序，并且无论如何都不想造成 <code>panic</code>，那么你应该使用如上例所示的 <code>Box&lt;Error&gt;</code> （或 <code>Box&lt;Error + Send + Sync&gt;</code>）。另一个比较好的替代方法是使用 <a target="_blank" rel="noopener" href="https://crates.io/crates/anyhow"><code>anyhow</code></a> crate 及其 <code>anyhow::Error</code> 类型。使用 <code>anyhow</code> 时，在 nightly Rust 中，你的错误将自动附加 backtraces 。</li><li>否则，在程序中使用适当的 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> 和 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a> 实现定义自己的错误类型，以使 <code>?</code> 操作符更加符合工程学。</li><li>如果你正在编写库，并且代码可能会产生错误，请定义自己的错误类型并实现 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a> trait。在适当的地方，实现 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> 使你的库代码和调用者的代码更易于编写。（由于 Rust 的一致性规则，调用者将无法为你的错误类型实现 <code>From</code>，因此你的库应该这样做。）</li><li>使用 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> 和 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> 上定义的组合器 。有时单独使用它们可能会有些麻烦，但是我发现，<code>?</code> 操作符和组合器的组合非常有吸引力。<code>and_then</code>，<code>map</code> 和 <code>unwrap_or</code>是我的最爱。</li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://blog.burntsushi.net/rust-error-handling/&quot;&gt;https://blog.burntsushi.net/rust-error-handling/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文标题：Error Handling in Rust&lt;/p&gt;
&lt;p&gt;原文作者：&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://blog.burntsushi.net/&quot;&gt;Andrew Gallant’s Blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译日期：2020/08/03&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://blog.czccc.cc/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://blog.czccc.cc/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>SQL 必知必会 - 多表查询/联结/组合</title>
    <link href="http://blog.czccc.cc/p/4c50c6b4/"/>
    <id>http://blog.czccc.cc/p/4c50c6b4/</id>
    <published>2020-08-02T14:04:42.000Z</published>
    <updated>2022-08-06T13:07:33.621Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>SQL 必知必会 - 全书目录</p><ol><li>第 01 - 10 章：<a href="/p/57d19b2c">SQL 必知必会 - 单表查询/过滤/汇总</a></li><li>第 11 - 24 章：<a href="/p/4c50c6b4">SQL 必知必会 - 多表查询/联结/组合</a></li><li>第 15 - 24 章：<a href="/p/3b57f622">SQL 必知必会 - 数据更新/存储/事务</a></li></ol></blockquote><span id="more"></span><h1>使用子查询 - subquery</h1><ul><li>SQL 还允许创建子查询（subquery）, 即嵌套在其他查询中的查询</li><li>把子查询分解为多行并进行适当的缩进, 能极大地简化子查询的使用</li><li>作为子查询的 <code>SELECT</code> 语句只能查询单个列, 企图检索多个列将返回错误</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 利用子查询进行过滤</span></span><br><span class="line"><span class="comment">-- (1) 检索包含物品 RGAN01 的所有订单的编号。</span></span><br><span class="line"><span class="comment">-- (2) 检索具有前一步骤列出的订单编号的所有顾客的 ID。</span></span><br><span class="line"><span class="comment">-- (3) 检索前一步骤返回的所有顾客 ID 的顾客信息。</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cust_id</span><br><span class="line">                  <span class="keyword">FROM</span> Orders</span><br><span class="line">                  <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</span><br><span class="line">                                      <span class="keyword">FROM</span> OrderItems</span><br><span class="line">                                      <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;RGAN01&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 作为计算字段使用子查询</span></span><br><span class="line"><span class="comment">-- (1) 从 Customers 表中检索顾客列表；</span></span><br><span class="line"><span class="comment">-- (2) 对于检索出的每个顾客，统计其在 Orders 表中的订单数目。</span></span><br><span class="line"><span class="comment">-- 子查询在构造这种 SELECT 语句时极有用, 但必须注意限制有歧义的列。</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name,</span><br><span class="line">       cust_state,</span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">        <span class="keyword">FROM</span> Orders</span><br><span class="line">        <span class="keyword">WHERE</span> Orders.cust_id <span class="operator">=</span> Customers.cust_id) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure><h1>联结表 - <code>join</code></h1><ul><li>SQL 最强大的功能之一就是能在数据查询的执行中联结（ <code>join</code>）表</li><li>关系表<ul><li>关系表的设计就是要把信息分解成多个表，一类数据一个表</li><li>各表通过某些共同的值互相关联（所以才叫关系数据库）</li><li>可伸缩（scale）：能够适应不断增加的工作量而不失败。</li><li>设计良好的数据库或应用程序称为可伸缩性好（scale well）</li></ul></li><li>联结是一种机制，用来在一条 <code>SELECT</code> 语句中关联表，因此称为联结</li><li>使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行</li><li>创建联结：指定要联结的所有表以及关联它们的方式</li><li><code>WHERE</code> 子句作为过滤条件，只包含那些匹配给定条件（这里是联结条件）的行</li><li>笛卡儿积（cartesian product）：由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。也叫叉联结（cross join）。</li><li>等值联结（equijoin），也称为内联结（inner join）</li><li>ANSI SQL 规范首选 <code>INNER JOIN</code> 语法，</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- prod_name, prod_price 在一个表中，而 vend_name 在另一个表中</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Vendors, Products</span><br><span class="line"><span class="keyword">WHERE</span> Vendors.vend_id <span class="operator">=</span> Products.vend_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 笛卡儿积</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Vendors, Products;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 稍微不同的语法，结果相同</span></span><br><span class="line"><span class="comment">-- 两个表之间的关系是以 INNER JOIN 指定的部分 FROM 子句</span></span><br><span class="line"><span class="comment">-- 联结条件用特定的 ON 子句而不是 WHERE 子句给出</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Products</span><br><span class="line"><span class="keyword">ON</span> Vendors.vend_id <span class="operator">=</span> Products.vend_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 联结多个表</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name, vend_name, prod_price, quantity</span><br><span class="line"><span class="keyword">FROM</span> OrderItems, Products, Vendors</span><br><span class="line"><span class="keyword">WHERE</span> Products.vend_id <span class="operator">=</span> Vendors.vend_id</span><br><span class="line"><span class="keyword">AND</span> OrderItems.prod_id <span class="operator">=</span> Products.prod_id</span><br><span class="line"><span class="keyword">AND</span> order_num <span class="operator">=</span> <span class="number">20007</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第 11 章的例子可以简化为：</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> Customers, Orders, OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> Customers.cust_id <span class="operator">=</span> Orders.cust_id</span><br><span class="line"><span class="keyword">AND</span> OrderItems.order_num <span class="operator">=</span> Orders.order_num</span><br><span class="line"><span class="keyword">AND</span> prod_id <span class="operator">=</span> <span class="string">&#x27;RGAN01&#x27;</span>;</span><br></pre></td></tr></table></figure><h1>创建高级联结</h1><ul><li>在创建计算字段中，可以使用 <code>AS</code> 关键字给列起别名</li><li>SQL 除了可以对列名和计算字段使用别名，还允许给表名起别名<ul><li>缩短SQL 语句</li><li>允许在一条 <code>SELECT</code> 语句中多次使用相同的表</li><li>Oracle 不支持 <code>AS</code></li></ul></li><li>表别名只在查询执行中使用</li><li>自联结：通常作为外部语句，用来替代从相同表中检索数据的使用子查询语句</li><li>自然联结：排除多次出现的列，使每一列只返回一次<ul><li>要求你只能选择那些唯一的列</li><li>一般通过对一个表使用通配符（ <code>SELECT *</code>），而对其他表的列使用明确的子集来完成</li></ul></li><li>外联结：有时候需要包含没有关联行的那些行<ul><li>对每个顾客下的订单进行计数，包括那些至今尚未下订单的顾客</li><li>列出所有产品以及订购数量，包括没有人订购的产品</li><li>计算平均销售规模，包括那些至今尚未下订单的顾客。</li><li>使用关键字 <code>OUTER JOIN</code><br>来指定联结类型</li><li>在使用 <code>OUTER   JOIN</code> 语法时，必须使用 <code>RIGHT</code> 或 <code>LEFT</code> 关键字指定包括其所有行的表</li><li><code>RIGHT</code> 指出的是 <code>OUTER JOIN</code> 右边的表，而 <code>LEFT</code> 指出的是 <code>OUTER JOIN</code><br>左边的表</li><li>SQLite 只支持 <code>LEFT OUTER JOIN</code></li></ul></li><li>全外联结：检索两个表中<br>的所有行并关联那些可以关联的行<ul><li><code>FULL OUTER JOIN</code></li><li>Access、MariaDB、MySQL、Open Office Base 和 SQLite 不支持 <code>FULL   OUTER JOIN</code> 语法。</li></ul></li><li>使用带聚集函数的联结</li><li>使用联结和联结条件<ul><li>注意所使用的联结类型。一般我们使用内联结，但使用外联结也有效。</li><li>关于确切的联结语法，应该查看具体的文档，看相应的DBMS 支持何种语法（大多数DBMS 使用这两课中描述的某种语法）。</li><li>保证使用正确的联结条件（不管采用哪种语法），否则会返回不正确的数据。</li><li>应该总是提供联结条件，否则会得出笛卡儿积。</li><li>在一个联结中可以包含多个表，甚至可以对每个联结采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前分别测试每个联结。这会使故障排除更为简单。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- FROM 子句中的三个表全都有别名</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">AS</span> C, Orders <span class="keyword">AS</span> O, OrderItems <span class="keyword">AS</span> OI</span><br><span class="line"><span class="keyword">WHERE</span> C.cust_id <span class="operator">=</span> O.cust_id</span><br><span class="line">  <span class="keyword">AND</span> OI.order_num <span class="operator">=</span> O.order_num</span><br><span class="line">  <span class="keyword">AND</span> prod_id <span class="operator">=</span> <span class="string">&#x27;RGAN01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_id, cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> (<span class="keyword">SELECT</span> cust_name</span><br><span class="line">   <span class="keyword">FROM</span> Customers</span><br><span class="line">   <span class="keyword">WHERE</span> cust_contact <span class="operator">=</span> <span class="string">&#x27;Jim Jones&#x27;</span>);</span><br><span class="line"><span class="comment">-- 等同于上面，但使用自联结</span></span><br><span class="line"><span class="comment">-- 查询中需要的两个表实际上是相同的表，因此 Customers 表在 FROM 子句中出现了两次</span></span><br><span class="line"><span class="comment">-- 需要使用表别名</span></span><br><span class="line"><span class="keyword">SELECT</span> c1.cust_id, c1.cust_name, c1.cust_contact</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">AS</span> c1, Customers <span class="keyword">AS</span> c2</span><br><span class="line"><span class="keyword">WHERE</span> c1.cust_name <span class="operator">=</span> c2.cust_name</span><br><span class="line">  <span class="keyword">AND</span> c2.cust_contact <span class="operator">=</span> <span class="string">&#x27;Jim Jones&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自然联结</span></span><br><span class="line"><span class="keyword">SELECT</span> C.<span class="operator">*</span>, O.order_num, O.order_date,</span><br><span class="line">   OI.prod_id, OI.quantity, OI.item_price</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">AS</span> C, Orders <span class="keyword">AS</span> O, OrderItems <span class="keyword">AS</span> OI</span><br><span class="line"><span class="keyword">WHERE</span> C.cust_id <span class="operator">=</span> O.cust_id</span><br><span class="line">  <span class="keyword">AND</span> OI.order_num <span class="operator">=</span> O.order_num</span><br><span class="line">  <span class="keyword">AND</span> prod_id <span class="operator">=</span> <span class="string">&#x27;RGAN01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 内联结，检索所有顾客及其订单</span></span><br><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line">  <span class="keyword">ON</span> Customers.cust_id <span class="operator">=</span> Orders.cust_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 外联结</span></span><br><span class="line"><span class="comment">-- 从左边的表中选择所有行</span></span><br><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line">  <span class="keyword">ON</span> Customers.cust_id <span class="operator">=</span> Orders.cust_id;</span><br><span class="line"><span class="comment">-- 从右边的表中选择所有行</span></span><br><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line">  <span class="keyword">ON</span> Orders.cust_id <span class="operator">=</span> Customers.cust_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 全外联结</span></span><br><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Orders <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Customers</span><br><span class="line">  <span class="keyword">ON</span> Orders.cust_id <span class="operator">=</span> Customers.cust_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用带聚集函数的联结</span></span><br><span class="line"><span class="comment">-- 检索所有顾客及每个顾客所下的订单数</span></span><br><span class="line"><span class="keyword">SELECT</span> Customers.cust_id,</span><br><span class="line"><span class="built_in">COUNT</span>(Orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id <span class="operator">=</span> Orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Customers.cust_id;</span><br></pre></td></tr></table></figure><h1>组合查询</h1><ul><li>多数 SQL 查询只包含从一个或多个表中返回数据的单条 <code>SELECT</code> 语句</li><li>SQL 也允许执行多个查询（多条 <code>SELECT</code> 语句），并将结果作为一个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）</li><li>主要有两种情况需要使用组合查询：<ul><li>在一个查询中从不同的表返回结构数据</li><li>对一个表执行多个查询，按一个查询返回数据（等同于具有多个 <code>WHERE</code><br>子句的查询）</li></ul></li><li>创建组合查询<ul><li>可用 <code>UNION</code> 操作符来组合数条SQL 查询</li><li>给出每条 <code>SELECT</code> 语句，在各条语句之间放上关键字 <code>UNION</code></li></ul></li><li><code>UNION</code> 必须由两条或两条以上的 <code>SELECT</code> 语句组成，语句之间用关键字 <code>UNION</code> 分隔（因此，如果组合四条``SELECT<code>语句，将要使用三个</code>UNION`<br>关键字）。</li><li><code>UNION</code> 中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）。</li><li>列数据类型必须兼容：类型不必完全相同，但必须是 DBMS 可以隐含转换的类型（例如，不同的数值类型或不同的日期类型）。</li><li><code>UNION</code> 从查询结果集中自动去除了重复的行</li><li>如果想返回所有的匹配行，可使用 <code>UNION ALL</code> 而不是 <code>UNION</code></li><li>对组合查询结果排序:<ul><li>在用 <code>UNION</code> 组合查询时，只能使用一条 <code>ORDER BY</code> 子句，它必须位于最后一条 <code>SELECT</code> 语句之后</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 几个州的所有顾客</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="keyword">IN</span> (<span class="string">&#x27;IL&#x27;</span>,<span class="string">&#x27;IN&#x27;</span>,<span class="string">&#x27;MI&#x27;</span>);</span><br><span class="line"><span class="comment">-- 所有的Fun4All</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Fun4All&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 组合查询</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="keyword">IN</span> (<span class="string">&#x27;IL&#x27;</span>,<span class="string">&#x27;IN&#x27;</span>,<span class="string">&#x27;MI&#x27;</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Fun4All&#x27;</span>;</span><br><span class="line"><span class="comment">-- 等同于</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact, cust_email</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_state <span class="keyword">IN</span> (<span class="string">&#x27;IL&#x27;</span>,<span class="string">&#x27;IN&#x27;</span>,<span class="string">&#x27;MI&#x27;</span>)</span><br><span class="line">   <span class="keyword">OR</span> cust_name <span class="operator">=</span> <span class="string">&#x27;Fun4All&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><blockquote><p>SQL 必知必会 - 全书目录</p><ol><li>第 01 - 10 章：<a href="/p/57d19b2c">SQL 必知必会 - 单表查询/过滤/汇总</a></li><li>第 11 - 24 章：<a href="/p/4c50c6b4">SQL 必知必会 - 多表查询/联结/组合</a></li><li>第 15 - 24 章：<a href="/p/3b57f622">SQL 必知必会 - 数据更新/存储/事务</a></li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;SQL 必知必会 - 全书目录&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第 01 - 10 章：&lt;a href=&quot;/p/57d19b2c&quot;&gt;SQL 必知必会 - 单表查询/过滤/汇总&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;第 11 - 24 章：&lt;a href=&quot;/p/4c50c6b4&quot;&gt;SQL 必知必会 - 多表查询/联结/组合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;第 15 - 24 章：&lt;a href=&quot;/p/3b57f622&quot;&gt;SQL 必知必会 - 数据更新/存储/事务&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="SQL" scheme="http://blog.czccc.cc/categories/SQL/"/>
    
    
    <category term="SQL" scheme="http://blog.czccc.cc/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL 必知必会 - 单表查询/过滤/汇总</title>
    <link href="http://blog.czccc.cc/p/57d19b2c/"/>
    <id>http://blog.czccc.cc/p/57d19b2c/</id>
    <published>2020-08-02T03:42:44.000Z</published>
    <updated>2022-08-06T13:07:33.621Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>SQL 必知必会 - 全书目录</p><ol><li>第 01 - 10 章：<a href="/p/57d19b2c">SQL 必知必会 - 单表查询/过滤/汇总</a></li><li>第 11 - 24 章：<a href="/p/4c50c6b4">SQL 必知必会 - 多表查询/联结/组合</a></li><li>第 15 - 24 章：<a href="/p/3b57f622">SQL 必知必会 - 数据更新/存储/事务</a></li></ol></blockquote><span id="more"></span><h1>基础</h1><ul><li>SQL（发音为字母 S-Q-L 或 sequel）是 Structured Query Language（结构化查询语言）的缩写</li><li>SQL 是一种专门用来与数据库沟通的语言</li><li>标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL</li><li>数据库（database）: 保存有组织的数据的容器（通常是一个文件或一组文件）</li><li>数据库软件应称为数据库管理系统（DBMS）</li><li>表（table）: 某种特定类型数据的结构化清单</li><li>模式（schema）: 关于数据库和表的布局及特性的信息</li><li>列（column）: 表中的一个字段, 所有表都是由一个或多个列组成的</li><li>行（row）: 表中的一个记录, 有时也称其为数据库记录（record）</li><li>数据类型: 所允许的数据的类型. 每个表列都有相应的数据类型, 它限制（或允许）该列中存储的数据</li><li>主键（primary key）: 一列（或一组列）, 其值能够唯一标识表中每一行</li><li>表中的任何列都可以作为主键，只要它满足以下条件：<ul><li>任意两行都不具有相同的主键值</li><li>每一行都必须具有一个主键值（主键列不允许 <code>NULL</code> 值）</li><li>主键列中的值不允许修改或更新</li><li>主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）</li></ul></li></ul><h1>检索数据 - <code>SELECT</code></h1><ul><li>每句 SQL 语句都建议使用 <code>;</code> 结尾; 所有空格会被忽略</li><li>行内注释使用 <code>--</code> 或 <code>#</code> (一般不使用), 多行注释使用 <code>/* ... */</code></li><li>在<strong>不指定排序</strong>的情况下, 输出没有特定的顺序</li><li>SQL 语句<strong>不区分大小写</strong>, 但习惯上对 SQL 的关键词使用大写, 对列名和表名使用小写</li><li>使用 <code>DISTINCT</code> 去重输出不同的值, 作用于所有的列</li><li>限制输出的结果数目:<ul><li>SQL Server, Access: 使用 <code>TOP</code> 关键字</li><li>DB2: <code>FETCH FIRST 5 ROWS ONLY;</code></li><li>Oracle: <code>WHERE ROWNUM &lt;=5;</code></li><li>MySQL, MariaDB, PostgreSQL, SQLite: <code>LIMIT</code> 子句和 <code>OFFSET</code> 子句</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检索单个列</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> Products;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检索多个列</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name, prod_price <span class="keyword">FROM</span> Products;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检索所有列, 由于检索不需要的列, 会影响性能</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Products;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 去重输出, 在指定多个列时, 除非指定的两列完全相同，否则所有的行都会被检索出来</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id <span class="keyword">FROM</span> Products;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 限制输出结果, 不同的数据库实现方式不同</span></span><br><span class="line"><span class="comment">-- SQL Server, Access</span></span><br><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">5</span> prod_name <span class="keyword">FROM</span> Products;</span><br><span class="line"><span class="comment">-- DB2</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> Products <span class="keyword">FETCH</span> <span class="keyword">FIRST</span> <span class="number">5</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br><span class="line"><span class="comment">-- Oracle</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> Products <span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span><span class="number">5</span>;</span><br><span class="line"><span class="comment">-- MySQL, MariaDB, PostgreSQL, SQLite</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> Products LIMIT <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> Products LIMIT <span class="number">5</span> <span class="keyword">OFFSET</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- MySQL, MariaDB: LIMIT 3 OFFSET 4 可简写为 LIMIT 4, 3</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name <span class="keyword">FROM</span> Products LIMIT <span class="number">5</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h1>排序检索数据 - <code>ORDER BY</code></h1><ul><li>在指定一条 <code>ORDER BY</code> 子句时，应该保证它是 <code>SELECT</code> 语句中最后一条子句</li><li>可以使用<strong>未检索的列</strong>进行排序</li><li>支持按<strong>相对列位置</strong>, 此时不能使用未检索的列进行排序</li><li>默认为 <code>ASC</code> 或 <code>ASCENDING</code> 升序排序, 降序排序使用 <code>DESC</code> 或 <code>DESCENDING</code></li><li><code>DESC</code> 关键字只应用到直接位于其前面的列名, 指定多个列时, <strong>每个列</strong>都需要 <code>DESC</code> 关键字</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 先按 prod_price, 再按 prod_name 进行排序</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price, prod_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等同于上个例子</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 先按 prod_price 降序排序, 再按 prod_name 升序排序</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>, prod_name;</span><br></pre></td></tr></table></figure><h1>过滤数据 - <code>WHERE</code></h1><ul><li>使用 <code>SELECT</code> 语句的 <code>WHERE</code> 子句指定搜索条件</li><li><code>WHERE</code> 语句支持的操作符如下图, 注意某些操作符是冗余的, 具体支持参阅对应的数据库软件实现</li><li><code>BETWEEN</code> 操作符需要两个值，即范围的<strong>开始值</strong>和<strong>结束值</strong></li><li><code>BETWEEN</code> 匹配范围中所有的值，<strong>包括</strong>指定的开始值和结束值</li><li>空值检查: 特殊的 <code>WHERE</code> 子句: <code>IS NULL</code> 子句</li><li><code>NULL</code> 和非匹配: 在进行匹配过滤或非匹配过滤时, 不会返回值为 <code>NULL</code> 的行。</li></ul><p><img src="https://s1.ax1x.com/2020/08/02/aJcuqA.png" alt="WHERE 子句操作符"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一些常用的例子</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">=</span> <span class="number">3.49</span>;</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&lt;</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&lt;=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">&lt;&gt;</span> <span class="string">&#x27;DLL01&#x27;</span>;</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">!=</span> <span class="string">&#x27;DLL01&#x27;</span>;</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><h1>高级数据过滤 - <code>AND/OR/IN/NOT</code></h1><ul><li><code>SQL</code> 允许给出多个 <code>WHERE</code> 子句, 以 <code>AND</code> 子句或 <code>OR</code> 子句的方式使用</li><li><code>AND</code> 操作符用来指示检索<strong>匹配所有给定条件</strong>的行</li><li><code>OR</code> 操作符用来指示检索<strong>匹配任一条件</strong>的行</li><li>支持短路求值, <code>AND</code> 的优先级比 <code>OR</code> 高, 可使用<strong>圆括号</strong> <code>()</code> 手动指定优先级</li><li><code>IN</code> 操作符用来<strong>指定条件范围</strong>，范围中的每个条件都可以进行匹配<ul><li>等同于 <code>OR</code> 操作符, 但 <code>IN</code> 操作符的语法更清楚，更直观。</li><li>在与其他 <code>AND</code> 和 <code>OR</code> 操作符组合使用 <code>IN</code> 时，求值顺序更容易管理</li><li><code>IN</code> 操作符一般比一组 <code>OR</code> 操作符执行得更快</li><li><code>IN</code> 的最大优点是可以包含其他 <code>SELECT</code> 语句，能够更动态地建立 <code>WHERE</code> 子句。</li></ul></li><li><code>NOT</code> 操作符<strong>否定其后所跟的任何条件</strong>, 总是与其他操作符一起使用<ul><li>部分场景下也可用 <code>&lt;&gt;</code> 操作符来替代</li><li>在更复杂的子句中, <code>NOT</code> 是非常有用的</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">AND</span> prod_price <span class="operator">&lt;=</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span> <span class="keyword">OR</span> vend_id <span class="operator">=</span> <span class="string">&#x27;BRS01&#x27;</span>;</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> ( <span class="string">&#x27;DLL01&#x27;</span>, <span class="string">&#x27;BRS01&#x27;</span> )</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span></span><br></pre></td></tr></table></figure><h1>用通配符进行过滤 - <code>LIKE/%_[^]</code></h1><ul><li>利用通配符，可以创建<strong>比较特定数据</strong>的搜索模式, 用来匹配值的一部分</li><li>通配符搜索<strong>只能用于文本字段(字符串)</strong>, 非文本数据类型字段不能使用通配符搜索</li><li>百分号 <code>%</code> 通配符: 表示<strong>任何字符出现任意次数</strong><ul><li>Microsoft Access 中需要使用 <code>*</code></li><li>是否区分大小写与数据库有关</li><li>能匹配 0 个字符, 代表搜索模式中给定位置的 0 个、1 个或多个字符</li><li>许多 DBMS 都用空格来填补字段的内容, 使用 <code>%</code> 时需要考虑末尾填充的空格</li><li><code>%</code> 不会匹配产品名称为 <code>NULL</code> 的行</li></ul></li><li>下划线 <code>_</code> 通配符: <strong>只匹配单个字符</strong><ul><li>DB2 不支持通配符 <code>_</code>, Microsoft Access中需要使用 <code>?</code></li></ul></li><li>方括号 <code>[]</code> 通配符: 匹配方括号中任意单个字符<ul><li>不是所有 DBMS 都支持用来创建集合的 <code>[]</code></li><li>可以用 <strong>前缀字符</strong> <code>^</code>（脱字号）来否定</li><li>Microsoft Access 中需要用 <code>!</code> 来否定</li></ul></li><li>通配符搜索一般比前面讨论的其他搜索要耗费更长的处理时间<ul><li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li><li>在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。</li><li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- %</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;Fish%&#x27;</span>;           <span class="comment">-- 所有以词 Fish 起头的产品</span></span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;%bean bag%&#x27;</span>;      <span class="comment">-- 所有包含 bean bag 的产品</span></span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;F%y&#x27;</span>;             <span class="comment">-- 所有以 F 起头, 以 y 结尾的产品</span></span><br><span class="line"><span class="comment">-- _</span></span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">&#x27;__ inch teddy bear&#x27;</span>;</span><br><span class="line"><span class="comment">-- []</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_contact</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_contact <span class="keyword">LIKE</span> <span class="string">&#x27;[JM]%&#x27;</span>         <span class="comment">-- 所有名字以 J 或 M 起头的联系人</span></span><br><span class="line"><span class="keyword">WHERE</span> cust_contact <span class="keyword">LIKE</span> <span class="string">&#x27;[^JM]%&#x27;</span>        <span class="comment">-- 所有名字不以 J 或 M 起头的联系人</span></span><br></pre></td></tr></table></figure><h1>创建计算字段 - <code>AS/+||</code></h1><ul><li>拼接字段: 将值联结到一起（将一个值附加到另一个值）构成单个值。<ul><li>Access 和 SQL Server 使用 <code>+</code> 号</li><li>DB2, Oracle, PostgreSQL, SQLite 和 Open Office Base 使用 <code>||</code></li><li>MySQL 和 MariaDB 中使用特殊的函数 <code>Concat</code></li></ul></li><li>使用别名: 用 <code>AS</code> 关键字<ul><li>有时也称为导出列 (derived column)</li></ul></li><li>执行算术计算: 支持 <code>+-*/</code><ul><li>圆括号可用来区分优先顺序</li><li>省略了 <code>FROM</code> 子句后就是简单地访问和处理表达式</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 拼接字段, 使用别名</span></span><br><span class="line"><span class="comment">-- RTRIM() 函数去掉值右边的所有空格, 还有 LTRIM(), TRIM()</span></span><br><span class="line"><span class="keyword">SELECT</span> RTRIM(vend_name) <span class="operator">+</span> <span class="string">&#x27; (&#x27;</span> <span class="operator">+</span> RTRIM(vend_country) <span class="operator">+</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> RTRIM(vend_name) <span class="operator">||</span> <span class="string">&#x27; (&#x27;</span> <span class="operator">||</span> RTRIM(vend_country) <span class="operator">||</span> <span class="string">&#x27;)&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> Concat(RTRIM(vend_name), <span class="string">&#x27; (&#x27;</span>, RTRIM(vend_country), <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    <span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行算术计算</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_id,</span><br><span class="line">       quantity,</span><br><span class="line">       item_price,</span><br><span class="line">       quantity<span class="operator">*</span>item_price <span class="keyword">AS</span> expanded_price</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">20008</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 直接计算</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">3</span> <span class="operator">*</span> <span class="number">2</span>;           <span class="comment">-- 6</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">Trim</span>(<span class="string">&#x27; abc &#x27;</span>);   <span class="comment">-- &#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> Now();           <span class="comment">-- 当前日期和时间</span></span><br></pre></td></tr></table></figure><h1>使用函数处理数据 - 函数</h1><ul><li>只有少数几个函数被所有主要的 DBMS 等同地支持</li><li>与 SQL 语句不一样, SQL 函数不是可移植的</li><li>大多数 SQL 实现支持以下类型的函数<ul><li>用于处理文本字符串（如删除或填充值，转换值为大写或小写）的文本函数<ul><li><code>SOUNDEX()</code> 是一个将任何文本串转换为描述其语音表示的字母数字模式的算法</li></ul></li><li>用于在数值数据上进行算术操作（如返回绝对值，进行代数运算）的数值函数</li><li>用于处理日期和时间值并从这些值中提取特定成分（如返回两个日期之差，检查日期有效性）的日期和时间函数</li><li>返回 DBMS 正使用的特殊信息（如返回用户登录信息）的系统函数</li></ul></li></ul><p><img src="https://s1.ax1x.com/2020/08/02/aYGtIA.png" alt="DBMS 函数的差异"></p><p><img src="https://s1.ax1x.com/2020/08/02/aYG4MT.png" alt="常用的文本处理函数"></p><p><img src="https://s1.ax1x.com/2020/08/02/aYYdu8.png" alt="常用数值处理函数"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 SOUNDEX() 函数进行搜索, 匹配所有发音类似于 Michael Green 的联系名：</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">WHERE</span> SOUNDEX(cust_contact) <span class="operator">=</span> SOUNDEX(<span class="string">&#x27;Michael Green&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检索 2012 年的所有订单</span></span><br><span class="line"><span class="keyword">SELECT</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">WHERE</span> DATEPART(yy, order_date) <span class="operator">=</span> <span class="number">2012</span>;      <span class="comment">-- SQL Server</span></span><br><span class="line"><span class="keyword">WHERE</span> DATEPART(<span class="string">&#x27;yyyy&#x27;</span>, order_date) <span class="operator">=</span> <span class="number">2012</span>;  <span class="comment">-- Access</span></span><br><span class="line"><span class="keyword">WHERE</span> DATE_PART(<span class="string">&#x27;year&#x27;</span>, order_date) <span class="operator">=</span> <span class="number">2012</span>; <span class="comment">-- PostgreSQL</span></span><br><span class="line"><span class="keyword">WHERE</span> to_number(to_char(order_date, <span class="string">&#x27;YYYY&#x27;</span>)) <span class="operator">=</span> <span class="number">2012</span>;   <span class="comment">-- Oracle</span></span><br><span class="line"><span class="keyword">WHERE</span> order_date <span class="keyword">BETWEEN</span> to_date(<span class="string">&#x27;01-01-2012&#x27;</span>)</span><br><span class="line">      <span class="keyword">AND</span> to_date(<span class="string">&#x27;12-31-2012&#x27;</span>);            <span class="comment">-- Oracle</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(order_date) <span class="operator">=</span> <span class="number">2012</span>;              <span class="comment">-- MySQL, MariaDB</span></span><br><span class="line"><span class="keyword">WHERE</span> strftime(<span class="string">&#x27;%Y&#x27;</span>, order_date) <span class="operator">=</span> <span class="string">&#x27;2012&#x27;</span>;  <span class="comment">-- SQLite</span></span><br></pre></td></tr></table></figure><h1>汇总数据 - 聚集函数</h1><ul><li>聚集函数: 汇总数据而不用把它们实际检索出来</li><li><code>AVG()</code> 只能用来确定特定数值列的平均值, 而且列名必须作为函数参数给出<ul><li>只用于单个列</li><li>忽略列值为 <code>NULL</code> 的行</li></ul></li><li><code>COUNT()</code> 确定表中行的数目或符合特定条件的行的数目<ul><li><code>COUNT(*)</code> 对表中行的数目进行计数，不管表列中包含的是空值（<code>NULL</code>）还是非空值</li><li><code>COUNT(column)</code> 对特定列中具有值的行进行计数，忽略 <code>NULL</code> 值。</li></ul></li><li><code>MAX()</code> / <code>MIN()</code> 返回指定列中的最大/小值, 要求指定列名, 忽略列值为 <code>NULL</code> 的行<ul><li>允许将它用来返回任意列中的最大/小值</li></ul></li><li><code>SUM()</code> 用来返回指定列值的和（总计）, 忽略列值为 <code>NULL</code> 的行。</li><li>聚集不同值:<ul><li>对所有行执行计算，指定 <code>ALL</code> 参数或不指定参数（因为 <code>ALL</code> 是默认行为）。</li><li>只包含不同的值，指定 <code>DISTINCT</code> 参数。</li><li><code>DISTINCT</code> 必须使用列名, 只能用于 <code>COUNT()</code>, <code>DISTINCT</code> 不能用于 <code>COUNT(*)</code></li></ul></li><li>组合聚集函数</li></ul><p><img src="https://s1.ax1x.com/2020/08/02/aYNuwD.png" alt="SQL 聚集函数"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计算平均值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(prod_price) <span class="keyword">AS</span> avg_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检索客人数目</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_cust</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(cust_email) <span class="keyword">AS</span> num_cust</span><br><span class="line"><span class="keyword">FROM</span> Customers;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检索最高/低单价</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(prod_price) <span class="keyword">AS</span> max_price</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(prod_price) <span class="keyword">AS</span> min_price</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算总的订单金额</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(item_price<span class="operator">*</span>quantity) <span class="keyword">AS</span> total_price</span><br><span class="line"><span class="keyword">FROM</span> OrderItems</span><br><span class="line"><span class="keyword">WHERE</span> order_num <span class="operator">=</span> <span class="number">20005</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 特定供应商提供的产品的平均价格, 只考虑各个不同的价格</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(<span class="keyword">DISTINCT</span> prod_price) <span class="keyword">AS</span> avg_price</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> <span class="string">&#x27;DLL01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 同时使用多个聚集函数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)        <span class="keyword">AS</span> num_items,</span><br><span class="line">       <span class="built_in">MIN</span>(prod_price) <span class="keyword">AS</span> price_min,</span><br><span class="line">       <span class="built_in">MAX</span>(prod_price) <span class="keyword">AS</span> price_max,</span><br><span class="line">       <span class="built_in">AVG</span>(prod_price) <span class="keyword">AS</span> price_avg</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure><h1>分组数据 - <code>GROUP BY/HAVING</code></h1><ul><li>使用分组可以将数据分为多个逻辑组, 对每个组进行聚集计算</li><li>创建分组: 使用 <code>SELECT</code> 语句的 <code>GROUP BY</code> 子句<ul><li>可以包含任意数目的列，因而可以对分组进行嵌套</li><li>如果在 <code>GROUP BY</code> 子句中嵌套了分组，数据将在最后指定的分组上进行汇总</li><li>列出的每一列都必须是检索列或有效的表达式, 不能使用别名</li><li>大多数 SQL 实现不允许 <code>GROUP BY</code> 列带有长度可变的数据类型</li><li><strong>除聚集计算语句外</strong>，<code>SELECT</code> 语句中的每一列都必须在 <code>GROUP BY</code> 子句中给出</li><li>如果分组列中包含具有 <code>NULL</code> 值的行，则 <code>NULL</code> 将作为一个分组返回. 如果列中有多行 <code>NULL</code> 值，它们将分为一组</li><li><code>GROUP BY</code> 子句必须出现在 <code>WHERE</code> 子句之后，<code>ORDER BY</code> 子句之前</li></ul></li><li>过滤分组: <code>HAVING</code> 子句<ul><li><code>WHERE</code> 过滤指定的是行, <code>HAVING</code> 过滤指定的是分组</li><li><code>HAVING</code> 支持所有 <code>WHERE</code> 操作符</li><li><code>WHERE</code> 在数据分组前进行过滤, <code>HAVING</code> 在数据分组后进行过滤</li><li><code>WHERE</code> 排除的行不包括在分组中, 这可能会改变计算值, 从而影响 <code>HAVING</code> 子句中基于这些值过滤掉的分组</li><li>如果不指定 <code>GROUP BY</code>, 则大多数 DBMS 会同等对待它们</li></ul></li><li>分组和排序<ul><li>一般在使用 <code>GROUP BY</code> 子句时, 应该也给出 <code>ORDER BY</code> 子句</li><li>这是保证数据正确排序的唯一方法, 千万不要仅依赖 <code>GROUP BY</code> 排序数据</li></ul></li></ul><p><img src="https://s1.ax1x.com/2020/08/02/atNuVS.png" alt="ORDER BY 与 GROUP BY"></p><p><img src="https://s1.ax1x.com/2020/08/02/atNJK0.png" alt="SELECT 子句及其顺序"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- GROUP BY 子句指示 DBMS 按 vend_id 排序并分组数据</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 过滤出 COUNT(*) &gt;= 2（两个以上订单）的那些分组</span></span><br><span class="line"><span class="comment">-- 在这里无法使用 WHERE 语句, 因为过滤是基于分组聚集值, 而不是特定行的值</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cust_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列出具有两个以上产品且其价格都大于等于 4 的供应商</span></span><br><span class="line"><span class="comment">-- WHERE 子句过滤所有 prod_price 至少为4 的行</span></span><br><span class="line"><span class="comment">-- 然后按 vend_id 分组数据, HAVING 子句过滤计数为 2 或 2 以上的分组。</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&gt;=</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><hr><blockquote><p>SQL 必知必会 - 全书目录</p><ol><li>第 01 - 10 章：<a href="/p/57d19b2c">SQL 必知必会 - 单表查询/过滤/汇总</a></li><li>第 11 - 24 章：<a href="/p/4c50c6b4">SQL 必知必会 - 多表查询/联结/组合</a></li><li>第 15 - 24 章：<a href="/p/3b57f622">SQL 必知必会 - 数据更新/存储/事务</a></li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;SQL 必知必会 - 全书目录&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第 01 - 10 章：&lt;a href=&quot;/p/57d19b2c&quot;&gt;SQL 必知必会 - 单表查询/过滤/汇总&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;第 11 - 24 章：&lt;a href=&quot;/p/4c50c6b4&quot;&gt;SQL 必知必会 - 多表查询/联结/组合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;第 15 - 24 章：&lt;a href=&quot;/p/3b57f622&quot;&gt;SQL 必知必会 - 数据更新/存储/事务&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="SQL" scheme="http://blog.czccc.cc/categories/SQL/"/>
    
    
    <category term="SQL" scheme="http://blog.czccc.cc/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>改装 PowerShell</title>
    <link href="http://blog.czccc.cc/p/90941d95/"/>
    <id>http://blog.czccc.cc/p/90941d95/</id>
    <published>2020-04-24T04:36:35.000Z</published>
    <updated>2022-08-06T13:07:33.624Z</updated>
    
    <content type="html"><![CDATA[<hr><p>作为 Windows 下的终端, PowerShell 一直以来都显得不太好用, 简陋的背景, 不好看的字体, 难用的命令.</p><p>而 PowerShell 事实上还算一款较为强大的命令行工具, 今天就来将其改装成为真正的生产力工具.</p><p>主要涉及: 字体, 颜色, 终端, <code>oh-my-posh</code>, <code>PSReadLine</code></p><span id="more"></span><h1>首先从外表开始</h1><h2 id="更改终端字体">更改终端字体</h2><p>Windows 下的字体总是显得简陋, 当然这是由于历史包袱严重, 难以直接更改, 也因此出现了一系列修改字体的工具, 如 <code>MacType</code>, 但是使用工具修改字体具有一定的风险性.</p><p>更加安全一点的方案是使用特制的字体, 比如这款: <a target="_blank" rel="noopener" href="https://github.com/be5invis/Sarasa-Gothic"><code>Sarasa Gothic/更纱黑体/更紗黑體/更紗ゴシック/사라사 고딕</code></a></p><p>在 <a target="_blank" rel="noopener" href="https://github.com/be5invis/Sarasa-Gothic/releases">Release</a> 中下载最新版, 可以选择只安装简体中文版, 即包含 <code>SC</code> 的字体.</p><blockquote><p>Windows 选择 ttf 文件即可, 本文撰写时最新版为 <a target="_blank" rel="noopener" href="https://github.com/be5invis/Sarasa-Gothic/releases/download/v0.12.5/sarasa-gothic-ttf-0.12.5.7z">sarasa-gothic-ttf-0.12.5.7z</a></p></blockquote><p>Windows 控制台在中文系统下, 默认是新宋体, 显示效果很差, 将其更改为刚安装的更纱黑体, 这里选择的是 <code>Sarasa Term SC</code>, 字号为 20:</p><blockquote><p>如果找不到对应的字体, 或是更改之后没有发生变化, 可能是因为默认代码页为 <code>GBK</code>, 可以尝试更改代码页到 <code>UTF-8</code>:<br><code>chcp 65001</code><br>然后再进行尝试.</p></blockquote><p><img src="https://s1.ax1x.com/2020/04/24/JBtNRJ.png" alt=""></p><p>然后就能发现 PowerShell 已经有了明显的变化.</p><h2 id="更改终端配色">更改终端配色</h2><p>PowerShell 的默认蓝底白字配色也有点丑陋.</p><p>微软官方提供了一个更换 PowerShell 配色的小工具：<a target="_blank" rel="noopener" href="https://github.com/Microsoft/console/tree/master/tools/ColorTool">ColorTool.exe</a>，我们可以利用它来更换 PowerShell 的主题颜色。ColorTool 支持 iTerm 主题（以 <code>.itermcolors</code> 结尾的主题文件）。</p><p>我们可以从 <a target="_blank" rel="noopener" href="https://github.com/Microsoft/console/releases">ColorTool 的 GitHub 页面</a> 下载这个小工具。当然，如果你使用 <a target="_blank" rel="noopener" href="https://sspai.com/post/52496">Scoop</a>，也可以这样安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install colortool</span><br></pre></td></tr></table></figure><p>值得注意的是，如果你是直接从 GitHub 上面下载了 <code>colortool.zip</code> 并解压，<code>colortool.exe</code> 的路径就并没有自动加入环境变量，所以你没有办法全局调用这个工具。因此我更加推荐利用 Scoop 这个优质的包管理来安装 ColorTool。</p><p><strong>推荐阅读：</strong><a target="_blank" rel="noopener" href="https://sspai.com/post/52496">「一行代码」搞定软件安装卸载，用 Scoop 管理你的 Windows 软件</a></p><p>ColorTool 使用非常简单。工具自带了几种主题，我们可以利用下面这个命令进行查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 注：-s 代表 schemes</span><br><span class="line">colortool -s</span><br></pre></td></tr></table></figure><p><img src="https://cdn.sspai.com/2019/02/12/079538cec907de93a90b70a027200297.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="几个自带配色主题"></p><p>其中前面列出的几个 <code>.ini</code> 和 <code>.itermcolors</code> 就是主题配置文件，我们可以直接通过下面这个命令设置主题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 临时查看</span><br><span class="line">colortool &lt;主题名称&gt;</span><br><span class="line"># 定义默认值</span><br><span class="line">colortool -d &lt;主题名称&gt;</span><br></pre></td></tr></table></figure><p>比如我们希望将主题配色更换为 <code>OneHalfDark.itermcolors</code>，只需要输入下面这个命令就可以更换并预览更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colortool OneHalfDark</span><br></pre></td></tr></table></figure><p><img src="https://cdn.sspai.com/2019/02/12/a969328f28e108ec6b84056e22a8f410.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="更换主题"></p><p>由于 ColorTool 直接支持 iTerm 主题配置文件，因此我们可以在 <a target="_blank" rel="noopener" href="https://iterm2colorschemes.com/">iterm2colorschemes</a> 这个网站找到我们想要的主题背景进行配置，方法和上面介绍的一样：在 PowerShell 中定位至你希望更换的主题文件，使用命令 <code>colortool &lt;主题名称&gt;.itermcolors</code> 进行配置即可。同时，如果你对上面的主题都不满意，你也可以直接在这个网站： <a target="_blank" rel="noopener" href="https://terminal.sexy/">terminal.sexy</a> 自行配置自己想要的主题，并通过同样的方式进行应用。</p><p>不过从 <a target="_blank" rel="noopener" href="https://github.com/mbadolato/iTerm2-Color-Schemes">iTerm2 Color Schemes</a> 的配色方案实在是太多了，选起来本身也是个麻烦事，我最后在这几款中选出了下面这几款配色，感觉还不错，推荐给大家：</p><ul><li><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/mbadolato/iTerm2-Color-Schemes/master/schemes/ayu.itermcolors">ayu</a></li><li><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/mbadolato/iTerm2-Color-Schemes/master/schemes/Molokai.itermcolors">Molokai</a></li><li><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/mbadolato/iTerm2-Color-Schemes/master/schemes/Cobalt2.itermcolors">Cobalt2</a></li><li><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/mbadolato/iTerm2-Color-Schemes/master/schemes/Pandora.itermcolors">Pandora</a></li><li><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/mbadolato/iTerm2-Color-Schemes/master/schemes/Thayer%20Bright.itermcolors">ThayerBright</a></li><li><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/mbadolato/iTerm2-Color-Schemes/master/schemes/Symfonic.itermcolors">Symfonic</a></li><li><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/mbadolato/iTerm2-Color-Schemes/master/schemes/Red%20Sands.itermcolors">RedSands</a></li><li><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/mbadolato/iTerm2-Color-Schemes/master/schemes/Mathias.itermcolors">Mathias</a></li></ul><h1>添加效率工具</h1><h2 id="配置文件路径">配置文件路径</h2><p>PowerShell 的配置文件一般都在 <code>$HOME\Documents\WindowsPowerShell</code> 目录下, 并且可能会存在多个 <code>.ps1</code> 文件</p><ul><li><code>Microsoft.PowerShell_profile.ps1</code>: 这个是 PowerShell 终端的配置文件, 在这里更改的设置只会在系统自带的 PowerShell 终端中生效, 在其他位置, 比如 VS Code, Cmder 中不会生效.</li><li><code>Microsoft.VSCode_profile.ps1</code>: 和上面同理, 不过是在 <code>VS Code</code> 中生效.</li><li><code>profile.ps1</code>: 这个是 PowerShell 的全局配置文件, 在多个位置都会生效.</li></ul><p>新增（或修改）你的 PowerShell 配置文件 <code>Microsoft.PowerShell_profile.ps1</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 如果之前没有配置文件，就新建一个 PowerShell 配置文件</span><br><span class="line">if (!(Test-Path -Path $PROFILE )) &#123; New-Item -Type File -Path $PROFILE -Force &#125;</span><br><span class="line"></span><br><span class="line"># 用记事本打开配置文件</span><br><span class="line">notepad $PROFILE</span><br></pre></td></tr></table></figure><h2 id="PSReadLine">PSReadLine</h2><p>PowerShell 无法开箱即用的另一个原因是命令补全和历史搜索功能很差劲. 官方维护的有一个 <a target="_blank" rel="noopener" href="https://github.com/PowerShell/PSReadLine">PSReadLine</a> 项目, 用于实现类似于 Linux 下 Bash 的命令补全功能.</p><p>官方推荐使用 <code>PowerShellGet</code> 安装, 不过首先需要安装这个模块:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Module -Name PowerShellGet -Force</span><br></pre></td></tr></table></figure><p>之后通过 <code>PowerShellGet</code> 安装  <code>PSReadLine</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装最新版</span><br><span class="line">Install-Module PSReadLine -AllowPrerelease -Force</span><br><span class="line"></span><br><span class="line"># 安装稳定版</span><br><span class="line">Install-Module PSReadLine</span><br></pre></td></tr></table></figure><p>之后需要启动并配置 PSReadLine, 在配置文件中加入如下内容, 便可实现一个基本的 Shell 功能:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Import-Module PSReadLine</span><br><span class="line"></span><br><span class="line"># 历史命令搜索</span><br><span class="line">Set-PSReadLineOption -HistorySearchCursorMovesToEnd</span><br><span class="line">Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward</span><br><span class="line">Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward</span><br><span class="line"></span><br><span class="line"># 补全功能</span><br><span class="line">Set-PSReadLineKeyHandler -Key Ctrl+q -Function TabCompleteNext</span><br><span class="line">Set-PSReadLineKeyHandler -Key Ctrl+Q -Function TabCompletePrevious</span><br></pre></td></tr></table></figure><p>也可参考官方的样例 <a target="_blank" rel="noopener" href="https://github.com/PowerShell/PSReadLine/blob/master/PSReadLine/SamplePSReadLineProfile.ps1">SamplePSReadLineProfile.ps1</a> 实现自己想要的功能</p><h2 id="Oh-my-posh">Oh-my-posh</h2><p>和 Linux 下大名鼎鼎的 <code>oh-my-zsh</code> 类似, 针对于 PowerShell 也有对应的 <code>oh-my-posh</code>.</p><p>我们通过在 PowerShell 中执行下面的命令安装配置 <code>oh-my-posh</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Install-Module posh-git -Scope CurrentUser </span><br><span class="line">Install-Module oh-my-posh -Scope CurrentUser</span><br></pre></td></tr></table></figure><p>然后让 PowerShell 配置生效. 需要修改 PowerShell 配置文件, 在其中添加下面的内容:</p><figure class="highlight powershell"><figcaption><span>Microsoft.PowerShell_profile.ps1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Import-Module</span> posh<span class="literal">-git</span> </span><br><span class="line"><span class="built_in">Import-Module</span> <span class="built_in">oh</span><span class="literal">-my-posh</span> </span><br><span class="line"><span class="variable">$DefaultUser</span> = <span class="string">&#x27;Your User Name&#x27;</span></span><br><span class="line"><span class="built_in">Set-Theme</span> Agnoster</span><br></pre></td></tr></table></figure><p>其中最后一句 <code>Set-Theme &lt;主题名&gt;</code> 就是配置主题的命令。而 <code>$DefaultUser</code> 则可以用来隐藏用户名, 使 PowerShell 看起来更简洁.</p><p>如果一切顺利，你应该看到你的 Prompt 部分变成了类似这个的样子：</p><p><img src="https://s1.ax1x.com/2020/04/24/JBTI0I.png" alt=""></p><blockquote><p><strong>注意</strong>：如果你发现后面的日期显示出现了凌乱的现象（比如本该在同一行显示的字符却跑到了下一行），多半是因为显示了中文。目前很多终端都不能正常的显示中文或 CJK 字符（即：Double-width character），所以你可以通过下面这个命令将 PowerShell 的环境设置为 en-US 的英文环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Culture en-US</span><br></pre></td></tr></table></figure></blockquote><h1>Bug Fix</h1><h2 id="部分符号字体无法显示">部分符号字体无法显示</h2><p>如果你使用 <code>oh-my-posh</code>，并且在 <code>oh-my-posh</code> 里面配置了 PowerLine 命令提示符的话，你会发现，在进入 Git 目录时会看到命令提示符中有个“□”：</p><p><img src="https://coolcode.org/2018/03/16/how-to-make-your-powershell-beautiful/WSL1.png" alt="字体中的乱码"></p><p>这个是个表情符“✎”，但是因为 Sarasa 系列字体中不包含表情符，因此就只能显示乱码了。不过也有解决办法，打开注册表编辑器，找到路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink</span><br></pre></td></tr></table></figure><p>在其中新建多字符串值，名称为：<code>Sarasa Term SC</code>，内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MICROSS.TTF,Microsoft Sans Serif,108,122</span><br><span class="line">MICROSS.TTF,Microsoft Sans Serif</span><br><span class="line">MINGLIU.TTC,PMingLiU</span><br><span class="line">MSMINCHO.TTC,MS PMincho</span><br><span class="line">BATANG.TTC,Batang</span><br><span class="line">MSYH.TTC,Microsoft YaHei UI</span><br><span class="line">MSJH.TTC,Microsoft JhengHei UI</span><br><span class="line">YUGOTHM.TTC,Yu Gothic UI</span><br><span class="line">MALGUN.TTF,Malgun Gothic</span><br><span class="line">SEGUISYM.TTF,Segoe UI Symbol</span><br></pre></td></tr></table></figure><p>这段内容是复制的宋体 SimSun 的，如果你愿意的话，可以用同样的方法把 <code>Sarasa</code> 系列的都注册一下，也可以只修改要使用的这个，然后重启计算机就可以了。</p><h1>参考链接</h1><ul><li><a target="_blank" rel="noopener" href="https://sspai.com/post/52868">告别 Windows 终端的难看难用，从改造 PowerShell 的外观开始</a></li><li><a target="_blank" rel="noopener" href="https://sspai.com/post/52907">5 个 PowerShell 主题，让你的 Windows 终端更好看</a></li><li><a target="_blank" rel="noopener" href="https://coolcode.org/2018/03/16/how-to-make-your-powershell-beautiful">PowerShell 美化指南</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;作为 Windows 下的终端, PowerShell 一直以来都显得不太好用, 简陋的背景, 不好看的字体, 难用的命令.&lt;/p&gt;
&lt;p&gt;而 PowerShell 事实上还算一款较为强大的命令行工具, 今天就来将其改装成为真正的生产力工具.&lt;/p&gt;
&lt;p&gt;主要涉及: 字体, 颜色, 终端, &lt;code&gt;oh-my-posh&lt;/code&gt;, &lt;code&gt;PSReadLine&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Windows" scheme="http://blog.czccc.cc/categories/Windows/"/>
    
    
    <category term="Windows" scheme="http://blog.czccc.cc/tags/Windows/"/>
    
    <category term="PowerShell" scheme="http://blog.czccc.cc/tags/PowerShell/"/>
    
  </entry>
  
  <entry>
    <title>Vim 基本配置</title>
    <link href="http://blog.czccc.cc/p/e2b505f0/"/>
    <id>http://blog.czccc.cc/p/e2b505f0/</id>
    <published>2020-04-16T09:43:00.000Z</published>
    <updated>2022-08-06T13:07:33.625Z</updated>
    
    <content type="html"><![CDATA[<hr><span id="more"></span><h1>配置方式</h1><p>Vim 有许多种配置方式, 主要有:</p><ul><li>单次配置项 (命令模式下输入)</li><li>用户配置文件 <code>~/.vimrc</code></li><li>全局配置文件 <code>/etc/vim/vimrc</code> 或者 <code>/etc/vimrc</code></li></ul><p>单次配置项主要是通过在命令模式下，先输入一个冒号，再输入配置.</p><p>举例来说，<code>set number</code>这个配置可以写在<code>.vimrc</code>里面，也可以在命令模式输入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> number</span><br></pre></td></tr></table></figure><p>配置项一般都有&quot;打开&quot;和&quot;关闭&quot;两个设置。“关闭&quot;就是在&quot;打开&quot;前面加上前缀&quot;no”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; 打开</span></span><br><span class="line"><span class="string">set number</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 关闭</span><br><span class="line"><span class="built_in">set</span> nonumber</span><br></pre></td></tr></table></figure><p>上面代码中，双引号开始的行表示注释。</p><p>查询某个配置项是打开还是关闭，可以在命令模式下，输入该配置，并在后面加上问号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> number?</span><br></pre></td></tr></table></figure><p>上面的命令会返回<code>number</code>或者<code>nonumber</code>。</p><p>如果想查看帮助，可以使用<code>help</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">help</span> number</span><br></pre></td></tr></table></figure><h1>常用配置总览</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&quot; 行号相关</span><br><span class="line">set number          &quot; 行号 = nu</span><br><span class="line">set relativenumber  &quot; 显示相对行号</span><br><span class="line">set cursorline      &quot; 高亮当前行 = cul</span><br><span class="line">set cursorcolumn    &quot; 高亮当前列 = cul</span><br><span class="line">set textwidth=80    &quot; 行宽, 用于自动换行</span><br><span class="line">set wrap            &quot; 自动换行</span><br><span class="line">set linebreak       &quot; 换行不分割单词</span><br><span class="line"></span><br><span class="line">syntax on           &quot; 语法高亮</span><br><span class="line">set showmatch       &quot; 高亮对应括号</span><br><span class="line">set paste           &quot; 设置粘贴模式</span><br><span class="line">set nocompatible    &quot; 是否兼容 vi</span><br><span class="line">set showmode        &quot; 底部显示当前模式</span><br><span class="line">set showcmd         &quot; 底部显示当前命令</span><br><span class="line">set ruler           &quot; 显示光标位置</span><br><span class="line">set mouse=a         &quot; 支持鼠标操作</span><br><span class="line">set encoding=utf-8  &quot; 编码</span><br><span class="line">set t_Co=256        &quot; 启用256色</span><br><span class="line">set noerrorbells    &quot; 出错时不发出响声</span><br><span class="line">filetype indent on  &quot; 开启文件类型检查</span><br><span class="line"></span><br><span class="line">&quot; 缩进相关</span><br><span class="line">set autoindent      &quot; 自动缩进</span><br><span class="line">set tabstop=4       &quot; tab 表示的空格数</span><br><span class="line">set expandtab       &quot; tab 自动转空格</span><br><span class="line">set softtabstop=2   &quot; tab 转换的空格数</span><br><span class="line"></span><br><span class="line">&quot; 搜索高亮</span><br><span class="line">set hlsearch        &quot; 高亮搜索结果</span><br><span class="line">set incsearch       &quot; 自动跳转到第一个搜索结果</span><br><span class="line">set ignorecase      &quot; 搜索忽略大小写</span><br></pre></td></tr></table></figure><h1>基本配置</h1><p>（1）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> nocompatible</span><br></pre></td></tr></table></figure><p>不与 Vi 兼容（采用 Vim 自己的操作命令）。</p><p>（2）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syntax on</span><br></pre></td></tr></table></figure><p>打开语法高亮。自动识别代码，使用多种颜色显示。</p><p>（3）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> showmode</span><br></pre></td></tr></table></figure><p>在底部显示，当前处于命令模式还是插入模式。</p><p>（4）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> showcmd</span><br></pre></td></tr></table></figure><p>命令模式下，在底部显示，当前键入的指令。比如，键入的指令是<code>2y3d</code>，那么底部就会显示<code>2y3</code>，当键入<code>d</code>的时候，操作完成，显示消失。</p><p>（5）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> mouse=a</span><br></pre></td></tr></table></figure><p>支持使用鼠标。</p><p>（6）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> encoding=utf-8  </span><br></pre></td></tr></table></figure><p>使用 utf-8 编码。</p><p>（7）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> t_Co=256</span><br></pre></td></tr></table></figure><p>启用256色。</p><p>（8）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filetype indent on</span><br></pre></td></tr></table></figure><p>开启文件类型检查，并且载入与该类型对应的缩进规则。比如，如果编辑的是<code>.py</code>文件，Vim 就是会找 Python 的缩进规则<code>~/.vim/indent/python.vim</code>。</p><h1>缩进</h1><p>（9）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> autoindent</span><br></pre></td></tr></table></figure><p>按下回车键后，下一行的缩进会自动跟上一行的缩进保持一致。</p><p>（10）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> tabstop=2</span><br></pre></td></tr></table></figure><p>按下 Tab 键时，Vim 显示的空格数。</p><p>（11）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> shiftwidth=4</span><br></pre></td></tr></table></figure><p>在文本上按下<code>&gt;&gt;</code>（增加一级缩进）、<code>&lt;&lt;</code>（取消一级缩进）或者<code>==</code>（取消全部缩进）时，每一级的字符数。</p><p>（12）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> expandtab</span><br></pre></td></tr></table></figure><p>由于 Tab 键在不同的编辑器缩进不一致，该设置自动将 Tab 转为空格。</p><p>（13）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> softtabstop=2</span><br></pre></td></tr></table></figure><p>Tab 转为多少个空格。</p><h1>外观</h1><p>（14）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> number</span><br></pre></td></tr></table></figure><p>显示行号</p><p>（15）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> relativenumber</span><br></pre></td></tr></table></figure><p>显示光标所在的当前行的行号，其他行都为相对于该行的相对行号。</p><p>（16）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> cursorline</span><br></pre></td></tr></table></figure><p>光标所在的当前行高亮。</p><p>（17）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> textwidth=80</span><br></pre></td></tr></table></figure><p>设置行宽，即一行显示多少个字符。</p><p>（18）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> wrap</span><br></pre></td></tr></table></figure><p>自动折行，即太长的行分成几行显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> nowrap</span><br></pre></td></tr></table></figure><p>关闭自动折行</p><p>（19）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> linebreak</span><br></pre></td></tr></table></figure><p>只有遇到指定的符号（比如空格、连词号和其他标点符号），才发生折行。也就是说，不会在单词内部折行。</p><p>（20）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> wrapmargin=2</span><br></pre></td></tr></table></figure><p>指定折行处与编辑窗口的右边缘之间空出的字符数。</p><p>（21）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> scrolloff=5</span><br></pre></td></tr></table></figure><p>垂直滚动时，光标距离顶部/底部的位置（单位：行）。</p><p>（22）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> sidescrolloff=15</span><br></pre></td></tr></table></figure><p>水平滚动时，光标距离行首或行尾的位置（单位：字符）。该配置在不折行时比较有用。</p><p>（23）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> laststatus=2</span><br></pre></td></tr></table></figure><p>是否显示状态栏。0 表示不显示，1 表示只在多窗口时显示，2 表示显示。</p><p>（24）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>  ruler</span><br></pre></td></tr></table></figure><p>在状态栏显示光标的当前位置（位于哪一行哪一列）。</p><h1>搜索</h1><p>（25）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> showmatch</span><br></pre></td></tr></table></figure><p>光标遇到圆括号、方括号、大括号时，自动高亮对应的另一个圆括号、方括号和大括号。</p><p>（26）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> hlsearch</span><br></pre></td></tr></table></figure><p>搜索时，高亮显示匹配结果。</p><p>（27）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> incsearch</span><br></pre></td></tr></table></figure><p>输入搜索模式时，每输入一个字符，就自动跳到第一个匹配的结果。</p><p>（28）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> ignorecase</span><br></pre></td></tr></table></figure><p>搜索时忽略大小写。</p><p>（29）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> smartcase</span><br></pre></td></tr></table></figure><p>如果同时打开了<code>ignorecase</code>，那么对于只有一个大写字母的搜索词，将大小写敏感；其他情况都是大小写不敏感。比如，搜索<code>Test</code>时，将不匹配<code>test</code>；搜索<code>test</code>时，将匹配<code>Test</code>。</p><h1>编辑</h1><p>（30）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> spell spelllang=en_us</span><br></pre></td></tr></table></figure><p>打开英语单词的拼写检查。</p><p>（31）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> nobackup</span><br></pre></td></tr></table></figure><p>不创建备份文件。默认情况下，文件保存时，会额外创建一个备份文件，它的文件名是在原文件名的末尾，再添加一个波浪号（〜）。</p><p>（32）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> noswapfile</span><br></pre></td></tr></table></figure><p>不创建交换文件。交换文件主要用于系统崩溃时恢复文件，文件名的开头是<code>.</code>、结尾是<code>.swp</code>。</p><p>（33）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> undofile</span><br></pre></td></tr></table></figure><p>保留撤销历史。</p><p>Vim 会在编辑时保存操作历史，用来供用户撤消更改。默认情况下，操作记录只在本次编辑时有效，一旦编辑结束、文件关闭，操作历史就消失了。</p><p>打开这个设置，可以在文件关闭后，操作记录保留在一个文件里面，继续存在。这意味着，重新打开一个文件，可以撤销上一次编辑时的操作。撤消文件是跟原文件保存在一起的隐藏文件，文件名以<code>.un~</code>开头。</p><p>（34）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> backupdir=~/.vim/.backup//  </span><br><span class="line"><span class="built_in">set</span> directory=~/.vim/.swp//</span><br><span class="line"><span class="built_in">set</span> undodir=~/.vim/.undo// </span><br></pre></td></tr></table></figure><p>设置备份文件、交换文件、操作历史文件的保存位置。</p><p>结尾的<code>//</code>表示生成的文件名带有绝对路径，路径中用<code>%</code>替换目录分隔符，这样可以防止文件重名。</p><p>（35）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> autochdir</span><br></pre></td></tr></table></figure><p>自动切换工作目录。这主要用在一个 Vim 会话之中打开多个文件的情况，默认的工作目录是打开的第一个文件的目录。该配置可以将工作目录自动切换到，正在编辑的文件的目录。</p><p>（36）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> noerrorbells</span><br></pre></td></tr></table></figure><p>出错时，不要发出响声。</p><p>（37）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> visualbell</span><br></pre></td></tr></table></figure><p>出错时，发出视觉提示，通常是屏幕闪烁。</p><p>（38）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="built_in">history</span>=1000</span><br></pre></td></tr></table></figure><p>Vim 需要记住多少次历史操作。</p><p>（39）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> autoread</span><br></pre></td></tr></table></figure><p>打开文件监视。如果在编辑过程中文件发生外部改变（比如被别的编辑器编辑了），就会发出提示。</p><p>（40）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> listchars=tab:»■,trail:■</span><br><span class="line"><span class="built_in">set</span> list</span><br></pre></td></tr></table></figure><p>如果行尾有多余的空格（包括 Tab 键），该配置将让这些空格显示成可见的小方块。</p><p>（41）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> wildmenu</span><br><span class="line"><span class="built_in">set</span> wildmode=longest:list,full</span><br></pre></td></tr></table></figure><p>命令模式下，底部操作指令按下 Tab 键自动补全。第一次按下 Tab，会显示所有匹配的操作指令的清单；第二次按下 Tab，会依次选择各个指令。</p><h1>参考链接</h1><ul><li><a target="_blank" rel="noopener" href="https://opensource.com/article/18/9/vi-editor-productivity-powerhouse">Turn your vim editor into a productivity powerhouse</a></li><li><a target="_blank" rel="noopener" href="https://dougblack.io/words/a-good-vimrc.html">A Good Vimrc</a></li><li><a target="_blank" rel="noopener" href="http://vimdoc.sourceforge.net/htmldoc/options.html">Vim documentation: options</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="Vim" scheme="http://blog.czccc.cc/categories/Vim/"/>
    
    
    <category term="vim" scheme="http://blog.czccc.cc/tags/vim/"/>
    
    <category term="config" scheme="http://blog.czccc.cc/tags/config/"/>
    
  </entry>
  
  <entry>
    <title>Makefile 入门</title>
    <link href="http://blog.czccc.cc/p/9d37c3fa/"/>
    <id>http://blog.czccc.cc/p/9d37c3fa/</id>
    <published>2020-04-09T07:12:54.000Z</published>
    <updated>2022-08-06T13:07:33.620Z</updated>
    
    <content type="html"><![CDATA[<hr><p>在 Linux（ Unix ）环境下使用 GNU 的 <code>make</code> 工具能够比较容易的构建一个属于你自己的工程，整个工程的编译只需要一个命令就可以完成编译、连接以至于最后的执行。不过这需要我们投入一些时间去完成一个或者多个称之为 <code>Makefile</code> 文件的编写。</p><p>所要完成的 <code>Makefile</code> 文件描述了整个工程的编译、连接等规则。其中包括：</p><ul><li>工程中的哪些源文件需要编译以及如何编译</li><li>需要创建哪些库文件以及如何创建这些库文件</li><li>如何最后产生我们想要的可执行文件。</li><li>…</li></ul><p>尽管看起来可能是很复杂的事情，但是为工程编写 <code>Makefile</code> 的好处是能够使用一行命令来完成“自动化编译”，一旦提供一个（通常对于一个工程来说会是多个）正确的 <code>Makefile</code>。编译整个工程你所要做的事就是在 <code>shell</code> 提示符下输入 <code>make</code> 命令。整个工程完全自动编译，极大提高了效率。</p><p>make 是一个命令工具，它解释 <code>Makefile</code> 中的指令。在 <code>Makefile</code> 文件中描述了整个工程所有文件的编译顺序、编译规则。<code>Makefile</code> 有自己的书写格式、关键字、函数。像 C 语言有自己的格式、关键字和函数一样。而且在 <code>Makefile</code> 中可以使用系统shell所提供的任何命令来完成想要的工作。<code>Makefile</code> 在绝大多数的 IDE 开发环境中都在使用，已经成为一种工程的编译方法。</p><span id="more"></span><h1>Makefile 基本规则</h1><p>一个 <code>Makefile</code> 的基本语法结构如下:</p><figure class="highlight makefile"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">    command</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><code>target</code> 可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。</li><li><code>prerequisites</code>: 生成该 target 所依赖的文件</li><li><code>command</code>: 该target要执行的命令（任意的shell命令）</li><li><code>prerequisites</code> 和 <code>command</code> 都是可选的, 但是二者至少存在一个.</li><li>没有 <code>command</code> 的规则也叫伪目标</li></ul><p>简单地说，上面这个语句规定了一个 <code>target</code> 目标的生成方式. 首先需要满足 <code>prerequisites</code>, 也就是说需要先完成 <code>prerequisites</code> 的内容, 然后执行 <code>command</code> 指令实现 <code>target</code> 的生成.</p><p>另一方面, 这个语句也表明了一种依赖关系, 也就是说:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prerequisites 中如果有一个以上的文件比 target 文件要新的话，command 所定义的命令就会被执行。</span><br></pre></td></tr></table></figure><p>而整个的 <code>Makefile</code> 就是这样的一条条规则语句组成的文件. 下面是一个简单的例子.</p><figure class="highlight makefile"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 `#` 进行注释</span></span><br><span class="line"><span class="comment"># 使用 `\` 进行行末换行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 b.txt 和 c.txt 复制到 a.txt 中</span></span><br><span class="line"><span class="section">a.txt: b.txt c.txt</span></span><br><span class="line">    cat b.txt c.txt &gt; a.txt</span><br><span class="line"></span><br><span class="line"><span class="section">b.txt:</span></span><br><span class="line">    echo <span class="string">&quot;this is the text B&quot;</span> &gt; b.txt</span><br><span class="line"></span><br><span class="line"><span class="section">c.txt:</span></span><br><span class="line">    echo <span class="string">&quot;this is the text C&quot;</span> &gt; c.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 伪目标, 用于删除之前生成的 a.txt</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.txt</span><br></pre></td></tr></table></figure><p>之后, 在命令行执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make        <span class="comment"># 等同于 make a.txt</span></span><br></pre></td></tr></table></figure><p>如果 <code>make</code> 命令运行时没有指定目标，默认会执行 Makefile 文件的第一个目标. 也就是 <code>a.txt</code>, 之后由于 <code>a.txt</code> 需要 <code>b.txt</code> 和 <code>c.txt</code>, <code>make</code> 命令会继续查找相应的命令生成这两个文件, 最后将其一共复制到 <code>a.txt</code> 中.</p><p>再执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure><p>便会执行清理操作, 删除所有的 <code>txt</code> 文件</p><h2 id="target"><code>target</code></h2><p>一个目标（<code>target</code>）就构成一条<strong>规则</strong>。目标通常是文件名，指明 <code>Make</code> 命令所要构建的对象，也可以是多个文件名，之间用空格分隔。除了文件名，目标还可以是<strong>某个操作的名字</strong>，这称为&quot;<strong>伪目标</strong>&quot;（<code>phony target</code>）。</p><p>比如上面示例中的 <code>clean</code>. 对于伪目标, 存在一种情况是, 如果当前目录下刚好存在一个名为 <code>clean</code> 的文件, 那么会导致 <code>clean</code> 这个规则不会被执行. 因为Make发现clean文件已经存在, 就认为没有必要重新构建了, 就不会执行指定的rm命令.</p><p>为了避免这种情况，可以明确声明 <code>clean</code> 是&quot;伪目标&quot;，写法如下。</p><figure class="highlight makefile"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.txt</span><br></pre></td></tr></table></figure><p>类似于 <code>.PHONY</code> 这样的内置目标名可以查看<a target="_blank" rel="noopener" href="http://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets">make 手册</a>。</p><p>如果 <code>Make</code> 命令运行时没有指定目标，默认会执行 <code>Makefile</code> 文件的第一个目标。</p><h2 id="prerequisites"><code>prerequisites</code></h2><p>前置条件通常也是一组文件名，之间用空格分隔。它指定了&quot;目标&quot;是否重新构建的判断标准：只要有一个<strong>前置文件不存在</strong>，或者有过<strong>更新</strong>（前置文件的时间戳比较新），&quot;目标&quot;就需要重新构建。</p><p>上面代码中，构建 a.txt 的前置条件是 <code>b.txt</code> 和 <code>c.txt</code> 。如果当前目录中，<code>b.txt</code> 和 <code>c.txt</code> 已经存在，那么<code>make a.txt</code>可以正常运行，否则必须再写一条规则，来生成 <code>b.txt</code> 和 <code>c.txt</code> 。</p><p>如果一个目标后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件不存在，每次调用<code>make b.txt</code>，它都会生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make a.txt</span><br><span class="line">make a.txt</span><br></pre></td></tr></table></figure><p>上面命令连续执行两次<code>make a.txt</code>。第一次执行会先新建 <code>b.txt</code> 和 <code>c.txt</code>，然后再新建 <code>a.txt</code>。第二次执行，Make发现 <code>b.txt</code> 和 <code>c.txt</code> 没有变动（时间戳晚于 <code>a.txt</code>），就不会执行任何操作，<code>a.txt</code> 也不会重新生成。</p><p>如果需要生成多个文件，往往采用下面的写法。</p><figure class="highlight makefile"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">source: file1 file2 file3</span></span><br></pre></td></tr></table></figure><p>上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="built_in">source</span></span><br></pre></td></tr></table></figure><p>执行<code>make source</code>命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make file1</span><br><span class="line">make file2</span><br><span class="line">make file3</span><br></pre></td></tr></table></figure><h2 id="commands"><code>commands</code></h2><p>命令（<code>commands</code>）表示如何更新目标文件，由一行或多行的<strong>Shell命令</strong>组成。它是构建&quot;目标&quot;的具体指令，它的运行结果通常就是生成目标文件。需要注意的是，每行命令在一个单独的shell中执行。这些 Shell 之间<strong>没有继承关系</strong>。比如:</p><figure class="highlight makefile"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">var-lost:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar</span><br><span class="line">    echo <span class="string">&quot;foo=[$$foo]&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码执行后（<code>make var-lost</code>），取不到foo的值。因为两行命令在两个不同的进程执行。解决办法有:</p><ul><li>将两行命令<strong>写在一行</strong>，中间用分号分隔</li><li>在换行符前加反斜杠转义</li><li>加上<code>.ONESHELL:</code>命令</li></ul><figure class="highlight makefile"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar; echo <span class="string">&quot;foo=[$$foo]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar; \</span><br><span class="line">    echo <span class="string">&quot;foo=[$$foo]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">.ONESHELL:</span></span><br><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar; </span><br><span class="line">    echo <span class="string">&quot;foo=[$$foo]&quot;</span></span><br></pre></td></tr></table></figure><p>每行命令之前必须有一个<strong>tab键</strong>。如果想用其他键，可以用内置变量<code>.RECIPEPREFIX</code>声明。比如使用大于号（&gt;）替代tab键:</p><figure class="highlight makefile"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">&gt; echo Hello, world</span><br></pre></td></tr></table></figure><h1>Makefile 语法</h1><h2 id="回声（echoing）">回声（echoing）</h2><p>正常情况下，make会打印出每条将要执行的命令，然后再执行，这就叫做回声（echoing）。在命令的前面加上@，就可以关闭回声。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    <span class="comment"># 这是测试 1</span></span><br><span class="line">    @<span class="comment"># 这是测试 2</span></span><br></pre></td></tr></table></figure><p>执行上面的规则，会得到下面的结果, 只打印了没有关闭回声的指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 这是测试 1</span></span><br></pre></td></tr></table></figure><p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在<strong>注释</strong>和<strong>纯显示</strong>的echo命令前面加上@。</p><h2 id="通配符（wildcard）">通配符（wildcard）</h2><p>通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号（<code>*</code>）、问号（<code>?</code>）和 <code>[...]</code> 。比如， <code>*.o</code> 表示所有后缀名为 <code>o</code> 的文件。</p><ul><li><code>*</code> :匹配0个或者是任意个字符</li><li><code>?</code> :匹配任意一个字符</li><li><code>[...]</code> :我们可以指定匹配的字符放在 <code>[]</code> 中</li></ul><p>通配符不仅可以使用在规则的命令中，还可以使用在规则中, 但是如果通配符使用在依赖的规则中的话一定要注意这个问题：<strong>不能通过引用变量的方式来使用</strong>, 如果想要引用变量, 需要使用一个函数 <code>wildcard</code>, 看下面这个例子.</p><figure class="highlight makefile"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正常</span></span><br><span class="line"><span class="section">test: *.c</span></span><br><span class="line">    gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误, 会提示没有 &quot;*.c&quot; 文件</span></span><br><span class="line">OBJ = *.c</span><br><span class="line"><span class="section">test: <span class="variable">$(OBJ)</span></span></span><br><span class="line">    gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常, 使用一个函数 &quot;wildcard&quot;，这个函数在引用变量的时候，会自动展开</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"><span class="section">test: <span class="variable">$(OBJ)</span></span></span><br><span class="line">    gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure><h2 id="模式匹配">模式匹配</h2><p><code>Makefile</code> 中有一个和通配符 “<code>*</code>” 相类似的字符，这个字符是 “<code>%</code>”，也是匹配任意个字符，使用在我们的的规则当中。使用匹配符 <code>%</code>，可以将大量同类型的文件，只用一条规则就完成构建。</p><figure class="highlight makefile"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>等同于下面的写法。</p><figure class="highlight makefile"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">f1.o: f1.c</span></span><br><span class="line"><span class="section">f2.o: f2.c</span></span><br></pre></td></tr></table></figure><p>“<code>%.o</code>” 把我们需要的所有的 “<code>.o</code>” 文件组合成为一个列表，从列表中挨个取出的每一个文件，<strong>“<code>%</code>” 表示取出来单个文件的文件名（不包含后缀）</strong>，然后找到文件中和 &quot;<code>%</code>&quot;名称相同的 “<code>.c</code>” 文件，然后执行下面的命令，直到列表中的文件全部被取出来为止。</p><h2 id="变量和赋值符">变量和赋值符</h2><p>Makefile 允许使用等号自定义变量。调用时，变量需要放在 <code>$( )</code> 之中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">txt = Hello World</span><br><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    @<span class="built_in">echo</span> $(txt)        <span class="comment"># 变量 txt 等于 Hello World</span></span><br></pre></td></tr></table></figure><p>调用 Shell 变量，需要在美元符号前，再加一个美元符号，这是因为 <code>Make</code> 命令会对美元符号转义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    @<span class="built_in">echo</span> $<span class="variable">$HOME</span></span><br></pre></td></tr></table></figure><p>有时，变量的值可能指向另一个变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1 = $(v2)</span><br></pre></td></tr></table></figure><p>上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。</p><p>为了解决类似问题，Makefile一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/448910/makefile-variable-assignment">StackOverflow</a>。</p><figure class="highlight makefile"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VARIABLE = value</span><br><span class="line"><span class="comment"># 在执行时扩展，允许递归扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE := value</span><br><span class="line"><span class="comment"># 在定义时扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE ?= value</span><br><span class="line"><span class="comment"># 只有在该变量为空时才设置值。</span></span><br><span class="line"></span><br><span class="line">VARIABLE += value</span><br><span class="line"><span class="comment"># 将值追加到变量的尾端。</span></span><br></pre></td></tr></table></figure><h2 id="内置变量（Implicit-Variables）">内置变量（Implicit Variables）</h2><p>Make命令提供一系列内置变量，比如，<code>$(CC)</code> 指向当前使用的编译器，<code>$(MAKE)</code> 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见<a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">Make 手册</a>。</p><figure class="highlight makefile"><figcaption><span>Makefie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">output:</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o output input.c</span><br></pre></td></tr></table></figure><h2 id="自动变量（Automatic-Variables）">自动变量（Automatic Variables）</h2><p>Make命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。</p><ul><li><strong><code>$@</code></strong></li></ul><p><code>$@</code> 指代当前目标，就是Make命令当前构建的那个目标。比如，<code>make foo</code>的 <code>$@</code> 就指代foo。</p><p><code>$(@D)</code> 和 <code>$(@F)</code> 分别指向 <code>$@</code> 的<strong>目录名</strong>和<strong>文件名</strong>。</p><p>比如，<code>$@</code> 是 <code>src/input.c</code>，那么 <code>$(@D)</code> 的值为 <code>src</code> ，<code>$(@F)</code> 的值为 <code>input.c</code>。</p><figure class="highlight makefile"><figcaption><span>Makefie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a.txt b.txt: </span><br><span class="line">    touch <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于下面的写法。</span></span><br><span class="line"><span class="section">a.txt:</span></span><br><span class="line">    touch a.txt</span><br><span class="line"><span class="section">b.txt:</span></span><br><span class="line">    touch b.txt</span><br></pre></td></tr></table></figure><ul><li><strong><code>$&lt;</code></strong></li></ul><p><code>$&lt;</code> 指代第一个前置条件。比如，规则为 <code>t: p1 p2</code>，那么 <code>$&lt;</code> 就指代 <code>p1</code> 。</p><p><code>$(&lt;D)</code> 和 <code>$(&lt;F)</code> 分别指向 <code>$&lt;</code> 的<strong>目录名</strong>和<strong>文件名</strong>。</p><figure class="highlight makefile"><figcaption><span>Makefie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.txt: b.txt c.txt</span></span><br><span class="line">    cp <span class="variable">$&lt;</span> <span class="variable">$@</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于下面的写法。</span></span><br><span class="line"><span class="section">a.txt: b.txt c.txt</span></span><br><span class="line">    cp b.txt a.txt </span><br></pre></td></tr></table></figure><ul><li><code>$?</code></li></ul><p><code>$?</code> 指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为<code> t: p1 p2</code>，其中 <code>p2</code> 的时间戳比 <code>t</code> 新，<code>$?</code> 就指代 <code>p2</code>。</p><ul><li><code>$^</code></li></ul><p><code>$^</code> 指代所有前置条件，之间以空格分隔。比如，规则为 <code>t: p1 p2</code>，那么 <code>$^</code> 就指代 <code>p1 p2</code> 。</p><ul><li><code>$*</code></li></ul><p><code>$*</code> 指代匹配符 <code>%</code> 匹配的部分， 比如 <code>%</code> 匹配 <code>f1.txt</code> 中的 <code>f1</code> ，<code>$*</code> 就表示 <code>f1</code>。</p><p>所有的自动变量清单，请看<a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">Make 手册</a>。下面是自动变量的一个例子。</p><figure class="highlight makefile"><figcaption><span>Makefie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">dest/%.txt: src/%.txt</span></span><br><span class="line">    @[ -d dest ] || mkdir dest</span><br><span class="line">    cp <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，<code>$&lt;</code> 指代前置文件（src/%.txt）， <code>$@</code> 指代目标文件（dest/%.txt）。</p><h2 id="判断和循环">判断和循环</h2><p><code>Makefile</code> 使用 <code>Bash</code> 语法，完成判断和循环。</p><figure class="highlight makefile"><figcaption><span>Makefie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">  libs=<span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  libs=<span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。</p><figure class="highlight makefile"><figcaption><span>Makefie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LIST = one two three</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    for i in <span class="variable">$(LIST)</span>; do \</span><br><span class="line">        echo $$i; \</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    for i in one two three; do \</span><br><span class="line">        echo $i; \</span><br><span class="line">    done</span><br></pre></td></tr></table></figure><p>上面代码的运行结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure><h2 id="函数">函数</h2><p>Makefile 还可以使用函数，格式如下。</p><figure class="highlight makefile"><figcaption><span>Makefie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(function arguments)</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$&#123;function arguments&#125;</span><br></pre></td></tr></table></figure><p>Makefile提供了许多<a target="_blank" rel="noopener" href="http://www.gnu.org/software/make/manual/html_node/Functions.html">内置函数</a>，可供调用。下面是几个常用的内置函数。</p><h3 id="shell-函数">shell 函数</h3><p>shell 函数用来执行 shell 命令</p><figure class="highlight makefile"><figcaption><span>Makefie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srcfiles := <span class="variable">$(<span class="built_in">shell</span> echo src/&#123;00..99&#125;.txt)</span></span><br></pre></td></tr></table></figure><h3 id="wildcard-函数">wildcard 函数</h3><p>wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。</p><figure class="highlight makefile"><figcaption><span>Makefie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srcfiles := <span class="variable">$(<span class="built_in">wildcard</span> src/*.txt)</span></span><br></pre></td></tr></table></figure><h3 id="subst-函数">subst 函数</h3><p>subst 函数用来文本替换，格式如下。</p><figure class="highlight makefile"><figcaption><span>Makefie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> from,to,text)</span></span><br></pre></td></tr></table></figure><p>下面的例子将字符串&quot;feet on the street&quot;替换成&quot;fEEt on the strEEt&quot;。</p><figure class="highlight makefile"><figcaption><span>Makefie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> ee,EE,feet on the street)</span></span><br></pre></td></tr></table></figure><p>下面是一个稍微复杂的例子。</p><figure class="highlight makefile"><figcaption><span>Makefie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line"><span class="comment"># space变量用两个空变量作为标识符，当中是一个空格</span></span><br><span class="line">space:= <span class="variable">$(empty)</span> <span class="variable">$(empty)</span></span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= <span class="variable">$(<span class="built_in">subst</span> <span class="variable">$(space)</span>,<span class="variable">$(comma)</span>,<span class="variable">$(foo)</span>)</span></span><br><span class="line"><span class="comment"># bar is now `a,b,c&#x27;.</span></span><br></pre></td></tr></table></figure><h3 id="patsubst函数">patsubst函数</h3><p>patsubst 函数用于模式匹配的替换，格式如下。</p><figure class="highlight makefile"><figcaption><span>Makefie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> pattern,replacement,text)</span></span><br></pre></td></tr></table></figure><p>下面的例子将文件名&quot;x.c.c bar.c&quot;，替换成&quot;x.c.o bar.o&quot;。</p><figure class="highlight makefile"><figcaption><span>Makefie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,x.c.c bar.c)</span></span><br></pre></td></tr></table></figure><h3 id="替换后缀名">替换后缀名</h3><p>替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上patsubst函数的一种简写形式。</p><figure class="highlight makefile"><figcaption><span>Makefie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">min: $(OUTPUT:.js=.min.js)</span></span><br></pre></td></tr></table></figure><p>上面代码的意思是，将变量OUTPUT中的后缀名 .js 全部替换成 .min.js 。</p><h1>Makefile 的实例</h1><h2 id="执行多个目标">执行多个目标</h2><figure class="highlight makefile"><figcaption><span>Makefie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: cleanall cleanobj cleandiff</span></span><br><span class="line"></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">        rm program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">        rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">        rm *.diff</span><br></pre></td></tr></table></figure><p>上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（cleanall），删除所有指定类型的文件。</p><h2 id="编译C语言项目">编译C语言项目</h2><figure class="highlight makefile"><figcaption><span>Makefie</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o </span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h</span><br><span class="line">    cc -c display.c</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">     rm edit main.o kbd.o command.o display.o</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: edit clean</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;在 Linux（ Unix ）环境下使用 GNU 的 &lt;code&gt;make&lt;/code&gt; 工具能够比较容易的构建一个属于你自己的工程，整个工程的编译只需要一个命令就可以完成编译、连接以至于最后的执行。不过这需要我们投入一些时间去完成一个或者多个称之为 &lt;code&gt;Makefile&lt;/code&gt; 文件的编写。&lt;/p&gt;
&lt;p&gt;所要完成的 &lt;code&gt;Makefile&lt;/code&gt; 文件描述了整个工程的编译、连接等规则。其中包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工程中的哪些源文件需要编译以及如何编译&lt;/li&gt;
&lt;li&gt;需要创建哪些库文件以及如何创建这些库文件&lt;/li&gt;
&lt;li&gt;如何最后产生我们想要的可执行文件。&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管看起来可能是很复杂的事情，但是为工程编写 &lt;code&gt;Makefile&lt;/code&gt; 的好处是能够使用一行命令来完成“自动化编译”，一旦提供一个（通常对于一个工程来说会是多个）正确的 &lt;code&gt;Makefile&lt;/code&gt;。编译整个工程你所要做的事就是在 &lt;code&gt;shell&lt;/code&gt; 提示符下输入 &lt;code&gt;make&lt;/code&gt; 命令。整个工程完全自动编译，极大提高了效率。&lt;/p&gt;
&lt;p&gt;make 是一个命令工具，它解释 &lt;code&gt;Makefile&lt;/code&gt; 中的指令。在 &lt;code&gt;Makefile&lt;/code&gt; 文件中描述了整个工程所有文件的编译顺序、编译规则。&lt;code&gt;Makefile&lt;/code&gt; 有自己的书写格式、关键字、函数。像 C 语言有自己的格式、关键字和函数一样。而且在 &lt;code&gt;Makefile&lt;/code&gt; 中可以使用系统shell所提供的任何命令来完成想要的工作。&lt;code&gt;Makefile&lt;/code&gt; 在绝大多数的 IDE 开发环境中都在使用，已经成为一种工程的编译方法。&lt;/p&gt;</summary>
    
    
    
    <category term="C-CPP" scheme="http://blog.czccc.cc/categories/C-CPP/"/>
    
    
    <category term="C" scheme="http://blog.czccc.cc/tags/C/"/>
    
    <category term="CPP" scheme="http://blog.czccc.cc/tags/CPP/"/>
    
    <category term="C++" scheme="http://blog.czccc.cc/tags/C/"/>
    
    <category term="Makefile" scheme="http://blog.czccc.cc/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>Python 中的魔术方法</title>
    <link href="http://blog.czccc.cc/p/7c8c7b3f/"/>
    <id>http://blog.czccc.cc/p/7c8c7b3f/</id>
    <published>2020-01-17T12:40:37.000Z</published>
    <updated>2022-08-06T13:07:33.621Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中有一种比较特别的类方法, 通常使用<strong>双下划线</strong>包裹着方法的名称, 被称为<strong>魔术方法</strong>.</p><p>英文也称为 magic method 或者 dunder method</p><span id="more"></span><p>为了比较方便地解释这些方法的作用, 我会通过构造一个类: Vector, 表示 n 维矢量, 并通过这些魔术方法逐渐地向其中添加功能.</p><h1>创建对象</h1><h2 id="init"><code>__init__</code></h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, dim=<span class="number">1</span></span>):</span><br><span class="line">        self.dim = dim</span><br></pre></td></tr></table></figure><h2 id="new"><code>__new__</code></h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python 中有一种比较特别的类方法, 通常使用&lt;strong&gt;双下划线&lt;/strong&gt;包裹着方法的名称, 被称为&lt;strong&gt;魔术方法&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;英文也称为 magic method 或者 dunder method&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="http://blog.czccc.cc/categories/Python/"/>
    
    
    <category term="Python" scheme="http://blog.czccc.cc/tags/Python/"/>
    
  </entry>
  
</feed>
