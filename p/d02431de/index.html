<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Rust 中的错误处理 - CZCC</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="CZCC"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="CZCC"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="原文地址：https:&amp;#x2F;&amp;#x2F;blog.burntsushi.net&amp;#x2F;rust-error-handling&amp;#x2F; 原文标题：Error Handling in Rust 原文作者：Andrew Gallant’s Blog 翻译日期：2020&amp;#x2F;08&amp;#x2F;03"><meta property="og:type" content="blog"><meta property="og:title" content="Rust 中的错误处理"><meta property="og:url" content="http://blog.czccc.cc/p/d02431de/"><meta property="og:site_name" content="CZCC"><meta property="og:description" content="原文地址：https:&amp;#x2F;&amp;#x2F;blog.burntsushi.net&amp;#x2F;rust-error-handling&amp;#x2F; 原文标题：Error Handling in Rust 原文作者：Andrew Gallant’s Blog 翻译日期：2020&amp;#x2F;08&amp;#x2F;03"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://blog.czccc.cc/img/og_image.png"><meta property="article:published_time" content="2020-08-03T01:35:41.000Z"><meta property="article:modified_time" content="2022-08-06T13:07:33.621Z"><meta property="article:author" content="Cheng"><meta property="article:tag" content="Rust"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.czccc.cc/p/d02431de/"},"headline":"Rust 中的错误处理","image":["http://blog.czccc.cc/img/og_image.png"],"datePublished":"2020-08-03T01:35:41.000Z","dateModified":"2022-08-06T13:07:33.621Z","author":{"@type":"Person","name":"Cheng"},"publisher":{"@type":"Organization","name":"CZCC","logo":{"@type":"ImageObject","url":"http://blog.czccc.cc/img/logo.ico"}},"description":"原文地址：https:&#x2F;&#x2F;blog.burntsushi.net&#x2F;rust-error-handling&#x2F; 原文标题：Error Handling in Rust 原文作者：Andrew Gallant’s Blog 翻译日期：2020&#x2F;08&#x2F;03"}</script><link rel="canonical" href="http://blog.czccc.cc/p/d02431de/"><link rel="alternate" href="/atom.xml" title="CZCC" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.ico" alt="CZCC" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/categories/LeetCode">LeetCode</a><a class="navbar-item" href="/Software">Software</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/czccc/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-3 is-size-4-mobile"><i class="fas fa-angle-double-right">  </i>Rust 中的错误处理</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-alt">  </i><span class="level-item"><time dateTime="2020-08-03T01:35:41.000Z" title="2020/8/3 09:35:41">2020-08-03</time>发表</span><i class="far fa-calendar-check">  </i><span class="level-item"><time dateTime="2022-08-06T13:07:33.621Z" title="2022/8/6 21:07:33">2022-08-06</time>更新</span><i class="far fa-folder">  </i><span class="level-item"><a class="link-muted" href="/categories/Rust/">Rust</a></span><i class="far fa-hourglass">  </i><span class="level-item">2 小时读完 (大约18598个字)</span><i class="far fa-eye">  </i><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><hr>
<blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://blog.burntsushi.net/rust-error-handling/">https://blog.burntsushi.net/rust-error-handling/</a></p>
<p>原文标题：Error Handling in Rust</p>
<p>原文作者：<a target="_blank" rel="noopener" href="https://blog.burntsushi.net/">Andrew Gallant’s Blog</a></p>
<p>翻译日期：2020/08/03</p>
</blockquote>
<span id="more"></span>
<h1>Rust 中的错误处理</h1>
<p>与大多数编程语言一样，Rust 鼓励程序员以特定方式处理错误。一般而言，错误处理分为两大类：<strong>异常</strong>和<strong>返回值</strong>。Rust选择<strong>使用返回值</strong>进行错误处理。</p>
<p>在本文中，我尝试对 Rust 中如何进行错误处理提供全面的说明。并且，我将尝试一次引入一个错误处理的方法，并帮助你获得扎实的实践知识，即如何整合所有内容。</p>
<p>如果没有良好的实现方式，Rust 中的错误处理可能会很冗长并繁琐。本文将探讨这些问题，并展示如何<strong>使用标准库</strong>使错误处理变得简明，并符合工程习惯。</p>
<p><strong>目标受众</strong>：尚不明确 Rust 错误处理用法的新手。熟悉 Rust 语法会更好。（本文使用了许多标准库 trait，但很少使用闭包和宏。）</p>
<p><strong>更新（2018/04/14）</strong>：示例已转换为使用 <code>?</code> 进行处理，并添加了一些文本以提供更改的背景。</p>
<p><strong>更新（2020/01/03）</strong>：删除了 <a target="_blank" rel="noopener" href="https://crates.io/crates/failure"><code>failure</code></a> 的使用建议， 并替换为建议使用 <code>Box&lt;Error + Send + Sync&gt;</code> 或 <a target="_blank" rel="noopener" href="https://crates.io/crates/anyhow"><code>anyhow</code></a>。</p>
<h2 id="简要说明-2">简要说明</h2>
<p>文中的代码示例均通过 Rust <code>1.0.0-beta.5</code> 进行编译。随着 Rust 1.0 稳定版的发布，他们应该同样可以运行。</p>
<p>所有的代码都可以在作者的<a target="_blank" rel="noopener" href="https://github.com/BurntSushi/blog/tree/master/code/rust-error-handling">博客仓库</a>中找到并编译。</p>
<p><a target="_blank" rel="noopener" href="http://doc.rust-lang.org/1.0.0-beta.5/book/">Rust Book</a> 中有一节 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/1.0.0-beta.5/book/error-handling.html">section on error handling</a>。它提供了非常简短的概述，但是（还）没有介绍得足够详细，尤其是在使用标准库的一些最新内容时。</p>
<blockquote>
<p>译者注：最新版的 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/title-page.html">Rust Book</a> 已经更新了许多内容，建议阅读<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">新版的错误处理章节</a>。</p>
<p><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/title-page.html">简体中文版地址</a>, <a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch09-00-error-handling.html">错误处理章节</a>。</p>
</blockquote>
<h2 id="运行代码">运行代码</h2>
<p>读者如果想要运行本文中的代码示例，可以使用下面的方法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://github.com/BurntSushi/blog</span><br><span class="line">$ <span class="built_in">cd</span> blog/code/rust-error-handling</span><br><span class="line">$ cargo run --bin NAME-OF-CODE-SAMPLE [ args ... ]</span><br></pre></td></tr></table></figure>
<p>每个代码示例有其名称。（没有命名的代码不能按照这种方式运行。）</p>
<h2 id="说明">说明</h2>
<p>本文很长，主要是因为我从一开始就使用多种错误类型及其组合，并尝试使用 Rust 逐步进行错误处理。因此，在其他显式类型系统中有经验的程序员可能想快速跳转本文。这是一些简短指南：</p>
<ul>
<li>如果你不熟悉 Rust，系统编程和显式类型系统，那么请从头开始并逐步进行。（如果你是全新用户，则可能应该先通读 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/title-page.html">Rust Book</a>。）</li>
<li>如果你以前从未看过 Rust，但是有过使用函数式语言的经验（对“代数数据类型”和“组合器”感到熟悉），那么你可以跳过基础知识，而先略读<a href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B">多种错误类型</a>，然后仔细阅读 <a href="#%E7%94%A8%E4%BA%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93-traits">标准库错误特征</a>。（如果你以前从未真正看过Rust，略读<a href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识</a>可能是一个不错的主意。）你可能需要查询 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/title-page.html">Rust Book</a>，以获取有关 Rust 闭包和宏的帮助。</li>
<li>如果你已经对 Rust 有所了解，并且只想学习如何对错误进行处理，那么你可以直接跳到<a href="#%E6%A6%82%E6%8B%AC">最后</a>。略读<a href="#%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0-%E8%AF%BB%E5%8F%96%E4%BA%BA%E5%8F%A3%E6%95%B0%E6%8D%AE">模式匹配</a>可能会比较有用。</li>
</ul>
<hr>
<h1>基础知识</h1>
<p>我喜欢将错误处理变为使用<strong>模式匹配</strong>来判断一个计算任务是否成功。正如我们将要看到的，工程上错误处理的关键是保持代码可组合性的同时，<strong>减少显式模式匹配的数目</strong>。</p>
<p>保持代码的可组合性很重要，因为如果没有此要求，我们可以在遇到意外情况时直接进行 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic</code></a> 操作。（<code>panic</code> 导致当前任务结束，并且在大多数情况下，整个程序都将中止。）这是一个示例：</p>
<figure class="highlight rust"><figcaption><span>panic-simple</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Guess a number between 1 and 10.</span></span><br><span class="line"><span class="comment">// If it matches the number I had in mind, return true. Else, return false.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">guess</span>(n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span> || n &gt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;Invalid number: &#123;&#125;&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    n == <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">guess</span>(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你想要运行此代码，查看 <a href="#%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81">运行代码</a> 一章。</p>
</blockquote>
<p>如果你尝试运行此代码，程序将会中止，并报告错误信息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="string">&#x27;&lt;main&gt;&#x27;</span> panicked at <span class="string">&#x27;Invalid number: 11&#x27;</span>, src/bin/panic-simple.rs:5</span><br></pre></td></tr></table></figure>
<p>这是另外一个例子。程序接收一个整数作为参数，将其乘 2 并打印出来。</p>
<figure class="highlight rust"><figcaption><span>unwrap-double</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">argv</span> = env::<span class="title function_ invoke__">args</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arg</span>: <span class="type">String</span> = argv.<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// error 1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = arg.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// error 2</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="number">2</span> * n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $ cargo run --bin unwrap-double 5</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>如果你没有给程序传递参数 (error 1) 或者第一个参数不是整数 (error 2)，程序会像第一个例子一样中止。</p>
<p>我认为这种错误处理方式就像是<em>在中国商店中奔跑的公牛</em>。公牛会到达它想去的地方，但是会践踏过程中的一切。</p>
<h2 id="Unwrapping-说明">Unwrapping 说明</h2>
<p>在上面的例子里 (<code>unwrap-double</code>)，我声称：如果程序满足两个错误条件之一，该程序将中止。但是，程序中并未像第一个示例（<code>panic-simple</code>）那样包含显式调用 <code>panic</code> 。这是因为 <code>panic</code> 嵌入在对 <code>unwrap</code> 的调用中。</p>
<p>要 “<code>unwrap</code>” Rust 中的某些内容，也就意味着：“给我计算的结果，并且如果有错误，请立即调用 <code>panic</code> 并中止程序。” 如果我直接展示用于 unwrapping 的代码可能会帮助你理解这一点，因为它十分简单。但是要做到这一点，我们首先需要探讨 <code>Option</code> 和 <code>Result</code> 类型。这两种类型在其上都有一个称为 <code>unwrap</code> 的方法。</p>
<h2 id="Option-类型"><code>Option</code> 类型</h2>
<p><code>Option</code> 类型定义在 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html">标准库</a> 中：</p>
<figure class="highlight rust"><figcaption><span>option-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Option</code> 类型在 Rust 中主要适用于表示<strong>不存在的可能性</strong>。将<strong>不存在的可能性</strong>编码到类型系统中是一个很重要的概念，因为它可以通过编译器去强制程序员处理这样的<strong>不存在的情况</strong>。让我们看一个例子，它在字符串中尝试查找一个字符：</p>
<figure class="highlight rust"><figcaption><span>option-ex-string-find</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Searches `haystack` for the Unicode character `needle`. If one is found, the</span></span><br><span class="line"><span class="comment">// byte offset of the character is returned. Otherwise, `None` is returned.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find</span>(haystack: &amp;<span class="type">str</span>, needle: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">usize</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">for</span> (offset, c) <span class="keyword">in</span> haystack.<span class="title function_ invoke__">char_indices</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> c == needle &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（Pro-tip：请勿使用此代码。请使用标准库中的 <code>find</code> 方法。）</p>
<p>注意到当函数找到一个匹配的字符时，它并不直接返回 <code>offset</code>，而是返回 <code>Some(offset)</code>。<code>Some</code> 是 <code>Option</code> 中的一个变体，或者说是一个值构造（value constructor）函数。你可以将其认为是一个函数：<code>fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;</code>。相应的， <code>None</code> 也是一个值构造（value constructor）函数,只不过它没有参数。你可以将 <code>None</code> 认为是一个函数： <code>fn&lt;T&gt;() -&gt; Option&lt;T&gt;</code>。</p>
<p>这看起来很简单，但这只是程序的一半，另一半是使用我们编写的函数 <code>find</code>。让我们尝试使用它在文件名中查找扩展名：</p>
<figure class="highlight rust"><figcaption><span>option-ex-string-find</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main_find</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_name</span> = <span class="string">&quot;foobar.rs&quot;</span>;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">find</span>(file_name, <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;No file extension found.&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;File extension: &#123;&#125;&quot;</span>, &amp;file_name[i+<span class="number">1</span>..]),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此代码对 <code>find</code> 返回的 <code>Option&lt;usize&gt;</code> 进行<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch06-00-enums.html"><strong>模式匹配</strong></a>，实际上，模式匹配是获取存储在<code>Option&lt;T&gt;</code>中的值的<strong>唯一方法</strong>。这意味着作为程序员的你，<strong>必须</strong>处理当 <code>Option&lt;T&gt;</code> 是 <code>None</code> 的情况，而不仅仅是 <code>Some(t)</code>。</p>
<p>但是等等，那么在 <code>unwrap-double</code> 中使用的 <code>unwrap</code> 是什么情况呢？那里没有模式匹配！这是因为它将模式匹配嵌入到 <code>unwrap</code> 方法中。你可以根据需要自己定义 <code>unwrap</code> 方法：</p>
<figure class="highlight rust"><figcaption><span>option-def-unwrap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="type">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">unwrap</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Option::<span class="title function_ invoke__">Some</span>(val) =&gt; val,</span><br><span class="line">            Option::<span class="literal">None</span> =&gt;</span><br><span class="line">              <span class="built_in">panic!</span>(<span class="string">&quot;called `Option::unwrap()` on a `None` value&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>unwrap</code> 方法中抽象出模式匹配，正是工程中使用 <code>unwrap</code> 的方式。然而，<code>unwrap</code> 中的 <code>panic!</code> 仍然意味着这个 <code>unwrap</code> 是不可组合的：<em>这是中国商店里的公牛</em>。</p>
<h3 id="组合-Option-T">组合 <code>Option&lt;T&gt;</code></h3>
<p>在 <code>option-ex-string-find</code> 其中，我们看到如何使用<code>find</code>来查找文件名中的扩展名。但是，并非所有文件名都带有 <code>.</code>，因此文件名<em>可能没有扩展名</em>。我们将这种<strong>不存在的可能性</strong>编码为类型 <code>Option&lt;T&gt;</code>。换句话说，编译器将迫使我们处理扩展不存在的可能性。就我们而言，我们只是打印出一条错误消息。</p>
<p>获取文件扩展名是很常见的操作，因此可以将其放入函数中：</p>
<figure class="highlight rust"><figcaption><span>option-ex-string-find</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the extension of the given file name, where the extension is defined</span></span><br><span class="line"><span class="comment">// as all characters succeeding the first `.`.</span></span><br><span class="line"><span class="comment">// If `file_name` has no `.`, then `None` is returned.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">extension_explicit</span>(file_name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">find</span>(file_name, <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(&amp;file_name[i+<span class="number">1</span>..]),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（Pro-tip：请勿使用此代码。请使用标准库中的 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/path/struct.Path.html#method.extension"><code>extension</code></a> 方法。）</p>
<p>上面的代码仍然很简单，但需要注意的一点是，<code>find</code> 强制我们考虑不存在的可能性。这种情况的好处在于：编译器不会让我们意外忘记文件名没有扩展名的情况。另一方面，像 <code>extension_explicit</code> 函数所实现的那样，进行显式的模式匹配可能会有点繁琐。</p>
<p>实际上，<code>extension_explicit</code> 中的模式匹配遵循一种非常常见的模式：将函数映射到 <code>Option&lt;T&gt;</code> 内部的值，如果该 <code>Option</code> 为 <code>None</code>，只需返回 <code>None</code> 即可。</p>
<p>Rust 具有参数多态性，因此定义抽象该模式的组合器非常容易：</p>
<figure class="highlight rust"><figcaption><span>option-map</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">map</span>&lt;F, T, A&gt;(option: <span class="type">Option</span>&lt;T&gt;, f: F) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;A&gt; <span class="keyword">where</span> F: <span class="title function_ invoke__">FnOnce</span>(T) <span class="punctuation">-&gt;</span> A &#123;</span><br><span class="line">    <span class="keyword">match</span> option &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(value) =&gt; <span class="title function_ invoke__">Some</span>(<span class="title function_ invoke__">f</span>(value)),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，<code>map</code> 在标准库中被定义为 <code>Option&lt;T&gt;</code> 上的一种<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map">方法</a>。</p>
<p>有了新的组合器，我们可以重写 <code>extension_explicit</code> 方法以去除模式匹配：</p>
<figure class="highlight rust"><figcaption><span>option-ex-string-find</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the extension of the given file name, where the extension is defined</span></span><br><span class="line"><span class="comment">// as all characters succeeding the first `.`.</span></span><br><span class="line"><span class="comment">// If `file_name` has no `.`, then `None` is returned.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">extension</span>(file_name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">find</span>(file_name, <span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">map</span>(|i| &amp;file_name[i+<span class="number">1</span>..])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种很常见的模式是，当 <code>Option</code> 值为 <code>None</code> 时，为其<strong>分配一个默认值</strong>。例如，你的程序假定：即使文件扩展名不存在，文件的扩展名也是 <code>rs</code>。同样的，对此情况的模式匹配并不特定于文件扩展名。使用 <code>Option&lt;T&gt;</code> 也可以实现它：</p>
<figure class="highlight rust"><figcaption><span>option-unwrap-or</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">unwrap_or</span>&lt;T&gt;(option: <span class="type">Option</span>&lt;T&gt;, default: T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">match</span> option &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; default,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(value) =&gt; value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的要求是，默认值必须与 <code>Option&lt;T&gt;</code> 内的值具有相同的类型。在我们的例子里，使用它非常简单：</p>
<figure class="highlight rust"><figcaption><span>option-ex-string-find</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">extension</span>(<span class="string">&quot;foobar.csv&quot;</span>).<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;rs&quot;</span>), <span class="string">&quot;csv&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">extension</span>(<span class="string">&quot;foobar&quot;</span>).<span class="title function_ invoke__">unwrap_or</span>(<span class="string">&quot;rs&quot;</span>), <span class="string">&quot;rs&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（请注意，<code>unwrap_or</code> 在标准库中是定义在 <code>Option&lt;T&gt;</code> 上的一种<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or">方法</a>，所以我们在这里用的并不是我们在上面自己定义的函数。记得查找更通用的 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code> 方法</a>。）</p>
<p>我认为还有一种组合器值得特别注意：<code>and_then</code>。它使组合不同的计算变得更容易，这些计算都会处理不存在的可能性。例如，本节中的许多代码都是关于查找给定文件名的扩展名。为此，你首先需要从文件路径中提取出文件名。尽管大多数文件路径都具有文件名，但并非所有都具有，例如<code>.</code>，<code>..</code>或 <code>/</code>。</p>
<p>因此，我们面临的挑战是查找给定文件路径下所有文件的扩展名 。让我们从显式模式匹配开始：</p>
<figure class="highlight rust"><figcaption><span>option-ex-string-find</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">file_path_ext_explicit</span>(file_path: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">file_name</span>(file_path) &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(name) =&gt; <span class="keyword">match</span> <span class="title function_ invoke__">extension</span>(name) &#123;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(ext) =&gt; <span class="title function_ invoke__">Some</span>(ext),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_name</span>(file_path: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// implementation elided</span></span><br><span class="line">  <span class="built_in">unimplemented!</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会认为我们可以只使用 <code>map</code> 组合器来减少模式匹配，但是它的类型不太合适。即，<code>map</code> 采用仅对内部值执行某些操作的函数。然后，总是用 <code>Some</code> 来包装该函数的结果。但是，我们需要类似于 <code>map</code>，但允许调用者返回其他的 <code>Option</code>。它的通用实现甚至比 <code>map</code> 更简单：</p>
<figure class="highlight rust"><figcaption><span>option-and-then</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">and_then</span>&lt;F, T, A&gt;(option: <span class="type">Option</span>&lt;T&gt;, f: F) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;A&gt;</span><br><span class="line">        <span class="keyword">where</span> F: <span class="title function_ invoke__">FnOnce</span>(T) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;A&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> option &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(value) =&gt; <span class="title function_ invoke__">f</span>(value),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以重写 <code>file_path_ext</code> 函数，而无需进行显式的模式匹配：</p>
<figure class="highlight rust"><figcaption><span>option-ex-string-find</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">file_path_ext</span>(file_path: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">file_name</span>(file_path).<span class="title function_ invoke__">and_then</span>(extension)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Option</code> 类型在<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html">标准库</a>中定义了许多其他组合器。建议浏览此文档并熟悉其可用的内容，它们通常可以为你减少模式匹配。熟悉这些组合器会很有帮助，并且它们中大多也为 <code>Result</code> 定义了相似的语义，我们将在下面讨论。</p>
<p>组合使用 <code>Option</code> 类型是个比较符合工程学的实现，因为它们减少了显式的模式匹配。它们仍然是可组合的，因为它们允许调用者以自己的方式处理不存在的可能性。类似于 <code>unwrap</code> 的方法移除了这种可能性，因为他们在 <code>Option&lt;T&gt;</code> 是 <code>None</code> 会中止程序运行。</p>
<h2 id="Result-类型"><code>Result</code> 类型</h2>
<p><code>Result</code> 类型也定义在<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/">标准库</a>中：</p>
<figure class="highlight rust"><figcaption><span>result-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Result</code> 类型是更丰富版的 <code>Option</code>。也就是说，不同于像 <code>Option</code> 那样表示<strong>不存在的可能性</strong>，<code>Result</code>表示的是<strong>出现错误的可能性</strong>。通常，错误用于解释为什么某些计算结果会失败。这是更严格的 <code>Option</code> 的通用形式。请考虑以下类型别名，该别名在各个方面的语义上均等同于实际的 <code>Option&lt;T&gt;</code> ：</p>
<figure class="highlight rust"><figcaption><span>option-as-result</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Option</span>&lt;T&gt; = <span class="type">Result</span>&lt;T, ()&gt;;</span><br></pre></td></tr></table></figure>
<p>这将 <code>Result</code> 的第二个参数类型始终固定为 <code>()</code>（发音为 “unit” 或 “empty tuple”）。并且也只定义在 <code>()</code> 类型中。（<code>()</code> 类型和值这两个级别的术语具有相同的符号！）</p>
<p><code>Result</code> 类型是表示计算中两个可能结果之一的方式。按照惯例，一个结果是预期正确的结果即“<code>Ok</code>”，而另一个结果是不预期的错误即“<code>Err</code>”。</p>
<p>就像 <code>Option</code> 一样，<code>Result</code> 类型也具有在标准库中定义的 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>unwrap</code></a> 方法。让我们自己定义一下：</p>
<figure class="highlight rust"><figcaption><span>result-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T, E: ::std::fmt::<span class="built_in">Debug</span>&gt; <span class="type">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">unwrap</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Result::<span class="title function_ invoke__">Ok</span>(val) =&gt; val,</span><br><span class="line">            Result::<span class="title function_ invoke__">Err</span>(err) =&gt;</span><br><span class="line">              <span class="built_in">panic!</span>(<span class="string">&quot;called `Result::unwrap()` on an `Err` value: &#123;:?&#125;&quot;</span>, err),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这实际上与我们对 <code>Option::unwrap</code> 的定义相类似，只不过它在 <code>panic!</code> 消息中返回错误值。这使调试程序更加容易，但还需要我们在 <code>E</code> 类型参数（代表我们的错误类型）上添加 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> 约束。由于绝大多数类型都应满足 <code>Debug</code> 约束条件，因此这在实践中很容易解决。（类型上的 <code>Debug</code> 只是意味着有一种合理的方式来以人类可读的形式打印该类型的值。）</p>
<p>好的，让我们继续下一个例子。</p>
<h3 id="解析整数">解析整数</h3>
<p>Rust 标准库使将字符串转换为整数十分容易。实际上也是如此，编写如下内容非常简单：</p>
<figure class="highlight rust"><figcaption><span>result-num-unwrap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">double_number</span>(number_str: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="number">2</span> * number_str.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = <span class="title function_ invoke__">double_number</span>(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(n, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此时，你应该对调用 <code>unwrap</code> 表示警惕。例如，如果字符串未解析为数字，则会出现 <code>panic</code>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;&lt;main&gt;&#x27; panicked at &#x27;called `Result::unwrap()` on an `Err` value: ParseIntError &#123; kind: InvalidDigit &#125;&#x27;, /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729</span><br></pre></td></tr></table></figure>
<p>这是相当不直观的，如果这种情况发生在你正在使用的库函数中，你可能会感到很烦恼。因此，我们应该尝试处理函数中的错误，并让调用者决定如何处理。这意味着更改 <code>double_number</code> 的返回类型。但是要怎么做呢？让我们查看标准库中 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse</code> 方法</a>的定义 ：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">str</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">parse</span>&lt;F: FromStr&gt;(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;F, F::<span class="literal">Err</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯… 所以我们至少知道需要使用 <code>Result</code>。当然，返回 <code>Option</code> 也是可取的。毕竟，字符串要么解析为数字，要么不是数字。虽然这是一种合理的方法，但是使用 <code>Result</code> 可以从内部区分为什么字符串没有解析为整数。（无论它是一个空字符串，一个无效数字，数字太大还是太小。）因此，使用 <code>Result</code> 更有意义，因为我们希望提供的信息不仅仅是简单的“不存在”，我们想说明为什么解析会失败。当遇到 <code>Option</code> 和 <code>Result</code> 之间的选择时，你应该尝试效仿这样的推理。如果你可以提供详细的错误信息，那么你就应该这样做。（我们将在稍后看到更多信息。）</p>
<p>好的，但是我们如何编写返回类型？上面定义的 <code>parse</code> 方法在标准库中所有不同的数字类型上都是通用的。我们可以（并且应该）使函数也如此通用，不过现在让我们首先仅支持显式定义类型。我们只关心 <code>i32</code>，因此我们需要找到它的 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.i32.html"><code>FromStr</code> 实现</a>并查看其<a target="_blank" rel="noopener" href="http://doc.rust-lang.org/1.0.0-beta.5/book/associated-types.html">关联类型 <code>Err</code></a>。这么做是为了找到具体的错误类型，在此情况下为 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a>。然后，我们可以重写函数：</p>
<figure class="highlight rust"><figcaption><span>result-num-no-unwrap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">double_number</span>(number_str: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> number_str.parse::&lt;<span class="type">i32</span>&gt;() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="title function_ invoke__">Err</span>(err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">double_number</span>(<span class="string">&quot;10&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">assert_eq!</span>(n, <span class="number">20</span>),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;:?&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这看起来好了一些，但是现在代码行数更多了！模式匹配再次使我们感到繁琐。</p>
<p>因此可以<strong>使用组合器</strong>来帮助我们！就像 <code>Option</code> 一样，<code>Result</code> 有很多定义为方法的组合器。<code>Result</code> 和 <code>Option</code> 在公共的组合器上有很大的交集。特别的，<code>map</code> 便是该交集的一部分：</p>
<figure class="highlight rust"><figcaption><span>result-num-no-unwrap-map</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">double_number</span>(number_str: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    number_str.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map</span>(|n| <span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">double_number</span>(<span class="string">&quot;10&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">assert_eq!</span>(n, <span class="number">20</span>),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;:?&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常使用的组合器在 <code>Result</code> 中都有，包括 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or"><code>unwrap_or</code></a> 和 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then"><code>and_then</code></a>。此外，由于 <code>Result</code> 具有第二种类型的参数，因此有一些组合器仅使用错误类型，例如 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>map_err</code></a>（类似于 <code>map</code>）和 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/result/enum.Result.html#method.or_else"><code>or_else</code></a> （类似于 <code>and_then</code>）。</p>
<h3 id="Result-类型别名"><code>Result</code> 类型别名</h3>
<p>在标准库中，你可能经常看到类似 <code>Result&lt;i32&gt;</code> 的类型。但是，在 <code>Result</code> 中定义了两个类型参数，我们如何只指定一个就可以使用呢？答案是定义一个 <code>Result</code> 类型别名，在其中固定类型参数中的一个特定类型。通常，固定类型是错误类型。例如，我们前面的解析整数的示例可以这样重写：</p>
<figure class="highlight rust"><figcaption><span>result-num-no-unwrap-map-alias</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::num::ParseIntError;</span><br><span class="line"><span class="keyword">use</span> std::result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span>&lt;T&gt; = result::<span class="type">Result</span>&lt;T, ParseIntError&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">double_number</span>(number_str: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="built_in">unimplemented!</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要这样做？因为如果我们有很多需要返回 <code>ParseIntError</code> 的函数，那么定义一个始终使用 <code>ParseIntError</code> 的别名要方便得多，这样我们就不必一直重复它。</p>
<p>这个习惯用法在标准库中最常见的地方是 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>。通常情况下，这样编写<code>io::Result&lt;T&gt;</code> 就可以清楚地表明你使用的是 <code>io</code> 模块的类型别名，而不是使用的普通定义 <code>std::result</code>。（此习惯用法也用于 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/fmt/type.Result.html"><code>fmt::Result</code></a>。）</p>
<h2 id="小插曲：unwrapping-并非不能使用的">小插曲：unwrapping 并非不能使用的</h2>
<p>如果你一直在阅读本文，你可能已经注意到，我采取了相当严格的措施来禁止调用 <code>unwrap</code> 导致程序中止 <code>panic</code> 的方法。一般来说，这是一个很好的建议。</p>
<p>但是，<code>unwrap</code> 仍然是可以使用。确切地说，使用 <code>unwrap</code> 是一个灰色地带，部分人并不建议使用。我总结了我对此事的一些<strong>看法</strong>。</p>
<ul>
<li>**在代码示例和简短的程序中。**有时你正在编写示例或简短的程序，而错误处理并不重要。在这种情况下使用 <code>unwrap</code> 非常方便。</li>
<li>**在程序中止时表示程序中有错误。**当程序应防止发生某种情况时（例如，从空堆栈中弹出），则可以允许中止。因为它暴露了程序中的错误，这既可能是明确的，例如 <code>assert!</code> 失败，也可能是因为你对数组的索引超出范围。</li>
</ul>
<p>这可能并不是详尽的说明。此外，使用 <code>Option</code> 时，通常最好使用其 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>expect</code></a> 方法。除了打印一条给你的消息外，它的用途与 <code>unwrap</code> 完全相同。但它使输出的程序中止问题描述变得友好一些，因为它将显示你的消息，而不是“调用 <code>None</code> 值的 <code>unwrap</code>”。</p>
<p>我的建议可以归结为：运用你良好的判断力。我的写作中从不出现 “从不做X” 或 “Y被视为有害” 这两个词。在所有方面都有权衡取舍，由程序员在你的用例使用可接受的部分。我的目标只是帮助你尽可能准确地评估权衡。</p>
<p>既然我们已经介绍了 Rust 中错误处理的基础知识，并且我已经讲过关于 <code>unwrap</code> 的内容，那么让我们开始探索标准库的更多内容。</p>
<h1>使用多种错误类型</h1>
<p>到目前为止，我们已经尝试的错误处理都是基于 <code>Option&lt;T&gt;</code> 或 <code>Result&lt;T, SomeError&gt;</code>。但是，当你同时使用 <code>Option</code> 和 <code>Result</code> 时会发生什么？又或者如果有一个 <code>Result&lt;T, Error1&gt;</code> 和一个 <code>Result&lt;T, Error2&gt;</code>？处理<strong>不同错误类型的组合</strong>是摆在我们面前的下一个挑战，它将成为本文其余部分的主题。</p>
<h2 id="组合-Option-与-Result">组合 <code>Option</code> 与 <code>Result</code></h2>
<p>到目前为止，我已经讨论了为 <code>Option</code> 定义的组合器和为 <code>Result</code> 定义的组合器。我们可以使用这些组合器来组合不同计算的结果，而无需进行明确的模式匹配。</p>
<p>但是在实际代码中，事情并不总是那么简单。有时你需要混合使用 <code>Option</code> 和 <code>Result</code> 类型。我们是否必须诉诸明确的模式匹配，还是可以继续使用组合器？</p>
<p>现在，让我们重新回顾本文中的第一个示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">argv</span> = env::<span class="title function_ invoke__">args</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arg</span>: <span class="type">String</span> = argv.<span class="title function_ invoke__">nth</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// error 1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = arg.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// error 2</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="number">2</span> * n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $ cargo run --bin unwrap-double 5</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>鉴于我们刚学会的 <code>Option</code>，<code>Result</code> 以及它们的各种组合器，我们应该尝试改写这个程序，以让错误得到妥善处理：当没有错误时，程序不应该崩溃。</p>
<p>这里的棘手问题是 <code>argv.nth(1)</code> 返回一个 <code>Option</code>，而 <code>arg.parse()</code> 返回一个 <code>Result</code>，这些不是可以直接组合的。当同时面对 <code>Option</code> 和 <code>Result</code> 时，解决方案通常<strong>是将 <code>Option</code> 转换为 <code>Result</code></strong>。在我们的示例中，命令行参数如果为空（来自 <code>env::args()</code>）表示用户未正确调用程序。我们可以使用 <code>String</code> 来描述这个错误。我们试试吧：</p>
<figure class="highlight rust"><figcaption><span>error-double-string</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">double_arg</span>(<span class="keyword">mut</span> argv: env::Args) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    argv.<span class="title function_ invoke__">nth</span>(<span class="number">1</span>)</span><br><span class="line">        .<span class="title function_ invoke__">ok_or</span>(<span class="string">&quot;Please give at least one argument&quot;</span>.<span class="title function_ invoke__">to_owned</span>())</span><br><span class="line">        .<span class="title function_ invoke__">and_then</span>(|arg| arg.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map_err</span>(|err| err.<span class="title function_ invoke__">to_string</span>()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">double_arg</span>(env::<span class="title function_ invoke__">args</span>()) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此示例中，有一些新东西。首先是 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or"><code>Option::ok_or</code></a> 组合器的使用。这是将 <code>Option</code> 转换为 <code>Result</code> 的一种方法。转换需要你指定如果 <code>Option</code> 是 <code>None</code>，会使用什么错误。就像我们看到的其他组合器一样，其定义非常简单：</p>
<figure class="highlight rust"><figcaption><span>option-ok-or-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">ok_or</span>&lt;T, E&gt;(option: <span class="type">Option</span>&lt;T&gt;, err: E) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> option &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(val) =&gt; <span class="title function_ invoke__">Ok</span>(val),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="title function_ invoke__">Err</span>(err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用的另一个新的组合器是 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>Result::map_err</code></a>。类似于<code>Result::map</code>，但它将函数映射到<code>Result</code>的<strong>错误</strong>部分上。如果<code>Result</code>是一个<code>Ok(...)</code>值，则将其返回原样。</p>
<p>我们之所以在这里使用 <code>map_err</code>，是因为错误类型必须保持相同（因为我们使用 <code>and_then</code>）。由于我们选择将 <code>Option&lt;String&gt;</code>（来自于 <code>argv.nth(1)</code>）转换为 <code>Result&lt;String, String&gt;</code>，因此我们还必须将 <code>ParseIntError</code>（来自于 <code>arg.parse()</code>）转换为 <code>String</code>。</p>
<h2 id="组合器的限制">组合器的限制</h2>
<p>进行 IO 和解析输入是一项非常常见的任务，这也是我个人在 Rust 中做的比较多的工作。因此，我们将使用 IO 和各种解析例程来举例说明错误处理。</p>
<p>让我们从一个简单的例子开始。我们的任务是打开文件，读取文件的所有内容并将其内容转换为数字。然后，将其乘以 <code>2</code> 并打印输出。</p>
<p>尽管我尝试说服你不要使用 <code>unwrap</code>，但是开始编写代码时 <code>unwrap</code> 是很有用的。它使你可以专注于问题而不是错误处理，并且可以揭示需要进行正确错误处理的地方。让我们开始编写第一版程序，然后对其进行重构，以使用更好的错误处理。</p>
<figure class="highlight rust"><figcaption><span>io-basic-unwrap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(file_path).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// error 1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// error 2</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = contents.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// error 3</span></span><br><span class="line">    <span class="number">2</span> * n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">doubled</span> = <span class="title function_ invoke__">file_double</span>(<span class="string">&quot;foobar&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, doubled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（N.B. 使用 <code>AsRef&lt;Path&gt;</code> 因为它们是使用在 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>std::fs::File::open</code></a> 上的<a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open">相同参数类型</a>。这使得使用任何类型的字符串作为文件路径都符合工程学。）</p>
<p>这里可能会发生三种不同的错误：</p>
<ol>
<li>打开文件时出现问题。</li>
<li>从文件读取数据时出现问题。</li>
<li>将数据解析为数字时出现问题。</li>
</ol>
<p>前两个问题属于 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/io/struct.Error.html"><code>std::io::Error</code></a> 类型 ，这一点可以从 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>std::fs::File::open</code></a> 和 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>std::io::Read::read_to_string</code></a> 的返回类型中得知 。（请注意，它们都使用前面描述的 <code>Result</code> 类型别名。如果单击 <code>Result</code> 类型，你将看到<a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/io/type.Result.html">类型别名</a>，并因此看到基础的 <code>io::Error</code> 类型。）第三个问题属于 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a> 类型。<code>io::Error</code> 这种类型在整个标准库中的使用非常广泛，你将经常看到它。</p>
<p>让我们开始重构 <code>file_double</code> 函数。为了使此功能可与程序的其他组件组合，如果满足上述任何错误条件，则不要 <code>panic</code>。实际上，这意味着该函数在任何操作失败时都应<strong>返回错误</strong>。我们的问题是 <code>file_double</code> 的返回类型为 <code>i32</code>，这无法为我们提供任何有用的报告错误的方式。因此，我们必须首先将返回类型从 <code>i32</code> 更改为其他类型。</p>
<p>我们需要决定的第一件事：我们应该使用 <code>Option</code> 还是 <code>Result</code>？使用 <code>Option</code> 非常简单，如果发生三个错误中的任何一个，我们可以简单地返回 <code>None</code>。这有一定效果，<em>并且比 <code>panic</code> 更好</em>，但是我们可以做得更好，我们应该传递一些有关发生的错误的详细信息。由于我们要表达<strong>错误的可能性</strong>，因此应使用 <code>Result&lt;i32, E&gt;</code>。但是 <code>E</code> 应该是什么呢？由于可能发生两种不同类型的错误，因此我们需要将它们转换为常见类型。一种这样的类型是 <code>String</code>。让我们看看这如何影响我们的代码：</p>
<figure class="highlight rust"><figcaption><span>io-basic-error-string</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(file_path)</span><br><span class="line">         .<span class="title function_ invoke__">map_err</span>(|err| err.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">         .<span class="title function_ invoke__">and_then</span>(|<span class="keyword">mut</span> file| &#123;</span><br><span class="line">              <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">              file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents)</span><br><span class="line">                  .<span class="title function_ invoke__">map_err</span>(|err| err.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">                  .<span class="title function_ invoke__">map</span>(|_| contents)</span><br><span class="line">         &#125;)</span><br><span class="line">         .<span class="title function_ invoke__">and_then</span>(|contents| &#123;</span><br><span class="line">              contents.<span class="title function_ invoke__">trim</span>().parse::&lt;<span class="type">i32</span>&gt;()</span><br><span class="line">                      .<span class="title function_ invoke__">map_err</span>(|err| err.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">         &#125;)</span><br><span class="line">         .<span class="title function_ invoke__">map</span>(|n| <span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">file_double</span>(<span class="string">&quot;foobar&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码看起来有些复杂。像这样的代码可能需要大量的练习才能变得容易编写，我写的方式是<em>遵循返回类型</em>。一旦将 <code>file_double</code> 返回类型更改为 <code>Result&lt;i32, String&gt;</code>，我就必须开始寻找合适的组合器。在这种情况下，我们只用了三种不同的组合程序：<code>and_then</code>，<code>map</code> 和 <code>map_err</code>。</p>
<p><code>and_then</code> 用于链接多个计算，其中每个计算都可能返回错误。打开文件后，还有另外两个可能失败的计算：从文件读取并将内容解析为数字，相应地，有两个 <code>and_then</code> 调用。</p>
<p><code>map</code> 用于将函数应用于 <code>Result</code> 的 <code>Ok(...)</code> 值。例如，最后一次调用 <code>map</code> 将 <code>Ok(...)</code> 值（<code>i32</code>）乘以 <code>2</code>。如果在此之前发生了错误，则由于 <code>map</code> 定义的方式，该操作将被跳过。</p>
<p><code>map_err</code> 是使所有这些工作都有效的技巧。<code>map_err</code> 就像 <code>map</code> 一样，只是它对 <code>Result</code> 的 <code>Err(...)</code> 值应用了一个函数。在这种情况下，我们希望将所有错误都转换为一种类型：<code>String</code>。由于 <code>io::Error</code> 和 <code>num::ParseIntError</code> 实现 <code>ToString</code>，我们可以调用 <code>to_string()</code> 方法将其转换。</p>
<p>综上所述，代码仍然很繁琐。掌握组合器的用法很重要，但是它们有其局限性。让我们尝试另一种方法：<strong>提前返回</strong>。</p>
<h2 id="提取返回">提取返回</h2>
<p>我想使用<strong>提前返回</strong>重写上一节的代码。提前返回可以让你尽早退出该功能。我们在 <code>file_double</code> 中无法从一个闭包内部提前返回，因此我们需要恢复为显式的模式匹配。</p>
<figure class="highlight rust"><figcaption><span>io-basic-error-string-early-return</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = <span class="keyword">match</span> File::<span class="title function_ invoke__">open</span>(file_path) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(err) = file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = <span class="keyword">match</span> contents.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; n,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">file_double</span>(<span class="string">&quot;foobar&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部分人可能不认为此代码是比使用组合器的代码更好，但是，如果你不熟悉组合器方法，那么这段代码看起来将会更简单。它使用带有 <code>match</code> 和 <code>if let</code> 的显式模式匹配。如果发生错误，它只是停止执行该函数并返回错误（通过将其转换为字符串）。</p>
<p>这不是倒退一步吗？之前，我曾说过，工程学错误处理的关键是减少显式模式匹配，但是我们在这里已恢复为显式模式匹配。事实证明，有多种方法可以减少显式模式匹配，组合器不是唯一的方法。</p>
<h2 id="try-宏-操作符"><code>try!</code> 宏/<code>?</code> 操作符</h2>
<p>在较旧的 Rust 版本（Rust 1.12 或更早版本）中，Rust 中错误处理的基石是 <code>try!</code> 宏。<code>try!</code> 宏将模式匹配抽象成组合器，但不同于组合器，它也抽象<em>控制流</em>。即，它可以抽象出上面看到的<em>提前返回</em>模式。</p>
<p>这是<code>try!</code>宏的简化定义：</p>
<figure class="highlight rust"><figcaption><span>try-def-simple</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> <span class="keyword">try</span> &#123;</span><br><span class="line">    ($e:expr) =&gt; (<span class="keyword">match</span> $e &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(val) =&gt; val,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（ <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/macro.try!.html">真实的定义</a> 要复杂得多。我们将在以后再看。）</p>
<p>使用 <code>try!</code> 宏可以很容易地简化我们的示例。由于它可以进行模式匹配并为我们实现提前返回，因此我们获得了更易于阅读的紧凑代码：</p>
<figure class="highlight rust"><figcaption><span>io-basic-error-try</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = <span class="built_in">try!</span>(File::<span class="title function_ invoke__">open</span>(file_path).<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="built_in">try!</span>(file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents).<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="built_in">try!</span>(contents.<span class="title function_ invoke__">trim</span>().parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">file_double</span>(<span class="string">&quot;foobar&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>map_err</code> 调用仍然需要传递给我们的 <code>try!</code> 定义。这是因为错误类型仍需要转换为 <code>String</code>。好消息是，我们将很快学习如何删除这些 <code>map_err</code> 调用！坏消息是，在删除 <code>map_err</code> 调用之前，我们将需要更多地了解标准库中的几个重要特征。</p>
<p>在较新版本的 Rust（Rust 1.13 或更高版本）中，该 <code>try!</code> 宏已替换为 <code>?</code> 操作符。虽然它打算增加我们在这里不会介绍的新功能，但是使用 <code>?</code> 代替<code>try!</code> 是很简单的：</p>
<figure class="highlight rust"><figcaption><span>io-basic-error-question</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(file_path).<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>())?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents).<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>())?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = contents.<span class="title function_ invoke__">trim</span>().parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>())?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">file_double</span>(<span class="string">&quot;foobar&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义自己的错误类型">定义自己的错误类型</h2>
<p>在深入探讨一些标准库错误 traits 之前，我想通过在前面的示例中删除对我们的错误类型 <code>String</code> 的使用来结束本节。</p>
<p><code>String</code> 像在前面的示例中一样，使用起来很方便，因为很容易将错误转换为字符串，甚至可以当场将自己的错误作为字符串来实现。但是，使用 <code>String</code> 错误会带来一些不利影响。</p>
<p>第一个缺点是错误消息往往会使你的代码变得混乱。可以在其他地方定义错误消息，但是除非你受过特别的训练，否则很难将错误消息嵌入代码中。确实，我们在前面的示例中完全做到了这一点。</p>
<p>第二个更重要的缺点是 <code>String</code> 是<strong>有损的</strong>。也就是说，如果所有错误都转换为字符串，那么我们传递给调用方的错误将变得完全不透明。调用者可以对 <code>String</code> 错误进行的唯一合理的处理就是将其显示给用户。当然，检查字符串以确定错误的类型并不可靠。（诚然，与应用程序相比，此缺点在库内部要重要得多。）</p>
<p>例如，<code>io::Error</code> 类型嵌入 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>io::ErrorKind</code></a>，这是表示 IO 操作期间出了什么问题的<em>结构化数据</em>。这很重要，因为你可能希望根据错误做出不同的反应。（例如，<code>BrokenPipe</code> 错误可能意味着优雅地退出程序，而 <code>NotFound</code> 错误可能意味着退出并显示错误代码以向用户显示错误。）使用 <code>io::ErrorKind</code>，调用者可以使用模式匹配检查错误的类型，这绝对优于试图弄清楚一个 <code>String</code> 错误的细节。</p>
<p>与其在前面的从文件中读取整数的示例中将 <code>String</code> 用作错误类型，不如定义自己的错误类型，该错误类型表示结构化数据中的错误。如果调用者想检查详细信息，我们将努力不从潜在错误中删除信息。</p>
<p>表示<em>多种可能性之一</em>的理想方法是定义自己的枚举类型 <code>enum</code>。在我们的例子中，错误是 <code>io::Error</code> 或 <code>num::ParseIntError</code>，因此很自然地定义为：</p>
<figure class="highlight rust"><figcaption><span>io-basic-error-custom</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We derive `Debug` because all types should probably derive `Debug`.</span></span><br><span class="line"><span class="comment">// This gives us a reasonable human readable description of `CliError` values.</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Io</span>(io::Error),</span><br><span class="line">    <span class="title function_ invoke__">Parse</span>(num::ParseIntError),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整我们的代码非常容易。无需将错误转换为字符串，我们只需使用相应的值构造函数将它们转换为我们的类型 <code>CliError</code> 即可：</p>
<figure class="highlight rust"><figcaption><span>io-basic-error-custom</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, CliError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(file_path).<span class="title function_ invoke__">map_err</span>(CliError::Io)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents).<span class="title function_ invoke__">map_err</span>(CliError::Io)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = contents.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">map_err</span>(CliError::Parse)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">file_double</span>(<span class="string">&quot;foobar&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;:?&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唯一的更改是将 <code>map_err(|e| e.to_string())</code>（将错误转换为字符串）切换到 <code>map_err(CliError::Io)</code> 或 <code>map_err(CliError::Parse)</code>，调用者可以通过问题的错误等级决定是否向用户报告。实际上，将 <code>String</code> 用作错误类型会从调用方中删除这种选择，而使用自定义 <code>enum</code> 错误类型，例如 <code>CliError</code>，除了描述错误的结构化数据外，还可以像以前一样为调用方提供很多便利。</p>
<p><strong>经验法则</strong>是尽量定义自己的错误类型，但是 <code>String</code> 错误类型会在一定程度上发生，特别是在编写应用程序时。如果要编写库，则强烈建议定义自己的错误类型，以免不必要地从调用方中删除选择。</p>
<h1>用于错误处理的标准库 traits</h1>
<p>标准库为错误处理定义了两个不可或缺的 trait： <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a> 和 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>std::convert::From</code></a>。尽管 <code>Error</code> 专为一般性地描述错误而设计，但是 <code>From</code> trait 在两个不同类型之间转换值时起更一般的作用。</p>
<h2 id="Error-trait"><code>Error</code> trait</h2>
<p><code>Error</code> trait 在<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/error/trait.Error.html">标准库中的定义</a>如下：</p>
<figure class="highlight rust"><figcaption><span>error-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::&#123;<span class="built_in">Debug</span>, Display&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Error</span>: <span class="built_in">Debug</span> + Display &#123;</span><br><span class="line">  <span class="comment">/// A short description of the error.</span></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">description</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The lower level cause of this error, if any.</span></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">cause</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;Error&gt; &#123; <span class="literal">None</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此 trait 是非常通用的，因为它打算表示<strong>错误的所有类型</strong>。我们将在后面看到这对编写可组合代码很有帮助。简单地说，该 trait 允许你执行以下操作：</p>
<ul>
<li>获取 <code>Debug</code> 错误的表示形式。</li>
<li>获取 <code>Display</code> 错误的面向用户的表示形式。</li>
<li>获得错误的简短描述（通过 <code>description</code> 方法）。</li>
<li>检查错误的因果链（如果存在）（通过 <code>cause</code> 方法）。</li>
</ul>
<p>前两个来自于 <code>Error</code> 要求实现 <code>Debug</code> 和 <code>Display</code>。后两者来自 <code>Error</code> 上定义的两种方法。<code>Error</code> 的力量来自所有错误类型均隐含 <code>Error</code> 的事实，这意味着可以将存在的错误量化为 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/1.0.0-beta.5/book/trait-objects.html">trait 对象</a>，这表现为 <code>Box&lt;Error&gt;</code> 或 <code>&amp;Error</code>。实际上，<code>cause</code> 方法返回一个 <code>&amp;Error</code>，它本身就是一个 trait 对象。稍后，我们将重新使用 <code>Error</code> trait 作为 trait 对象。</p>
<p>就目前而言，已经能够通过实现 <code>Error</code>trait 编写示例。让我们使用上一节中定义的错误类型 ：</p>
<figure class="highlight rust"><figcaption><span>error-impl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We derive `Debug` because all types should probably derive `Debug`.</span></span><br><span class="line"><span class="comment">// This gives us a reasonable human readable description of `CliError` values.</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Io</span>(io::Error),</span><br><span class="line">    <span class="title function_ invoke__">Parse</span>(num::ParseIntError),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种特殊的错误类型表示可能发生两种类型的错误：处理 I/O 的错误或将字符串转换为数字的错误。通过向 <code>enum</code> 定义添加新的变体，该错误可以表示所需的错误类型。</p>
<p>为其实现 <code>Error</code> 非常简单，主要是要进行很多显式的模式匹配。</p>
<figure class="highlight rust"><figcaption><span>error-impl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="comment">// Both underlying errors already impl `Display`, so we defer to</span></span><br><span class="line">            <span class="comment">// their implementations.</span></span><br><span class="line">            CliError::<span class="title function_ invoke__">Io</span>(<span class="keyword">ref</span> err) =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;IO error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">            CliError::<span class="title function_ invoke__">Parse</span>(<span class="keyword">ref</span> err) =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;Parse error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">error</span>::Error <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">description</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="comment">// Both underlying errors already impl `Error`, so we defer to their</span></span><br><span class="line">        <span class="comment">// implementations.</span></span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            CliError::<span class="title function_ invoke__">Io</span>(<span class="keyword">ref</span> err) =&gt; err.<span class="title function_ invoke__">description</span>(),</span><br><span class="line">            <span class="comment">// Normally we can just write `err.description()`, but the error</span></span><br><span class="line">            <span class="comment">// type has a concrete method called `description`, which conflicts</span></span><br><span class="line">            <span class="comment">// with the trait method. For now, we must explicitly call</span></span><br><span class="line">            <span class="comment">// `description` through the `Error` trait.</span></span><br><span class="line">            CliError::<span class="title function_ invoke__">Parse</span>(<span class="keyword">ref</span> err) =&gt; error::Error::<span class="title function_ invoke__">description</span>(err),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cause</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;error::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="comment">// N.B. Both of these implicitly cast `err` from their concrete</span></span><br><span class="line">            <span class="comment">// types (either `&amp;io::Error` or `&amp;num::ParseIntError`)</span></span><br><span class="line">            <span class="comment">// to a trait object `&amp;Error`. This works because both error types</span></span><br><span class="line">            <span class="comment">// implement `Error`.</span></span><br><span class="line">            CliError::<span class="title function_ invoke__">Io</span>(<span class="keyword">ref</span> err) =&gt; <span class="title function_ invoke__">Some</span>(err),</span><br><span class="line">            CliError::<span class="title function_ invoke__">Parse</span>(<span class="keyword">ref</span> err) =&gt; <span class="title function_ invoke__">Some</span>(err),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这是一个非常典型的 <code>Error</code> 实现：匹配不同的错误类型，并实现 <code>description</code> 和 <code>cause</code> 的定义。</p>
<h2 id="From-trait"><code>From</code> trait</h2>
<p><code>std::convert::From</code> trait 也是<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.From.html">定义在标准库中</a>:</p>
<figure class="highlight rust"><figcaption><span>from-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">From</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是非常简单？<code>From</code> 之所以非常有用，是因为它为我们提供了一种通用的方式来实现从特定类型 <code>T</code> 到其他类型的转换（在这种情况下，“其他类型”是 <code>impl</code> 的主体，也即是 <code>Self</code>）。<code>From</code> 有<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.From.html">标准库提供的一组实现</a>。</p>
<p>以下是一些简单的示例，说明其 <code>From</code> 工作方式：</p>
<figure class="highlight rust"><figcaption><span>from-examples</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">string</span>: <span class="type">String</span> = <span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">bytes</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = <span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">cow</span>: ::std::borrow::Cow&lt;<span class="type">str</span>&gt; = <span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>OK，因此 <code>From</code> 对于在字符串之间进行转换很有用。那么错误呢？同样有一个关键的实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, E: Error + <span class="symbol">&#x27;a</span>&gt; <span class="built_in">From</span>&lt;E&gt; <span class="keyword">for</span> <span class="title class_">Box</span>&lt;Error + <span class="symbol">&#x27;a</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这个实现表示对于<strong>任何</strong>实现了 <code>Error</code> 的类型，我们可以将它转换为 trait 对象 <code>Box&lt;Error&gt;</code>，这在一般情况下很有用。</p>
<p>还记得我们以前处理的两个错误吗？也就是，<code>io::Error</code> 和 <code>num::ParseIntError</code>。既然都实现了 <code>Error</code>，它们同样可以使用 <code>From</code>：</p>
<figure class="highlight rust"><figcaption><span>from-examples-errors</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We have to jump through some hoops to actually get error values.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">io_err</span>: io::Error = io::Error::<span class="title function_ invoke__">last_os_error</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">parse_err</span>: num::ParseIntError = <span class="string">&quot;not a number&quot;</span>.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap_err</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK, here are the conversions.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">err1</span>: <span class="type">Box</span>&lt;Error&gt; = <span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(io_err);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">err2</span>: <span class="type">Box</span>&lt;Error&gt; = <span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(parse_err);</span><br></pre></td></tr></table></figure>
<p>注意这里有一个非常重要的模式。两个 <code>err1</code> 和 <code>err2</code> 具有<em>相同的类型</em>。这是因为它们是表示上完全相同的类型或 trait 对象。并且，编译器删除了它们的底层类型，因此在编译器看来，<code>err1</code> 和 <code>err2</code> 完全相同。此外，我们构造 <code>err1</code> 和 <code>err2</code> 使用了完全相同的函数调用：<code>From::from</code>。这是因为 <code>From::from</code> 在其参数和返回类型上都重载了。</p>
<p>此模式很重要，因为它解决了我们先前遇到的一个问题：提供了一种使用相同函数，将错误转换为相同类型的方法。</p>
<p>是时候重温一个老朋友了：<code>try!</code> 宏/ <code>?</code> 操作符。</p>
<h2 id="实际的-try-宏-操作符">实际的 <code>try!</code> 宏/ <code>?</code> 操作符</h2>
<p>之前，我介绍了 <code>try!</code> 的定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> <span class="keyword">try</span> &#123;</span><br><span class="line">    ($e:expr) =&gt; (<span class="keyword">match</span> $e &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(val) =&gt; val,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这不是真实的定义。它<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/macro.try!.html">在标准库中</a>的真正定义：</p>
<figure class="highlight rust"><figcaption><span>try-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> <span class="keyword">try</span> &#123;</span><br><span class="line">    ($e:expr) =&gt; (<span class="keyword">match</span> $e &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(val) =&gt; val,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(::std::convert::<span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(err)),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个微小而强大的更改：错误值 <code>From::from</code> 通过传递。这使 <code>try!</code> 宏的功能更加强大，因为它为你提供了自动类型转换。这也与 <code>?</code> 操作符的工作方式非常相似，但后者的定义略有不同，即 <code>x?</code> 类似以下内容：</p>
<figure class="highlight rust"><figcaption><span>questionmark-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> ::std::ops::Try::<span class="title function_ invoke__">into_result</span>(x) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(v) =&gt; v,</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> ::std::ops::Try::<span class="title function_ invoke__">from_error</span>(<span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(e)),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Try.html"><code>Try</code> trait</a> 暂时还在修改，不在本文的讨论范围之内，但是其本质是它提供了一种对许多不同类型的成功/失败模式进行抽象的方法，而无需与 <code>Result&lt;T, E&gt;</code> 紧密联系。如你所见，<code>x?</code> 语法仍然调用 <code>From::from</code>，这是我们实现自动错误转换的方式。</p>
<p>由于目前编写的大多数代码都使用 <code>?</code> 代替 <code>try!</code>，因此我们将在本文的其余部分中继续使用 <code>?</code>。</p>
<p>让我们看一下我们之前编写的用于读取文件并将其内容转换为整数的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(file_path).<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>())?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents).<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>())?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = contents.<span class="title function_ invoke__">trim</span>().parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map_err</span>(|e| e.<span class="title function_ invoke__">to_string</span>())?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前，我说过我们可以不调用 <code>map_err</code>。确实，我们要做的就是选择一种适用 <code>From</code> 的类型。正如我们在上一节中所看到的，<code>From</code> 的实现可以让我们将任何错误类型转换为 <code>Box&lt;Error&gt;</code>：</p>
<figure class="highlight rust"><figcaption><span>io-basic-error-try-from</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">Box</span>&lt;Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(file_path)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = contents.<span class="title function_ invoke__">trim</span>().parse::&lt;<span class="type">i32</span>&gt;()?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们已经非常接近理想的错误处理。我们的代码在错误处理上的开销很小，因为 <code>?</code> 操作符同时封装了三件事：</p>
<ol>
<li>模式匹配。</li>
<li>控制流。</li>
<li>错误类型转换。</li>
</ol>
<p>当三者结合在一起时，我们得到的代码不受组合器，调用 <code>unwrap</code> 或模式匹配的束缚。</p>
<p>剩下的只有一点点：<code>Box&lt;Error&gt;</code> 类型是<em>不透明的</em>。如果我们返回 <code>Box&lt;Error&gt;</code> 给调用方，则调用方将无法检查潜在的错误类型。虽然这种情况肯定比返回 <code>String</code> 要好，因为调用者可以调用诸如 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/error/trait.Error.html#tymethod.description"><code>description</code></a> 和 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/error/trait.Error.html#method.cause"><code>cause</code></a>的方法，但局限性仍然是：<code>Box&lt;Error&gt;</code> 不透明。（注意，这并非完全正确，因为 Rust 确实具有运行时反射，这在<a target="_blank" rel="noopener" href="https://crates.io/crates/error">超出本文范围的</a>某些情况下很有用。）</p>
<p>现在该重新审视我们的自定义 <code>CliError</code> 类型并将所有内容整合在一起。</p>
<h2 id="组合自定义错误类型">组合自定义错误类型</h2>
<p>在上一节中，我们研究了 <code>?</code> 运算符以及它如何通过调用 <code>From::from</code> 错误值为我们完成自动类型转换。特别是，我们可以将错误转换为 <code>Box&lt;Error&gt;</code>，但是类型对于调用者是不透明的。</p>
<p>要解决此问题，我们使用我们已经熟悉的相同补救措施：自定义错误类型。下面仍然是读取文件内容并将其转换为整数的代码：</p>
<figure class="highlight rust"><figcaption><span>io-basic-error-custom-from</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"><span class="keyword">use</span> std::num;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We derive `Debug` because all types should probably derive `Debug`.</span></span><br><span class="line"><span class="comment">// This gives us a reasonable human readable description of `CliError` values.</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Io</span>(io::Error),</span><br><span class="line">    <span class="title function_ invoke__">Parse</span>(num::ParseIntError),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double_verbose</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, CliError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(file_path).<span class="title function_ invoke__">map_err</span>(CliError::Io)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents).<span class="title function_ invoke__">map_err</span>(CliError::Io)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = contents.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">map_err</span>(CliError::Parse)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，我们仍然有 <code>map_err</code> 的调用。为什么？回想一下 <code>?</code> 运算符和 <code>From</code> 的定义，问题在于，没有 <code>From</code> 实现使我们能够从错误类型（例如 <code>io::Error</code> 和 <code>num::ParseIntError</code>）转换为我们自己的自定义类型 <code>CliError</code>。当然，解决这个问题很容易！既然定义了 <code>CliError</code>，我们就可以为它实现 <code>From</code>：</p>
<figure class="highlight rust"><figcaption><span>io-basic-error-custom-from</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;io::Error&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(err: io::Error) <span class="punctuation">-&gt;</span> CliError &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">Io</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;num::ParseIntError&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(err: num::ParseIntError) <span class="punctuation">-&gt;</span> CliError &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">Parse</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有这些实现正在做的事情是教导 <code>From</code> 如何从其他错误类型创建 <code>CliError</code>。在我们的例子中，实现就像调用相应的值构造函数一样简单。确实，这通常很容易。</p>
<p>我们终于可以重写<code>file_double</code>：</p>
<figure class="highlight rust"><figcaption><span>io-basic-error-custom-from</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">file_double</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, CliError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(file_path)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">contents</span> = String::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> contents)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i32</span> = contents.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>()?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在这里所做的唯一一件事就是删除对 <code>map_err</code> 的调用。不再需要它们，因为 <code>?</code> 运算符会在错误值上调用 <code>From::from</code>。之所以有效，是因为我们为所有可能出现的错误类型提供了 <code>From</code> 的实现。</p>
<p>如果我们修改 <code>file_double</code> 函数以执行其他操作，例如，将字符串转换为浮点数，则需要为错误类型添加新的变体：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Io</span>(io::Error),</span><br><span class="line">    <span class="title function_ invoke__">ParseInt</span>(num::ParseIntError),</span><br><span class="line">    <span class="title function_ invoke__">ParseFloat</span>(num::ParseFloatError),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了反映此更改，我们需要更新之前的 <code>impl From&lt;num::ParseIntError&gt; for CliError</code> 并添加新的 <code>impl From&lt;num::ParseFloatError&gt; for CliError</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;num::ParseIntError&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(err: num::ParseIntError) <span class="punctuation">-&gt;</span> CliError &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">ParseInt</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;num::ParseFloatError&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(err: num::ParseFloatError) <span class="punctuation">-&gt;</span> CliError &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">ParseFloat</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是这样！</p>
<h2 id="对库作者的建议">对库作者的建议</h2>
<p>Rust 库的范式仍在形成，但是如果你的库需要报告自定义错误，那么你可能需要定义自己的错误类型。是否公开其表示形式（如 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>ErrorKind</code></a>）或使其隐藏（如 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>）取决于你。无论如何执行，通常最好的做法是至少提供有关错误的信息，而不仅仅是其 <code>String</code> 表示形式。但是可以肯定的是，这将取决于用例。</p>
<p>至少，你应该实现 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a> trait。这将使你的库用户在组合错误类型时有一定的灵活性。实施此 <code>Error</code> 特征还意味着要确保用户具有获取错误的字符串表示形式的能力（因为它要求实现 <code>fmt::Debug</code> 和 <code>fmt::Display</code>）。</p>
<p>除此之外，提供 <code>From</code> 错误类型的实现也可能很有用。这使你（库作者）和你的用户可以编写更详细的错误。例如， <a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/csv/1.0.0-beta.5/enum.Error.html"><code>csv::Error</code></a>同时为 <code>io::Error</code> 和 <code>byteorder::Error</code> 提供了 <code>From</code> 实现 。</p>
<p>最后，根据你的喜好，你可能还想定义一个 <code>Result</code> 类型别名，尤其是在你的库定义了单个错误类型的情况下。这是在标准库使用的 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a> 和 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/fmt/type.Result.html"><code>fmt::Result</code></a>。</p>
<h1>案例学习: 读取人口数据</h1>
<p>这个案例很长，根据你的知识背景，可能会比较复杂。虽然有很多示例代码与说明一起使用，但大多数代码都是专门为教学目的而设计的。虽然我不够聪明，无法制作既不是玩具示例又能够实现教学的示例，但我可以撰写实际案例。</p>
<p>为此，我想构建一个命令行程序，让你查询世界人口数据。目标很简单：你给它一个位置，它将告诉你人口数据。尽管简单，但仍有很多地方可能出错！</p>
<p>我们将使用的<a target="_blank" rel="noopener" href="https://github.com/petewarden/dstkdata">数据</a>来自 <a target="_blank" rel="noopener" href="https://github.com/petewarden/dstkdata">Data Science Toolkit</a>。我已经为此练习准备了一些数据。你可以获取 <a target="_blank" rel="noopener" href="https://burntsushi.net/stuff/worldcitiespop.csv.gz">世界人口数据</a> （41MB gzip 压缩，145MB 未压缩），也可以仅获取 <a target="_blank" rel="noopener" href="https://burntsushi.net/stuff/uscitiespop.csv.gz">美国人口数据</a> （2.2MB gzip 压缩，7.2MB 未压缩）。</p>
<p>到目前为止，我一直将代码限制为 Rust 的标准库。但是对于像这样的真实任务，我们至少要使用某种东西来解析CSV数据，解析程序参数并将这些东西自动解码为 Rust 类型。为此，我们将使用 <a target="_blank" rel="noopener" href="https://crates.io/crates/csv"><code>csv</code></a>， <a target="_blank" rel="noopener" href="https://crates.io/crates/docopt"><code>docopt</code></a> 和<a target="_blank" rel="noopener" href="https://crates.io/crates/rustc-serialize"><code>rustc-serialize</code></a> crate。</p>
<h2 id="在-Github-上获取">在 Github 上获取</h2>
<p>该案例研究的最终代码<a target="_blank" rel="noopener" href="https://github.com/BurntSushi/rust-error-handling-case-study">在Github上</a>。如果你安装了Rust和Cargo，那么你要做的就是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/BurntSushi/rust-error-handling-case-study</span><br><span class="line"><span class="built_in">cd</span> rust-error-handling-case-study</span><br><span class="line">cargo build --release</span><br><span class="line">./target/release/city-pop --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>我们将逐步构建该项目。继续！</p>
<h2 id="初始化">初始化</h2>
<p>我不会花很多时间在 Cargo 上建立项目，因为 <a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch01-03-hello-cargo.html">Rust Book</a> 和 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/cargo/guide/">Cargo的文档 </a> 已经很好地介绍了该项目 。</p>
<p>要从头开始，请运行 <code>cargo new --bin city-pop</code> 并确保你的 <code>Cargo.toml</code> 如下所示：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">package</span>]</span><br><span class="line"><span class="string">name</span> <span class="string">=</span> <span class="string">&quot;city-pop&quot;</span></span><br><span class="line"><span class="string">version</span> <span class="string">=</span> <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="string">authors</span> <span class="string">=</span> [<span class="string">&quot;Andrew Gallant &lt;jamslam@gmail.com&gt;&quot;</span>]</span><br><span class="line"></span><br><span class="line">[[<span class="string">bin</span>]]</span><br><span class="line"><span class="string">name</span> <span class="string">=</span> <span class="string">&quot;city-pop&quot;</span></span><br><span class="line"></span><br><span class="line">[<span class="string">dependencies</span>]</span><br><span class="line"><span class="string">csv</span> <span class="string">=</span> <span class="string">&quot;0.*&quot;</span></span><br><span class="line"><span class="string">docopt</span> <span class="string">=</span> <span class="string">&quot;0.*&quot;</span></span><br><span class="line"><span class="string">rustc-serialize</span> <span class="string">=</span> <span class="string">&quot;0.*&quot;</span></span><br></pre></td></tr></table></figure>
<p>你应该能够直接运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cargo build --release</span><br><span class="line">./target/release/city-pop</span><br><span class="line"><span class="comment">#Outputs: Hello, world!</span></span><br></pre></td></tr></table></figure>
<h2 id="参数解析">参数解析</h2>
<p>让我们首先进行参数解析。我不会在 Docopt 上介绍太多细节，但是有一个 <a target="_blank" rel="noopener" href="http://docopt.org/">不错的网页</a> 描述了它以及 <a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/docopt/">Rust crate 的文档</a>。简单地说，Docopt 从 Usage 字符串生成一个<strong>参数解析器</strong>。解析完成后，我们可以将程序参数解码为Rust 结构体。我们的程序如下，其中带有适当的 <code>extern crate</code> 语句，Usage 字符串，我们的 <code>Args</code> struct 和一个空的 <code>main</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> docopt;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> rustc_serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> USAGE: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;</span></span><br><span class="line"><span class="string">Usage: city-pop [options] &lt;data-path&gt; &lt;city&gt;</span></span><br><span class="line"><span class="string">       city-pop --help</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">    -h, --help     Show this usage message.</span></span><br><span class="line"><span class="string">&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Args</span> &#123;</span><br><span class="line">    arg_data_path: <span class="type">String</span>,</span><br><span class="line">    arg_city: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，是时候开始编写了。<a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/docopt/struct.Docopt.html#method.new">Docopt 的文档</a>说，我们可以创建一个解析器 <code>Docopt::new</code>，然后使用 <code>Docopt::decode</code> 将其解码为一个结构体。这两个函数都会返回 <a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/docopt/enum.Error.html"><code>docopt::Error</code></a>。我们可以从显式模式匹配开始：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// These use statements were added below the `extern` statements.</span></span><br><span class="line"><span class="comment">// I&#x27;ll elide them in the future. Don&#x27;t worry! It&#x27;s all on Github:</span></span><br><span class="line"><span class="comment">// https://github.com/BurntSushi/rust-error-handling-case-study</span></span><br><span class="line"><span class="comment">//use std::io::&#123;self, Write&#125;;</span></span><br><span class="line"><span class="comment">//use std::process;</span></span><br><span class="line"><span class="comment">//use docopt::Docopt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: Args = <span class="keyword">match</span> Docopt::<span class="title function_ invoke__">new</span>(USAGE) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; &#123;</span><br><span class="line">            <span class="built_in">writeln!</span>(&amp;<span class="keyword">mut</span> io::<span class="title function_ invoke__">stderr</span>(), <span class="string">&quot;&#123;&#125;&quot;</span>, err).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(dopt) =&gt; <span class="keyword">match</span> dopt.<span class="title function_ invoke__">decode</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(err) =&gt; &#123;</span><br><span class="line">                <span class="built_in">writeln!</span>(&amp;<span class="keyword">mut</span> io::<span class="title function_ invoke__">stderr</span>(), <span class="string">&quot;&#123;&#125;&quot;</span>, err).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(args) =&gt; args,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这并不是很好。为了使代码更清晰，我们可以做的一件事是编写一个宏以将消息打印到 <code>stderr</code> 然后退出：</p>
<figure class="highlight rust"><figcaption><span>fatal-def</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> fatal &#123;</span><br><span class="line">    ($($tt:tt)*) =&gt; &#123;&#123;</span><br><span class="line">        <span class="keyword">use</span> std::io::Write;</span><br><span class="line">        <span class="built_in">writeln!</span>(&amp;<span class="keyword">mut</span> ::std::io::<span class="title function_ invoke__">stderr</span>(), $($tt)*).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        ::std::process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>unwrap</code> 在这里是没问题的，因为如果失败的话，就意味着你的程序无法写入 <code>stderr</code>。一个好的经验法则是可以中止，但是可以肯定的是，如果需要，你可以做其他事情。</p>
<p>这个代码看起来更好，但是显式的模式匹配仍然很麻烦：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">args</span>: Args = <span class="keyword">match</span> Docopt::<span class="title function_ invoke__">new</span>(USAGE) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(err) =&gt; fatal!(<span class="string">&quot;&#123;&#125;&quot;</span>, err),</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(dopt) =&gt; <span class="keyword">match</span> dopt.<span class="title function_ invoke__">decode</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; fatal!(<span class="string">&quot;&#123;&#125;&quot;</span>, err),</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(args) =&gt; args,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>值得庆幸的是，<a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/docopt/enum.Error.html"><code>docopt::Error</code></a> 类型定义了一种便捷的方法 <a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/docopt/enum.Error.html#method.exit"><code>exit</code></a>，该方法可以有效地完成我们刚刚做的事情。将其与我们的组合器知识相结合，我们获得了简洁明了的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">args</span>: Args = Docopt::<span class="title function_ invoke__">new</span>(USAGE)</span><br><span class="line">                        .<span class="title function_ invoke__">and_then</span>(|d| d.<span class="title function_ invoke__">decode</span>())</span><br><span class="line">                        .<span class="title function_ invoke__">unwrap_or_else</span>(|err| err.<span class="title function_ invoke__">exit</span>());</span><br></pre></td></tr></table></figure>
<p>如果此代码成功完成，则将根据用户提供的值填充 <code>args</code>。</p>
<h2 id="编写程序逻辑">编写程序逻辑</h2>
<p>编写代码的方式各不相同，但是当我不确定如何编码问题时，错误处理通常是我要考虑的最后一件事。对于好的设计来说，这不是一个很好的做法，但是对于快速原型制作可能是有用的。在我们的案例中，由于 Rust 迫使我们对错误进行处理，这也将使程序的哪些部分可能导致错误变得显而易见。为什么？因为 Rust 将使我们调用 <code>unwrap</code>，这可以使我们很好地了解如何进行错误处理。</p>
<p>在本案例中，程序逻辑非常简单。我们需要做的就是解析提供给我们的 CSV 数据，并在匹配的行中打印出一个字段。我们开始吧。（确保添加 <code>extern crate csv;</code> 到文件的顶部。）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This struct represents the data in each row of the CSV file.</span></span><br><span class="line"><span class="comment">// Type based decoding absolves us of a lot of the nitty gritty error</span></span><br><span class="line"><span class="comment">// handling, like parsing strings as integers or floats.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Row</span> &#123;</span><br><span class="line">    country: <span class="type">String</span>,</span><br><span class="line">    city: <span class="type">String</span>,</span><br><span class="line">    accent_city: <span class="type">String</span>,</span><br><span class="line">    region: <span class="type">String</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not every row has data for the population, latitude or longitude!</span></span><br><span class="line">    <span class="comment">// So we express them as `Option` types, which admits the possibility of</span></span><br><span class="line">    <span class="comment">// absence. The CSV parser will fill in the correct value for us.</span></span><br><span class="line">    population: <span class="type">Option</span>&lt;<span class="type">u64</span>&gt;,</span><br><span class="line">    latitude: <span class="type">Option</span>&lt;<span class="type">f64</span>&gt;,</span><br><span class="line">    longitude: <span class="type">Option</span>&lt;<span class="type">f64</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: Args = Docopt::<span class="title function_ invoke__">new</span>(USAGE)</span><br><span class="line">                            .<span class="title function_ invoke__">and_then</span>(|d| d.<span class="title function_ invoke__">decode</span>())</span><br><span class="line">                            .<span class="title function_ invoke__">unwrap_or_else</span>(|err| err.<span class="title function_ invoke__">exit</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = fs::File::<span class="title function_ invoke__">open</span>(args.arg_data_path).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rdr</span> = csv::Reader::<span class="title function_ invoke__">from_reader</span>(file);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> rdr.decode::&lt;Row&gt;() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">row</span> = row.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">if</span> row.city == args.arg_city &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;: &#123;:?&#125;&quot;</span>,</span><br><span class="line">                     row.city, row.country,</span><br><span class="line">                     row.population.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;population count&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们分析可能出现的错误。我们可以从显而易见的地方开始：这三个 <code>unwrap</code> 地方为：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>fs::File::open</code></a> 可能返回 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/io/struct.Error.html"><code>io::Error</code></a>。</li>
<li><a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/csv/struct.Reader.html#method.decode"><code>csv::Reader::decode</code></a> 一次解码一个记录，但是<a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html">解码一条记录</a> （查看 <code>Iterator</code> 上的关联类型 <code>Item</code>）可能产生一个 <a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/csv/1.0.0-beta.5/enum.Error.html"><code>csv::Error</code></a>。</li>
<li>如果 <code>row.population</code> 为 <code>None</code>，则调用 <code>expect</code> 会导致 <code>panic</code>。</li>
</ol>
<p>还有其他吗？如果我们找不到匹配的城市怎么办？类似的工具 <code>grep</code> 将返回错误代码，因此我们也应该这样做。因此，我们得到了特定于我们问题的逻辑错误，IO 错误和 CSV 分析错误。我们将探索两种不同的方法来处理这些错误。</p>
<p>我想从使用 <code>Box&lt;Error&gt;</code> 开始。稍后，我们将看到定义自己的错误类型也是很有用的。</p>
<h2 id="使用-Box-Error-进行错误处理">使用 <code>Box&lt;Error&gt;</code> 进行错误处理</h2>
<p><code>Box&lt;Error&gt;</code> 的特性很合适，因为你不需要定义自己的错误类型，也不需要任何 <code>From</code> 实现。缺点是，由于 <code>Box&lt;Error&gt;</code> 是 trait 对象，因此<strong>会删除隐含的类型</strong>，这意味着编译器无法再对其基础类型进行推理。</p>
<p>让我们开始改变函数的返回类型 <code>T</code> 到 <code>Result&lt;T, OurErrorType&gt;</code> 重构我们的代码。在这种情况下，<code>OurErrorType</code> is <code>Box&lt;Error&gt;</code>。那么 <code>T</code> 是什么？我们可以将返回类型添加到<code>main</code>吗？</p>
<p>第二个问题的答案是否定的，我们不能。这意味着我们需要编写一个新函数。但是 <code>T</code> 是什么呢？最简单的方法是将匹配 <code>Row</code> 值的列表作为 <code>Vec&lt;Row&gt;</code> 返回。（更好的代码将返回一个迭代器，但这留给读者练习。）</p>
<p>让我们将代码重构为自己的函数，但保留对 <code>unwrap</code> 的调用。请注意，我们选择通过简单地忽略该行来处理人口总数缺失的可能性。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Row</span> &#123;</span><br><span class="line">    <span class="comment">// unchanged</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PopulationCount</span> &#123;</span><br><span class="line">    city: <span class="type">String</span>,</span><br><span class="line">    country: <span class="type">String</span>,</span><br><span class="line">    <span class="comment">// This is no longer an `Option` because values of this type are only</span></span><br><span class="line">    <span class="comment">// constructed if they have a population count.</span></span><br><span class="line">    count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P, city: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;PopulationCount&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">found</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = fs::File::<span class="title function_ invoke__">open</span>(file_path).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rdr</span> = csv::Reader::<span class="title function_ invoke__">from_reader</span>(file);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> rdr.decode::&lt;Row&gt;() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">row</span> = row.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">match</span> row.population &#123;</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123; &#125; <span class="comment">// skip it</span></span><br><span class="line">            <span class="title function_ invoke__">Some</span>(count) =&gt; <span class="keyword">if</span> row.city == city &#123;</span><br><span class="line">                found.<span class="title function_ invoke__">push</span>(PopulationCount &#123;</span><br><span class="line">                    city: row.city,</span><br><span class="line">                    country: row.country,</span><br><span class="line">                    count: count,</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    found</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: Args = Docopt::<span class="title function_ invoke__">new</span>(USAGE)</span><br><span class="line">                            .<span class="title function_ invoke__">and_then</span>(|d| d.<span class="title function_ invoke__">decode</span>())</span><br><span class="line">                            .<span class="title function_ invoke__">unwrap_or_else</span>(|err| err.<span class="title function_ invoke__">exit</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">pop</span> <span class="keyword">in</span> <span class="title function_ invoke__">search</span>(&amp;args.arg_data_path, &amp;args.arg_city) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;: &#123;:?&#125;&quot;</span>, pop.city, pop.country, pop.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管我们摆脱了对 <code>expect</code> 的调用（是 <code>unwrap</code> 的更好的变体），但我们仍然应该处理没有任何搜索结果的情况。</p>
<p>要将其转换为正确的错误处理，我们需要执行以下操作：</p>
<ol>
<li>将 <code>search</code> 的返回类型更改为 <code>Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt;</code>。</li>
<li>使用 <code>?</code> 运算符，以便将错误返回给调用者，而不用 <code>panic</code> 该程序。</li>
<li>处理 <code>main</code> 中的错误。</li>
</ol>
<p>让我们尝试一下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;</span><br><span class="line">         (file_path: P, city: &amp;<span class="type">str</span>)</span><br><span class="line">         <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;PopulationCount&gt;, <span class="type">Box</span>&lt;Error+<span class="built_in">Send</span>+<span class="built_in">Sync</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">found</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = fs::File::<span class="title function_ invoke__">open</span>(file_path)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rdr</span> = csv::Reader::<span class="title function_ invoke__">from_reader</span>(file);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> rdr.decode::&lt;Row&gt;() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">row</span> = row?;</span><br><span class="line">        <span class="keyword">match</span> row.population &#123;</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123; &#125; <span class="comment">// skip it</span></span><br><span class="line">            <span class="title function_ invoke__">Some</span>(count) =&gt; <span class="keyword">if</span> row.city == city &#123;</span><br><span class="line">                found.<span class="title function_ invoke__">push</span>(PopulationCount &#123;</span><br><span class="line">                    city: row.city,</span><br><span class="line">                    country: row.country,</span><br><span class="line">                    count: count,</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> found.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="built_in">From</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;No matching cities with a population were found.&quot;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(found)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同于 <code>x.unwrap()</code>，我们现在使用 <code>x?</code>。由于我们的函数返回 <code>Result&lt;T, E&gt;</code>，因此如果发生错误，<code>?</code> 操作符会从函数中提前返回。</p>
<p>这段代码有一个大陷阱：我们应该使用 <code>Box&lt;Error + Send + Sync&gt;</code> 代替 <code>Box&lt;Error&gt;</code>。我们这样做是为了将纯字符串转换为错误类型。我们需要这些额外的限制，以便我们可以使用<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.From.html">相应的 <code>From</code> impls</a>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We are making use of this impl in the code above, since we call `From::from`</span></span><br><span class="line"><span class="comment">// on a `&amp;&#x27;static str`.</span></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; <span class="built_in">From</span>&lt;&amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>&gt; <span class="keyword">for</span> <span class="title class_">Box</span>&lt;Error + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="symbol">&#x27;a</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// But this is also useful when you need to allocate a new string for an</span></span><br><span class="line"><span class="comment">// error message, usually with `format!`.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;<span class="type">String</span>&gt; <span class="keyword">for</span> <span class="title class_">Box</span>&lt;Error + <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt;</span><br></pre></td></tr></table></figure>
<p>现在，我们已经了解了如何使用 <code>Box&lt;Error&gt;</code> 进行正确的错误处理，让我们尝试使用自定义错误类型的另一种方法。但是首先，让我们从错误处理中休息一下，并增加对从 <code>stdin</code> 中读取数据的支持。</p>
<h2 id="从-stdin-读取">从 stdin 读取</h2>
<p>在我们的程序中，我们接受单个文件作为输入，并对数据进行一次传递。这意味着我们可能应该能够在 stdin 上接受输入。但是我们也喜欢当前的格式，所以让我们两者兼而有之！</p>
<p>添加对 stdin 的支持实际上非常容易。我们只需要做两件事：</p>
<ol>
<li>调整程序参数，以便在从 stdin 读取人口数据时可以接受一个参数：城市。</li>
<li>修改 <code>search</code> 功能以采用<em>可选的</em>文件路径。当为 <code>None</code> 时，它知道应该从 stdin 读取。</li>
</ol>
<p>首先，这是新的 Usage 和 <code>Args</code> 结构：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> USAGE: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;</span></span><br><span class="line"><span class="string">Usage: city-pop [options] [&lt;data-path&gt;] &lt;city&gt;</span></span><br><span class="line"><span class="string">       city-pop --help</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">    -h, --help     Show this usage message.</span></span><br><span class="line"><span class="string">&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Args</span> &#123;</span><br><span class="line">    arg_data_path: <span class="type">Option</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    arg_city: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们所做的就是在 Docopt 用法字符串中将 <code>data-path</code> 参数设置为可选，并将相应的 struct 成员 <code>arg_data_path</code> 设置为可选。<code>docopt</code> crate将处理其余部分。</p>
<p>修改 <code>search</code> 有些棘手。<code>csv</code> crate 可以解析任何实现了<a target="_blank" rel="noopener" href="https://burntsushi.net/rustdoc/csv/struct.Reader.html#method.from_reader"><code>io::Read</code></a>的类型。但是，如何在两种类型上使用相同的代码？实际上，我们可以采取几种方法。一种方法是编写 <code>search</code> 代码，使其对某些实现了 <code>io::Read</code> 的类型参数 <code>R</code> 是通用的。另一种方法是只使用 trait 对象：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;</span><br><span class="line">         (file_path: &amp;<span class="type">Option</span>&lt;P&gt;, city: &amp;<span class="type">str</span>)</span><br><span class="line">         <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;PopulationCount&gt;, <span class="type">Box</span>&lt;Error+<span class="built_in">Send</span>+<span class="built_in">Sync</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">found</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span>: <span class="type">Box</span>&lt;io::Read&gt; = <span class="keyword">match</span> *file_path &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; Box::<span class="title function_ invoke__">new</span>(io::<span class="title function_ invoke__">stdin</span>()),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="keyword">ref</span> file_path) =&gt; Box::<span class="title function_ invoke__">new</span>(fs::File::<span class="title function_ invoke__">open</span>(file_path)?),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rdr</span> = csv::Reader::<span class="title function_ invoke__">from_reader</span>(input);</span><br><span class="line">    <span class="comment">// The rest remains unchanged!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用自定义类型进行错误处理">使用自定义类型进行错误处理</h2>
<p>之前，我们学习了如何使用自定义错误类型来编写错误类型。为此，我们将错误类型定义为 <code>enum</code>，然后实现 <code>Error</code> 和 <code>From</code>。</p>
<p>由于存在三个不同的错误（IO，CSV 解析和未找到），因此我们定义一个具有三个变体的 <code>enum</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Io</span>(io::Error),</span><br><span class="line">    <span class="title function_ invoke__">Csv</span>(csv::Error),</span><br><span class="line">    NotFound,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且实现 <code>Display</code> 和 <code>Error</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            CliError::<span class="title function_ invoke__">Io</span>(<span class="keyword">ref</span> err) =&gt; err.<span class="title function_ invoke__">fmt</span>(f),</span><br><span class="line">            CliError::<span class="title function_ invoke__">Csv</span>(<span class="keyword">ref</span> err) =&gt; err.<span class="title function_ invoke__">fmt</span>(f),</span><br><span class="line">            CliError::NotFound =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;No matching cities with a \</span></span><br><span class="line"><span class="string">                                             population were found.&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Error</span> <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">description</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            CliError::<span class="title function_ invoke__">Io</span>(<span class="keyword">ref</span> err) =&gt; err.<span class="title function_ invoke__">description</span>(),</span><br><span class="line">            CliError::<span class="title function_ invoke__">Csv</span>(<span class="keyword">ref</span> err) =&gt; err.<span class="title function_ invoke__">description</span>(),</span><br><span class="line">            CliError::NotFound =&gt; <span class="string">&quot;not found&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们可以在 <code>search</code> 函数中使用 <code>CliError</code> 类型之前，我们需要提供一些 <code>From</code> 实现。我们如何知道要提供哪些实现？好吧，我们需要同时从<code>io::Error</code> 和 <code>csv::Error</code> 中转换为 <code>CliError</code>。这些是唯一的外部错误，所以我们 <code>From</code> 现在只需要两个实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;io::Error&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(err: io::Error) <span class="punctuation">-&gt;</span> CliError &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">Io</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;csv::Error&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(err: csv::Error) <span class="punctuation">-&gt;</span> CliError &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">Csv</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于定义了 <code>?</code> 运算符，因此 <code>From</code> 非常重要 。特别是，如果发生错误，则对错误进行调用 <code>From::from</code>，在这种情况下，会将其转换为我们自己的错误类型 <code>CliError</code>。</p>
<p>随着 <code>From</code> 实现的完成，我们只需要对我们的 <code>search</code> 函数进行两个小调整：返回类型和“未找到”错误。这是完整的程序：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">search</span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;</span><br><span class="line">         (file_path: &amp;<span class="type">Option</span>&lt;P&gt;, city: &amp;<span class="type">str</span>)</span><br><span class="line">         <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;PopulationCount&gt;, CliError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">found</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span>: <span class="type">Box</span>&lt;io::Read&gt; = <span class="keyword">match</span> *file_path &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; Box::<span class="title function_ invoke__">new</span>(io::<span class="title function_ invoke__">stdin</span>()),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="keyword">ref</span> file_path) =&gt; Box::<span class="title function_ invoke__">new</span>(fs::File::<span class="title function_ invoke__">open</span>(file_path)?),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rdr</span> = csv::Reader::<span class="title function_ invoke__">from_reader</span>(input);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> rdr.decode::&lt;Row&gt;() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">row</span> = row?;</span><br><span class="line">        <span class="keyword">match</span> row.population &#123;</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123; &#125; <span class="comment">// skip it</span></span><br><span class="line">            <span class="title function_ invoke__">Some</span>(count) =&gt; <span class="keyword">if</span> row.city == city &#123;</span><br><span class="line">                found.<span class="title function_ invoke__">push</span>(PopulationCount &#123;</span><br><span class="line">                    city: row.city,</span><br><span class="line">                    country: row.country,</span><br><span class="line">                    count: count,</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> found.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(CliError::NotFound)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(found)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无需其他更改。</p>
<h2 id="额外功能">额外功能</h2>
<p>如果你像我一样，那么编写通用代码会感觉不错，因为通用化的东西很酷！但是有时候，这样做是不值得的。看一下我们在上一步中所做的事情：</p>
<ol>
<li>定义了新的错误类型。</li>
<li>新增实现了 <code>Error</code>，<code>Display</code> 和两个 <code>From</code>。</li>
</ol>
<p>这里最大的缺点是我们的程序并没有改善很多。我个人喜欢它，因为我喜欢使用 <code>enum</code> 表示错误，但是这样做有很多开销，尤其是在像这样的短程序中。</p>
<p>像我们在这里一样使用自定义错误类型的一个有用方面是，<code>main</code> 函数现在可以选择以不同方式处理错误。以前，使用 <code>Box&lt;Error&gt;</code> 时，它没有太多选择：仅打印消息。我们在这里仍然这样做，但是如果我们想添加一个 <code>--quiet</code> 标志怎么办？该 <code>--quiet</code> 标志应使任何详细的输出静音。</p>
<p>现在，如果程序找不到匹配项，它将输出一条消息，说明是这样。这可能有点笨拙，特别是如果你打算将该程序用于 shell 脚本中时。</p>
<p>因此，让我们从添加标志开始。像以前一样，我们需要调整用法字符串并在 <code>Args</code> 结构中添加一个标志。<code>docopt</code> crate 完成剩下的事情：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> USAGE: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;</span></span><br><span class="line"><span class="string">Usage: city-pop [options] [&lt;data-path&gt;] &lt;city&gt;</span></span><br><span class="line"><span class="string">       city-pop --help</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">    -h, --help     Show this usage message.</span></span><br><span class="line"><span class="string">    -q, --quiet    Don&#x27;t show noisy messages.</span></span><br><span class="line"><span class="string">&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Args</span> &#123;</span><br><span class="line">    arg_data_path: <span class="type">Option</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    arg_city: <span class="type">String</span>,</span><br><span class="line">    flag_quiet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们只需要实现 “quiet” 功能即可。这需要我们在 <code>main</code> 中进行的调整：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> <span class="title function_ invoke__">search</span>(&amp;args.arg_data_path, &amp;args.arg_city) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(CliError::NotFound) <span class="keyword">if</span> args.flag_quiet =&gt; process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(err) =&gt; fatal!(<span class="string">&quot;&#123;&#125;&quot;</span>, err),</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(pops) =&gt; <span class="keyword">for</span> <span class="variable">pop</span> <span class="keyword">in</span> pops &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;: &#123;:?&#125;&quot;</span>, pop.city, pop.country, pop.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果发生 IO 错误或数据解析失败，我们不想静默输出。因此，我们采用模式匹配，以检查错误类型是否为 <code>NotFound</code> 和是否已启用 <code>--quiet</code>。如果搜索失败，我们仍然会退出代码（遵循 <code>grep</code> 的约定）。</p>
<p>如果我们坚持使用 <code>Box&lt;Error&gt;</code>，那么实现 <code>--quiet</code> 功能将非常棘手。</p>
<p>这几乎总结了我们的案例研究。从这里开始，你应该能够编写带有适当错误处理的自己的程序和库。</p>
<h1>概括</h1>
<p>由于本文很长，因此快速总结一下Rust中的错误处理很有用。这些是我的“经验法则”。他们并不是教条。每一个规则都可能会有充足的理由去反驳！</p>
<ul>
<li>如果你正在编写示例代码，并不想实现过于繁琐的错误处理，<code>unwrap</code> 应该是很好用的（不管是 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>Result::unwrap</code></a>， <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap"><code>Option::unwrap</code></a> 或更好的 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>Option::expect</code></a>）。你的代码的使用者应该知道如何使用正确的错误处理。（如果没有，让他们来看这篇文章！）</li>
<li>如果你正在编写 quick ‘n’ dirty 程序，请不要羞于使用 <code>unwrap</code>。警告：如果交接到别人的手中，当他们被错误的消息所困扰时，不要感到惊讶！</li>
<li>如果你正在编写一个 quick ‘n’ dirty 程序，并且无论如何都不想造成 <code>panic</code>，那么你应该使用如上例所示的 <code>Box&lt;Error&gt;</code> （或 <code>Box&lt;Error + Send + Sync&gt;</code>）。另一个比较好的替代方法是使用 <a target="_blank" rel="noopener" href="https://crates.io/crates/anyhow"><code>anyhow</code></a> crate 及其 <code>anyhow::Error</code> 类型。使用 <code>anyhow</code> 时，在 nightly Rust 中，你的错误将自动附加 backtraces 。</li>
<li>否则，在程序中使用适当的 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> 和 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a> 实现定义自己的错误类型，以使 <code>?</code> 操作符更加符合工程学。</li>
<li>如果你正在编写库，并且代码可能会产生错误，请定义自己的错误类型并实现 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a> trait。在适当的地方，实现 <a target="_blank" rel="noopener" href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> 使你的库代码和调用者的代码更易于编写。（由于 Rust 的一致性规则，调用者将无法为你的错误类型实现 <code>From</code>，因此你的库应该这样做。）</li>
<li>使用 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> 和 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> 上定义的组合器 。有时单独使用它们可能会有些麻烦，但是我发现，<code>?</code> 操作符和组合器的组合非常有吸引力。<code>and_then</code>，<code>map</code> 和 <code>unwrap_or</code>是我的最爱。</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Rust 中的错误处理</p><p><a href="http://blog.czccc.cc/p/d02431de/">http://blog.czccc.cc/p/d02431de/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Cheng</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-08-03</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-08-06</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/Alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/WeChat_pay.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/p/3b57f622/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">SQL 必知必会 - 数据更新/存储/事务</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/p/4c50c6b4/"><span class="level-item">SQL 必知必会 - 多表查询/联结/组合</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'http://blog.czccc.cc/p/d02431de/';
            this.page.identifier = 'p/d02431de/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'czcc' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Cheng"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Cheng</p><p class="is-size-6 is-block">A Student</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Nanjing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">54</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">26</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">50</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/czccc" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/czccc"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget column-left is-sticky" id="toc" data-type="toc"><div class="card-content"><div class="menu" style="max-height: calc(100vh - 5rem); overflow-y: auto;"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#"><span class="level-left"><span class="level-item">1</span><span class="level-item">Rust 中的错误处理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简要说明-2"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">简要说明</span></span></a></li><li><a class="level is-mobile" href="#运行代码"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">运行代码</span></span></a></li><li><a class="level is-mobile" href="#说明"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">说明</span></span></a></li></ul></li><li><a class="level is-mobile" href="#"><span class="level-left"><span class="level-item">2</span><span class="level-item">基础知识</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Unwrapping-说明"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Unwrapping 说明</span></span></a></li><li><a class="level is-mobile" href="#Option-类型"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Option 类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#组合-Option-T"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">组合 Option&lt;T&gt;</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Result-类型"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Result 类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#解析整数"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">解析整数</span></span></a></li><li><a class="level is-mobile" href="#Result-类型别名"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">Result 类型别名</span></span></a></li></ul></li><li><a class="level is-mobile" href="#小插曲：unwrapping-并非不能使用的"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">小插曲：unwrapping 并非不能使用的</span></span></a></li></ul></li><li><a class="level is-mobile" href="#"><span class="level-left"><span class="level-item">3</span><span class="level-item">使用多种错误类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#组合-Option-与-Result"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">组合 Option 与 Result</span></span></a></li><li><a class="level is-mobile" href="#组合器的限制"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">组合器的限制</span></span></a></li><li><a class="level is-mobile" href="#提取返回"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">提取返回</span></span></a></li><li><a class="level is-mobile" href="#try-宏-操作符"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">try! 宏/? 操作符</span></span></a></li><li><a class="level is-mobile" href="#定义自己的错误类型"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">定义自己的错误类型</span></span></a></li></ul></li><li><a class="level is-mobile" href="#"><span class="level-left"><span class="level-item">4</span><span class="level-item">用于错误处理的标准库 traits</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Error-trait"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">Error trait</span></span></a></li><li><a class="level is-mobile" href="#From-trait"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">From trait</span></span></a></li><li><a class="level is-mobile" href="#实际的-try-宏-操作符"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">实际的 try! 宏/ ? 操作符</span></span></a></li><li><a class="level is-mobile" href="#组合自定义错误类型"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">组合自定义错误类型</span></span></a></li><li><a class="level is-mobile" href="#对库作者的建议"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">对库作者的建议</span></span></a></li></ul></li><li><a class="level is-mobile" href="#"><span class="level-left"><span class="level-item">5</span><span class="level-item">案例学习: 读取人口数据</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#在-Github-上获取"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">在 Github 上获取</span></span></a></li><li><a class="level is-mobile" href="#初始化"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">初始化</span></span></a></li><li><a class="level is-mobile" href="#参数解析"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">参数解析</span></span></a></li><li><a class="level is-mobile" href="#编写程序逻辑"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">编写程序逻辑</span></span></a></li><li><a class="level is-mobile" href="#使用-Box-Error-进行错误处理"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">使用 Box&lt;Error&gt; 进行错误处理</span></span></a></li><li><a class="level is-mobile" href="#从-stdin-读取"><span class="level-left"><span class="level-item">5.6</span><span class="level-item">从 stdin 读取</span></span></a></li><li><a class="level is-mobile" href="#使用自定义类型进行错误处理"><span class="level-left"><span class="level-item">5.7</span><span class="level-item">使用自定义类型进行错误处理</span></span></a></li><li><a class="level is-mobile" href="#额外功能"><span class="level-left"><span class="level-item">5.8</span><span class="level-item">额外功能</span></span></a></li></ul></li><li><a class="level is-mobile" href="#"><span class="level-left"><span class="level-item">6</span><span class="level-item">概括</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.ico" alt="CZCC" height="28"></a><p class="is-size-7"><span>&copy; 2022 Cheng</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/czccc/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>